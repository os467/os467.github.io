
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Tly的博客</title>
        <meta name="author" content="Os467">
        <meta name="description" content="Welcome">
        <meta name="keywords" content="">
        <link rel="icon" href="https://img.gejiba.com/images/ad7295b88b395d72d985a0835695dd71.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Tly的博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Tly的博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(https://img.gejiba.com/images/d3d5ed8eab68b8414a1f6284d28676e7.png)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Tly的博客</h1>
                <h3>Hi,i'm os467</h3>
                <h5>Welcome</h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class=>
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/07/17/Ajax/">
        <h2>
            Ajax
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/17
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</p>
<h2 id="AJAX-是什么？"><a href="#AJAX-是什么？" class="headerlink" title="AJAX 是什么？"></a>AJAX 是什么？</h2><p>AJAX &#x3D; Asynchronous JavaScript and XML</p>
<p>AJAX 是一种用于创建快速<strong>动态网页</strong>的技术</p>
<p>AJAX 通过在后台与服务器进行少量数据交换，使网页实现<strong>异步更新</strong>，这意味着可以在不重载整个页面的情况下，对网页的某些<strong>部分进行更新</strong></p>
<p>传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个页面</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/08/ajax.gif"></p>
<h2 id="AJAX-基于因特网标准"><a href="#AJAX-基于因特网标准" class="headerlink" title="AJAX 基于因特网标准"></a>AJAX 基于因特网标准</h2><p>AJAX 基于因特网标准，并使用以下技术组合：</p>
<ul>
<li>XMLHttpRequest 对象（与服务器异步交互数据）</li>
<li>JavaScript&#x2F;DOM（显示&#x2F;取回信息）</li>
<li>CSS（设置数据的样式）</li>
<li>XML（常用作数据传输的格式）</li>
</ul>
<p><img src="https://www.runoob.com/images/lamp.gif" alt="lamp"> AJAX 应用程序与浏览器和平台无关的！</p>
<h2 id="AJAX-创建-XMLHttpRequest-对象"><a href="#AJAX-创建-XMLHttpRequest-对象" class="headerlink" title="AJAX - 创建 XMLHttpRequest 对象"></a>AJAX - 创建 XMLHttpRequest 对象</h2><hr>
<p>XMLHttpRequest 是 AJAX 的基础。</p>
<hr>
<h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><p>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 <code>ActiveXObject</code>）。</p>
<p>XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在<strong>不重新加载整个网页的情况下，对网页的某部分进行更新</strong></p>
<hr>
<h3 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h3><p>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p>
<p>创建 XMLHttpRequest 对象的语法：</p>
<pre><code class="javascript">variable = new XMLHttpRequest();
</code></pre>
<p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：</p>
<pre><code class="javascript">variable = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
</code></pre>
<p>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 <code>ActiveXObject </code>：</p>
<pre><code class="javascript">var xmlhttp; 
if (window.XMLHttpRequest) &#123;

//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码   
    xmlhttp=new XMLHttpRequest(); 

&#125; else &#123;    

// IE6, IE5 浏览器执行代码    
xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);

&#125;
</code></pre>
<h2 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h2><p>如需将请求发送到服务器，我们使用 <strong>XMLHttpRequest</strong> 对象的 <strong>open()</strong> 和 <strong>send()</strong> 方法：</p>
<p><code>open(method,url,async)</code></p>
<p>规定请求的类型、URL 以及是否异步处理请求。</p>
<ul>
<li>method：请求的类型；GET 或 POST</li>
<li><code>url</code>：文件在服务器上的位置</li>
<li><code>async</code>：true（异步）或 false（同步）</li>
</ul>
<pre><code class="javascript">xmlhttp.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);
xmlhttp.send();
</code></pre>
<p><code>send(string)</code></p>
<p>将请求发送到服务器。</p>
<ul>
<li>string：仅用于 POST 请求</li>
</ul>
<h2 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h2><p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 <code>responseText</code> 或 <code>responseXML</code> 属性。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>responseText</code></td>
<td align="center">获得字符串形式的响应数据。</td>
</tr>
<tr>
<td align="center"><code>responseXML</code></td>
<td align="center">获得 XML 形式的响应数据。</td>
</tr>
</tbody></table>
<h2 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a><code>onreadystatechange</code> 事件</h2><p>当<strong>请求被发送到服务器</strong>时，我们需要<strong>执行一些基于响应的任务</strong>。</p>
<p>每当 <code>readyState</code> <strong>改变</strong>时，就会触发 <code>onreadystatechange</code> 事件。</p>
<p><code>readyState</code> 属性存有 XMLHttpRequest 的状态信息。</p>
<p>下面是 XMLHttpRequest 对象的三个重要的属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>onreadystatechange</code></td>
<td align="center">存储函数（或函数名），每当 <code>readyState</code> 属性改变时，就会调用该函数。</td>
</tr>
<tr>
<td align="center"><code>readyState</code></td>
<td align="center">存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪</td>
</tr>
<tr>
<td align="center">status</td>
<td align="center">200: “OK” 404: 未找到页面</td>
</tr>
</tbody></table>
<p>在 <code>onreadystatechange</code> 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。</p>
<p>当 <code>readyState</code> 等于 4 且状态为 200 时，表示响应已就绪：</p>
<p><strong>后端进行一个简单的用户伪校验</strong></p>
<pre><code class="java">@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

    request.setCharacterEncoding(&quot;utf-8&quot;);
    response.setContentType(&quot;html/text;charset=utf-8&quot;);

    String username = request.getParameter(&quot;username&quot;);
    String password = request.getParameter(&quot;password&quot;);

    if (username.equals(&quot;jack001&quot;) &amp;&amp; password.equals(&quot;123456&quot;))&#123;

        response.getWriter().print(&quot;1&quot;);

    &#125;else &#123;

        response.getWriter().print(&quot;2&quot;);

    &#125;

&#125;
</code></pre>
<h3 id="Ajax-JS"><a href="#Ajax-JS" class="headerlink" title="Ajax(JS)"></a>Ajax(JS)</h3><p><strong>一个基于JS原生Ajax的用户数据后端校验</strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;原生js的ajax&lt;/title&gt;
&lt;/head&gt;

&lt;script&gt;

    //测试Ajax的函数
    function testAjax()&#123;

        let xmlHttp;

        //判断是不是ie浏览器
        if(window.XMLHttpRequest)&#123;

            xmlHttp = new XMLHttpRequest();

        &#125;else &#123;

            xmlHttp = ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);

        &#125;

        let usernameEl = document.getElementById(&quot;username&quot;);

        let passwordEl = document.getElementById(&quot;password&quot;);

        let username = usernameEl.value;

        let password = passwordEl.value;

        //设置参数
        xmlHttp.open(&quot;GET&quot;,&quot;http://localhost:8080/jQuery/test?username=&quot;+username+&quot;&amp;password=&quot;+password,true);

        //访问具体的服务，发送请求
        xmlHttp.send();

        //绑定监听事件
        xmlHttp.onreadystatechange = function ()&#123;

            //判断服务器和网页的状态
            if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200)&#123;

                //获取服务器响应的数据
                alert(xmlHttp.responseText);

            &#125;

        &#125;

    &#125;

&lt;/script&gt;

&lt;body&gt;
请输入用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; value=&quot;&quot;&gt;&lt;br&gt;
请输入用户名密码：&lt;input type=&quot;password&quot; id=&quot;password&quot; value=&quot;&quot;&gt;&lt;br&gt;
&lt;input type=&quot;button&quot; value=&quot;ajax监听事件按钮&quot; onclick=&quot;testAjax()&quot;&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Ajax-JQuery"><a href="#Ajax-JQuery" class="headerlink" title="Ajax(JQuery)"></a>Ajax(JQuery)</h3><p><strong>一个基于Ajax的用户登录校验</strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;jQuery的ajax&lt;/title&gt;
&lt;/head&gt;
&lt;script src=&quot;../jQuery/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;

   $(function ()&#123;

       $(&quot;[value=提交]&quot;).click(function ()&#123;

           //获取用户名和密码的值
           let username = $(&quot;#username&quot;).val();

           let password = $(&quot;#password&quot;).val();

           //调用ajax函数
           $.ajax(&#123;

               //提交到后端的地址
               url:&quot;http://localhost:8080/jQuery/test&quot;,

               //提交的方式
               type:&quot;POST&quot;,

               //提交到后端的数据
               data:&#123;
                   username:username,
                   password:password
               &#125;,

               //请求成功之后的回调函数，监听事件
               success:function (obj)&#123;

                   if (obj == &quot;1&quot;)&#123;

                       alert(&quot;登陆成功&quot;);

                       //跳转到页面
                       location.href = &quot;http://www.baidu.com&quot;;
                   &#125;else &#123;

                       alert(&quot;登陆失败&quot;);

                   &#125;

               &#125;,

               //服务端返回的数据类型text,html,json,xml
               dataType:&quot;text&quot;

           &#125;)


       &#125;)

   &#125;)

&lt;/script&gt;

&lt;body&gt;
&lt;table align=&quot;center&quot; border=&quot;1px&quot;&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;td colspan=&quot;2&quot;&gt;&lt;h3&gt;用户登录&lt;/h3&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            请输入用户名
        &lt;/td&gt;
        &lt;td&gt;
            &lt;input type=&quot;text&quot; id=&quot;username&quot; value=&quot;&quot;&gt;&lt;br&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            请输入密码
        &lt;/td&gt;
        &lt;td&gt;
            &lt;input type=&quot;password&quot; id=&quot;password&quot; value=&quot;&quot;&gt;&lt;br&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;td colspan=&quot;2&quot;&gt;
            &lt;input type=&quot;button&quot; value=&quot;提交&quot;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;


&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>jQuery中封装的ajax以JSON串的形式存值</strong></p>
<p>一些关键的<strong>key与value</strong>：</p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">url</td>
<td align="center">后端资源地址</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">“GET”、”POST”…</td>
</tr>
<tr>
<td align="center">data</td>
<td align="center">提交到后端的数据（JSON串）{username : username, password : password}</td>
</tr>
<tr>
<td align="center">success</td>
<td align="center">服务器反馈数据成功后执行的方法 function (object接收后端的参数){方法体}</td>
</tr>
<tr>
<td align="center">dataType</td>
<td align="center">服务端返回的数据类型text,html,json,xml   “text”</td>
</tr>
</tbody></table>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/17/Ajax/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/14/Annotation/">
        <h2>
            Annotation
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/14
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p><strong>什么是注解？</strong></p>
<p>是<strong>元数据(Annotation)</strong> ，是一种对代码进行说明的数据，JDK1.5引入的新<strong>规范</strong>，是与类、接口、枚举等引用类型处于同一个层次，可以用在包、类、属性、方法、方法的参数和局部变量等的前边，<strong>不影响代码的语义</strong>，可以对其进行<strong>解析</strong></p>
<p><strong>注解Annotation</strong>:  是一种<strong>引用数据类型</strong>(在类加载的时候会生成字节码文件)</p>
<p><strong>注解在以后的用途:</strong></p>
<p>​		注解的作用：</p>
<p>​		注解只能起到一个<strong>标识</strong>的作用</p>
<p><strong>spring框架</strong>：基于注解的开发模式</p>
<p>​		学习了反射可以不使用new关键字去创建一个类的实例</p>
<p>​		spring是一个容器里面会存放很多类的实例</p>
<p><strong>我怎么知道有哪些类需要去创建实例，那些类不需要创建实例?</strong></p>
<p>​		用注解去标识一下，需要创建实例的类，用注解去做一个标识</p>
<p>​		在spring框架检测到该类有注解时，就会通过反射机制去创建该类的实例</p>
<p><strong>beans</strong>： User、Student、Person、Animal</p>
<h2 id="创建一个注解"><a href="#创建一个注解" class="headerlink" title="创建一个注解"></a>创建一个注解</h2><pre><code class="java">public @interface MyAnnotation &#123;
    
&#125;
</code></pre>
<p>注解中可以拥有属性，但是<strong>不能拥有方法</strong></p>
<p>如果你给一个注解声明了属性，那么在注解<strong>修饰元素</strong>的时候，就必须要给属性<strong>赋值</strong>，除非你在声明属性的时候，给了属性默认值</p>
<h3 id="在注解中声明属性"><a href="#在注解中声明属性" class="headerlink" title="在注解中声明属性"></a>在注解中声明属性</h3><pre><code class="java">public @interface MyAnnotation &#123;

    //在注解中如何去声明属性
    String name() default &quot;&quot;;

    int i();

    String[] strings() default &#123;&quot;1&quot;,&quot;2&quot;&#125;;

    //枚举类型
    Math math() default Math.Max;
    
    Math[] maths() default &#123;Math.Max,Math.Count,Math.Sum&#125;;
    
&#125;
</code></pre>
<p><strong>在注解中定义属性只能时八大基本数据类型、字符串类型String、枚举类型、以及主要类型所对应的数组类型</strong></p>
<p>在定义属性时，如果属性名称是<strong>value</strong>，那在注解修饰元素，并且给属性赋值的时候，属性名称可以<strong>省略不写</strong></p>
<pre><code class="java">@MyAnnotation(name = &quot;123&quot;,i = 100)
</code></pre>
<h4 id="注解运用范围"><a href="#注解运用范围" class="headerlink" title="注解运用范围"></a>注解运用范围</h4><p>注解使用时的语法格式是：</p>
<p>​		@注解类型名</p>
<p>注解可以出现在类上、属性上、方法上、变量上等</p>
<p>注解可以出现在注解类型上</p>
<h3 id="JDK内置注解"><a href="#JDK内置注解" class="headerlink" title="JDK内置注解"></a>JDK内置注解</h3><p><strong>Deprecated</strong> 用 <code>@Deprecated</code> 注释的程序元素，不鼓励程序员使用这样的元素，通过是因为它很危险或存在更好的选择</p>
<p><strong>Override</strong>表示一个方法声明打算重写超类中的另一个方法声明</p>
<p><strong><code>SuppressWarnings</code></strong>  指示应该在注释元素（以及包含在该注释元素中的所有程序元素）中取消显示指定的编译器警告</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><strong>什么是元注解？</strong></p>
<p>用来标注“注解类型”的“注解”，称为元注解</p>
<p><strong>修饰注解的注解</strong></p>
<p>在定义注解时需要通过元注解指定例如注解的使用场合、是否生成文档、是否可以继承、注解保持的策略（是否能被反射机制所获取到）</p>
<p><strong>元注解</strong>：</p>
<p><code>@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</code>	表示注解的作用域</p>
<p>参数只能是枚举类型数组</p>
<pre><code class="java">//使得注解能标识在类和属性前
@Target(&#123;ElementType.TYPE,ElementType.FIELD&#125;)
public @interface MyAnnotation &#123;

&#125;
</code></pre>
<ul>
<li><p><code>@Retention(RetentionPolicy.RUNTIME)</code>	</p>
<p>注解的生命周期</p>
</li>
<li><p><code>RetentionPolicy(设置注解的生命周期以及保持性策略)</code>:</p>
<p>​	<strong>SOURCE</strong>：</p>
<p>​		当前注解只保留在源码这个层面上，在类加载的时候不会去生成字节码文件，而且不可以被反射机制所获取!</p>
<p>​		<strong>CLASS</strong>：</p>
<p>​		在类加载的时候会生成字节码文件，但是不可以被发射机制获取</p>
<p>​		<strong>RUNTIME</strong>：</p>
<p>​		在类加载的时候可以生成字节码文件，而且可以被反射机制获取工</p>
</li>
<li><p><code>@Inherited</code></p>
<p>标识允许子注解来继承这个注解（注意这里只能是继承不能是接口上使用，而且只能继承类上的注解，不能继承方法上的注解）</p>
</li>
<li><p><code>@Documented</code>	</p>
<p>生成JAVADOC时会包含注解</p>
</li>
</ul>
<h2 id="如何通过反射机制获取注解："><a href="#如何通过反射机制获取注解：" class="headerlink" title="如何通过反射机制获取注解："></a>如何通过反射机制获取注解：</h2><p>​		1、创建类对应的字节码对象</p>
<p>​		2、通过字节码对象获取注解字节码对象</p>
<pre><code class="java">public class Annotation01 &#123;

    public static void main(String[] args) &#123;


        try &#123;

            //创建字节码对象
            Class aClass = Class.forName(&quot;com.os467.pojo.User&quot;);

            //获取类上的注解
            MyAnnotation annotation = (MyAnnotation)aClass.getAnnotation(MyAnnotation.class);

            if (annotation != null)&#123;

                //获取注解上的属性
                System.out.println(annotation.name());

                //获取属性字节码对象
                Field[] declaredFields = aClass.getDeclaredFields();

                for (Field declaredField : declaredFields) &#123;

                    MyAnnotation annotation1 = declaredField.getAnnotation(MyAnnotation.class);

                    if (annotation1 != null)&#123;

                        System.out.println(declaredField.getName()+&quot; 这个属性上有注解&quot;);

                    &#125;

                &#125;

            &#125;

        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;


    &#125;

&#125;
</code></pre>
<h3 id="根据注解自动生成SQL查询语句"><a href="#根据注解自动生成SQL查询语句" class="headerlink" title="根据注解自动生成SQL查询语句"></a>根据注解自动生成SQL查询语句</h3><pre><code class="java">package com.os467;

import com.os467.Annotion.Table;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;


public class ORM &#123;

    private ORM()&#123;

    &#125;

    public static String getSql(Object obj)&#123;

        StringBuilder stringBuilder = new StringBuilder();

        //获取obj字节码对象
        Class aClass = obj.getClass();

        Table annotation = (Table)aClass.getAnnotation(Table.class);

        //表的名称
        String table = null;

        if (annotation != null)&#123;

            //获取表的名称
            table = annotation.value();

            stringBuilder.append(&quot;select * from &quot;+ table +&quot; where &quot;);

        &#125;

        //获取属性字节码对象
        Field[] declaredFields = aClass.getDeclaredFields();

        for (Field declaredField : declaredFields) &#123;

            //打破封装
            declaredField.setAccessible(true);

            com.os467.Annotion.Field annotation1 = declaredField.getAnnotation(com.os467.Annotion.Field.class);

            //注解不为空的情况下拼接
            if (annotation1 != null)&#123;

                try &#123;

                    //获取属性值
                    Object o = declaredField.get(obj);

                    //检查email属性是否有多个&quot;，&quot;隔开
                    if (o != null &amp;&amp; o.toString().contains(&quot;,&quot;))&#123;

                        stringBuilder.append(annotation1.value() + &quot; in(&quot; + o + &quot;) and&quot;);

                    &#125;else if (o != null &amp;&amp; !o.toString().equals(&quot;0&quot;))&#123;

                        stringBuilder.append(annotation1.value() + &quot; = &quot;);

                        if (o instanceof String)&#123;

                            stringBuilder.append(&quot;&#39;&quot; + o + &quot;&#39;&quot; + &quot; and &quot;);

                        &#125;

                        if (o instanceof Integer)&#123;

                            stringBuilder.append(o + &quot; and &quot;);

                        &#125;

                    &#125;


                &#125; catch (IllegalAccessException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;

        &#125;

        String s = stringBuilder.toString();

        //替换掉最后的and 
        s = s.substring(0,s.length() - 4);

        if (s.contains(&quot;=&quot;))&#123;

            return s;

        &#125;

        return null;
    &#125;

&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/14/Annotation/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/13/Reflect/">
        <h2>
            Reflect
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/13
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="反射Reflect"><a href="#反射Reflect" class="headerlink" title="反射Reflect"></a>反射Reflect</h1><p><strong>反射机制是干什么的</strong>：</p>
<ul>
<li>可以在类加载的时候去获取类的相关信息（属性、方法、实现的接口、继承的类）</li>
<li>反射可以通过字节码的方式来创建实例</li>
</ul>
<p><strong>反射在以后开发中的作用</strong>：</p>
<p>​		我们设计程序最终是要提高程序的执行效率，我们在开发一个模块的时候，要不停的去创建对象 <code>User user = new User();</code> 使用<strong>new</strong>关键字，会使得程序之间产生耦合，以后new关键字使用多了，耦合就会变高，程序的执行效率就会很差</p>
<p>​		这个时候我们能不能换一种方式去创建实例，尽量避免使用new关键字，反射机制就可以在<strong>不使用</strong>new的情况下去创建实例</p>
<p>​		反射是各大java框架的<strong>底层</strong>：框架就是帮助程序解耦，提高程序的执行效率，提高开发人员的开发效率</p>
<p>spring  框架：容器</p>
<ul>
<li>通过java语言中的反射机制可以操作字节码文件</li>
<li>通过反射机制可以操作代码片段</li>
<li><code>java.lang.reflect</code></li>
</ul>
<p><strong>什么是反射</strong>：</p>
<p>​		反射是java中比较偏底层的一种机制，通过反射可以在类加载时去获取类相关的信息</p>
<h2 id="如何去获取一个类的字节码对象（Class）"><a href="#如何去获取一个类的字节码对象（Class）" class="headerlink" title="如何去获取一个类的字节码对象（Class）"></a>如何去获取一个类的字节码对象（Class）</h2><p>​	<code>对象.getClass()</code></p>
<p>​	<code>类.class属性</code></p>
<p>​	<code>Class.forName(&quot;全类名&quot;)</code></p>
<ul>
<li><p><strong><code>java.lang.Class：</code></strong> </p>
<p>代表整个字节码，代表一个类型，代表整个<strong>类</strong></p>
</li>
<li><p><strong><code>java.lang.reflect.Method</code>：</strong></p>
<p>代表字节码中的方法字节码，代表类中的<strong>方法</strong></p>
</li>
<li><p><strong><code>java.lang.reflect.Constructor：</code></strong></p>
<p>代表字节码中的<strong>构造方法</strong>字节码，代表类中的构造方法</p>
</li>
<li><p><strong><code>java.lang.reflect.Field：</code></strong></p>
<p>代表字节码中的<strong>属性</strong>字节码，代表类中的成员变量（静态变量+实例变量）</p>
</li>
</ul>
<h2 id="获取类中的属性"><a href="#获取类中的属性" class="headerlink" title="获取类中的属性"></a>获取类中的属性</h2><h3 id="获取类中公共的属性"><a href="#获取类中公共的属性" class="headerlink" title="获取类中公共的属性"></a>获取类中公共的属性</h3><p><code>getField()</code></p>
<pre><code class="java">//获取字节码对象
 Class stuClass = Class.forName(&quot;com.os467.pojo.Student&quot;);

 //getField()这个方法只能去获取公共的属性
 Field address = stuClass.getField(&quot;address&quot;);

 System.out.println(address);
</code></pre>
<h3 id="获取类中所有的属性"><a href="#获取类中所有的属性" class="headerlink" title="获取类中所有的属性"></a>获取类中所有的属性</h3><p><code>getDeclaredField()</code></p>
<pre><code class="java">//getDeclaredField()这个方法可以去获取一个类中所有的属性
Field id = stuClass.getDeclaredField(&quot;id&quot;);

System.out.println(id);
</code></pre>
<p><code>getDeclaredFields()</code></p>
<pre><code class="java">//获取一个类中所有属性，封装成字节码数组
Field[] declaredFields = stuClass.getDeclaredFields();
</code></pre>
<p><strong>获取全类名</strong></p>
<pre><code class="java">String name = stuClass.getName();
</code></pre>
<p><strong>获取简类名</strong></p>
<pre><code class="java">String simpleName = stuClass.getSimpleName();
</code></pre>
<p><strong>获取属性的类型</strong></p>
<p><code>declaredField.getType()</code></p>
<p><strong>获取属性的修饰符</strong></p>
<pre><code class="java">//获取属性的修饰符代号
int modifiers = declaredField.getModifiers();

//将代号转成修饰符字符串
String string = Modifier.toSring(modifiers);

System.out.println(string);
</code></pre>
<p>在学习反射时，获取类的<strong>信息</strong>都是通过<strong>get方法</strong>去获取的</p>
<h2 id="获取类中的方法"><a href="#获取类中的方法" class="headerlink" title="获取类中的方法"></a><strong>获取类中的方法</strong></h2><p>由于java类中的方法支持重载，所以在调用<code>getMethod(方法名称,参数类型)</code>方法时需要将方法的<strong>参数类型</strong>传入，不传入则默认获取<strong>无参</strong>的方法</p>
<h3 id="获取类中公有的方法"><a href="#获取类中公有的方法" class="headerlink" title="获取类中公有的方法"></a>获取类中公有的方法</h3><pre><code class="java">public class ReflectDemo03 &#123;

    public static void main(String[] args) throws Exception &#123;

        //获取字节码对象
        Class stuClass = Student.class;

        //获取一个类中的方法
        Method setAge = stuClass.getMethod(&quot;setAge&quot;,Integer.class);

        System.out.println(setAge);

        Method study = stuClass.getMethod(&quot;study&quot;, int.class, double.class, String.class);

        System.out.println(study);

    &#125;
&#125;
</code></pre>
<h3 id="获取类中所有的方法"><a href="#获取类中所有的方法" class="headerlink" title="获取类中所有的方法"></a>获取类中所有的方法</h3><pre><code class="java">public class ReflectDemo03 &#123;

    public static void main(String[] args) throws Exception &#123;

        //获取字节码对象
        Class stuClass = Student.class;

        //获取一个类中所有的方法
        Method[] declaredMethods = stuClass.getDeclaredMethods();

        for (Method declaredMethod : declaredMethods) &#123;

            System.out.println(declaredMethod);

        &#125;

    &#125;
&#125;
</code></pre>
<p><strong>其它的方法</strong></p>
<pre><code class="java">for (Method method : declaredMethods) &#123;

    //获取方法名称
    System.out.println(&quot;方法名称&quot;+method.getName());

    //获取方法返回值类型
    System.out.println(&quot;返回值类型&quot;+method.getReturnType().getSimpleName());

    //获取方法的参数
    for (Class&lt;?&gt; parameterType : method.getParameterTypes()) &#123;

        System.out.println(&quot;方法的参数类型&quot;+parameterType);


    &#125;

    //获取修饰符
    int modifiers = method.getModifiers();

    //将修饰符代号转成字符串
    String s = Modifier.toString(modifiers);

    System.out.println(&quot;修饰符&quot;+s);

&#125;
</code></pre>
<h3 id="获取所有的构造"><a href="#获取所有的构造" class="headerlink" title="获取所有的构造"></a>获取所有的构造</h3><pre><code class="java">public static void main(String[] args) throws Exception &#123;


    //获取字节码对象
    Class aClass = Class.forName(&quot;com.os467.pojo.Student&quot;);

    //获取所有的构造
    Constructor[] declaredConstructors = aClass.getDeclaredConstructors();

    //遍历数组
    for (Constructor declaredConstructor : declaredConstructors) &#123;

        System.out.println(declaredConstructor);

    &#125;

&#125;
</code></pre>
<h2 id="反射工具类ReflectUtils"><a href="#反射工具类ReflectUtils" class="headerlink" title="反射工具类ReflectUtils"></a>反射工具类ReflectUtils</h2><p>写一个工具类，写一个静态方法，方法传入一个类的全类名，然后反编译（可以获取这个类中所有的信息）这个类工具类要适用于所有的类</p>
<p><strong>根据反射获取类的信息</strong></p>
<ul>
<li>1、根据流对象先读取配置文件中的全类名数据</li>
<li>2、根据全类名创建字节码对象</li>
<li>3、根据字节码对象去获取类的信息，完成类的反编译</li>
</ul>
<pre><code class="java">package com.os467.utils;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Properties;

/**
 * 反编译工具类
 */
public class ReflectUtils &#123;

    //构造私有化
    private ReflectUtils()&#123;

    &#125;

    /**
     * 根据反射获取类的信息
     * 1、根据流对象先读取配置文件中的全类名数据
     * 2、根据全类名创建字节码对象
     * 3、根据字节码对象去获取类的信息，完成类的反编译
     * @return
     */
    public static String getTypeMessageByReflect()&#123;

        //用于字符串的追加,效率要比String高
        StringBuilder stringBuilder = new StringBuilder();

        try &#123;

            //创建流对象
            FileReader fileReader = new FileReader(&quot;className.properties&quot;);

            //创建集合对象
            Properties properties = new Properties();

            //将配置文件中的数据装载到集合里面
            properties.load(fileReader);

            //根据全类名创建字节码对象
            Class aClass = Class.forName(properties.getProperty(&quot;className&quot;));

            stringBuilder.append(&quot;public class &quot;);
            stringBuilder.append(aClass.getSimpleName()+&quot; &#123; \n&quot;);
            //获取类中所有的属性
            Field[] declaredFields = aClass.getDeclaredFields();

            for (Field declaredField : declaredFields) &#123;

                stringBuilder.append(&quot;\n\t&quot;);

                //获取属性的修饰符
                int modifiers = declaredField.getModifiers();

                //转成修饰符字符串
                String s = Modifier.toString(modifiers);

                //获取属性类型
                String simpleName = declaredField.getType().getSimpleName();

                //获取属性的名称
                String name = declaredField.getName();

                stringBuilder.append(s+&quot; &quot;+simpleName+&quot; &quot;+name+&quot;;&quot;);
                stringBuilder.append(&quot;\n&quot;);

            &#125;

            //获取类的所有构造
            Constructor[] declaredConstructors = aClass.getDeclaredConstructors();

            //遍历数组
            for (Constructor declaredConstructor : declaredConstructors) &#123;

                stringBuilder.append(&quot;\n\t&quot;);

                //获取构造的修饰符
                int modifiers = declaredConstructor.getModifiers();

                //转成修饰符字符串
                String s = Modifier.toString(modifiers);

                //获取构造名称
                String name = aClass.getSimpleName();

                stringBuilder.append(s + &quot; &quot; + name + &quot;(&quot;);

                //获取参数列表
                Class[] parameterTypes = declaredConstructor.getParameterTypes();

                //遍历参数列表
                for (Class parameterType : parameterTypes) &#123;

                    //获取参数名
                    stringBuilder.append(parameterType.getSimpleName()+&quot;,&quot;);

                &#125;

                //判断有参的还是无参的
                if (parameterTypes.length &gt; 0)&#123;

                    //删除具体下标下面的字符
                    stringBuilder.deleteCharAt(stringBuilder.length() - 1);

                &#125;

                stringBuilder.append(&quot;) &#123;&#125;&quot;);

                stringBuilder.append(&quot;\n&quot;);

                //获取所有的普通方法
                Method[] declaredMethods = aClass.getDeclaredMethods();

                //遍历数组
                for (Method declaredMethod : declaredMethods) &#123;

                    stringBuilder.append(&quot;\n\t&quot;);

                    //获取方法的修饰符
                    int modifiers1 = declaredMethod.getModifiers();

                    //转成修饰符字符串
                    String s1 = Modifier.toString(modifiers1);

                    //获取返回值类型
                    String simpleName = declaredMethod.getReturnType().getSimpleName();

                    stringBuilder.append(s1 + &quot; &quot; +simpleName + &quot; &quot; + declaredMethod.getName()+&quot;(&quot;);

                    //获取普通方法的参数列表
                    Class[] parameterTypes1 = declaredMethod.getParameterTypes();

                    //遍历参数
                    for (Class parameterType : parameterTypes1) &#123;

                        stringBuilder.append(parameterType.getSimpleName()+&quot;,&quot;);

                        if (parameterTypes.length &gt; 0)&#123;

                            //删除最后一个逗号
                            stringBuilder.deleteCharAt(stringBuilder.length() - 1);

                        &#125;

                    &#125;
                    stringBuilder.append(&quot;)&#123;&#125;&quot;);

                    stringBuilder.append(&quot;\n&quot;);

                &#125;

            &#125;

            stringBuilder.append(&quot;\n&#125;&quot;);

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;


        return stringBuilder.toString();
    &#125;


&#125;
</code></pre>
<p><strong>反射</strong></p>
<ul>
<li>通过反射机制访问对象的某个属性</li>
<li>通过反射机制调用对象的某个方法</li>
<li>通过反射机制调用某个构造方法实例化对象</li>
<li>通过反射机制获取父类及父类型接口</li>
</ul>
<p>获取父类</p>
<pre><code class="java">Class superclass = aClass.getSuperclass();
</code></pre>
<p>获取实现的接口</p>
<pre><code class="java">Class[] interfaces = aClass.getInterfaces();
</code></pre>
<h2 id="如何通过反射机制来创建一个类的实例"><a href="#如何通过反射机制来创建一个类的实例" class="headerlink" title="如何通过反射机制来创建一个类的实例"></a>如何通过反射机制来创建一个类的实例</h2><p><strong>无参构造实例</strong></p>
<p><strong><code>newInstance()</code></strong></p>
<pre><code class="java"> //获取字节码对象
Class aClass = Student.class;

//如何通过反射机制来创建一个类的实例
//默认情况下调用的是无参构造
Object o = aClass.newInstance();

if (o instanceof Student)&#123;

    Student student = (Student)o;

    System.out.println(student);

&#125;
</code></pre>
<p><strong>有参构造实例</strong></p>
<p><code>getDeclaredConstructor()</code>	不传参数就是获取无参构造实例</p>
<pre><code class="java">public static void main(String[] args) throws Exception &#123;

    //创建字节码对象
    Class aClass = User.class;

    //获取构造字节码对象
    Constructor constructor = aClass.getDeclaredConstructor(String.class,String.class);

    Object obj02 = constructor.newInstance(&quot;root&quot;, &quot;123456&quot;);

    System.out.println(obj02);
    
&#125;
</code></pre>
<h3 id="如何通过反射来给属性赋值"><a href="#如何通过反射来给属性赋值" class="headerlink" title="如何通过反射来给属性赋值"></a>如何通过反射来给属性赋值</h3><pre><code class="java">//获取属性，返回属性字节码对象
Field addressFiled = aClass.getDeclaredField(&quot;address&quot;);

//给属性进行一个赋值操作
//Object obj 属性所在类的实例
//Object value 具体要赋的值
addressFiled.set(o,&quot;南京市&quot;);

//通过反射获取属性具体的值
System.out.println(addressFiled.get(o));

System.out.println(o);
</code></pre>
<h3 id="如何通过反射获取属性值"><a href="#如何通过反射获取属性值" class="headerlink" title="如何通过反射获取属性值"></a>如何通过反射获取属性值</h3><p><strong>方法一</strong>：</p>
<p>先打破封装，再通过set方法给属性赋值</p>
<pre><code class="java">//获取属性字节码对象
Field declaredFieldName = aClass.getDeclaredField(&quot;name&quot;);

//打破封装
declaredFieldName.setAccessible(true);

//通过反射机制来创建一个类的实例
//采用的无参构造创建的实例
Object o = aClass.newInstance();

//调用set方法给属性赋值
declaredFieldName.set(o,&quot;张三&quot;);

System.out.println(o);
</code></pre>
<p><strong>方法二</strong>：</p>
<p>通过反射调用这个<strong>属性</strong>所对应的set方法给属性赋值</p>
<h2 id="通过反射调用类中的方法"><a href="#通过反射调用类中的方法" class="headerlink" title="通过反射调用类中的方法"></a>通过反射调用类中的方法</h2><pre><code class="java">public static void main(String[] args) throws Exception &#123;

    //获取字节码对象
    Class userClass = User.class;

    //获取方法字节码对象
    Method declaredMethod = userClass.getDeclaredMethod(&quot;login&quot;,String.class,String.class);

    //通过反射创建实例
    Object o = userClass.newInstance();

    //调用方法
    //通过反射调用方法的方法
    //Object var1 当前方法所在类的实例
    //Object... var2 你需要传的参数
    Object invoke = declaredMethod.invoke(o, &quot;zs001&quot;, &quot;123456&quot;);

    System.out.println(invoke);


&#125;
</code></pre>
<p><strong>注意</strong>：操作私有的方法需要打破封装</p>
<pre><code class="java">declaredMethod.setAccessible(true);
</code></pre>
<h4 id="反射在以后的用途"><a href="#反射在以后的用途" class="headerlink" title="反射在以后的用途"></a>反射在以后的用途</h4><p>反射最重要的用途就是开发各种通用框架，比如在spring中，我们将所有的类Bean交给spring容器管理，无论是XML配置Bean还是注解配置，当我们从容器中获取Bean来依赖注入时，容器会读取配置，而配置中给的就是类的信息，spring根据这些信息，需要创建那些Bean，spring就动态的创建这些类，还有在struts2的struts.xml中配置action，也是通过反射调用的action</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/13/Reflect/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/12/多线程/">
        <h2>
            多线程
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/12
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><ul>
<li><p>进程:是操作系统中一个程序及其数据在处理机上顺序执行时所发生的活动</p>
</li>
<li><p>线程:也成轻量进程，是进程中某个<strong>单一顺序</strong>的控制流（进程中的某一新单元）</p>
</li>
<li><p>多进程:在<strong>操作系统</strong>中同时运行多个任务(程序)</p>
</li>
<li><p>多线程:在同一应用<strong>程序</strong>中有多个顺序流同时执行</p>
</li>
<li><p>线程的生命周期:一个线程从创建到执行完的整个过程</p>
</li>
</ul>
<p><strong>线程与进程的区别</strong>：</p>
<p>​		进程对应的是一个服务，线程是进程中的执行单元</p>
<p>​		一个进程可以包含多个线程，一个线程一定属于某个进程</p>
<p>​		多线程特点：线程是<strong>异步</strong>的，线程是<strong>并发</strong>的，多个线程同时工作，线程与线程之间是互不干扰的</p>
<p>​		例子：火车站（进程）和售票窗口（线程）火车站 的关系</p>
<h2 id="关于线程的创建方式"><a href="#关于线程的创建方式" class="headerlink" title="关于线程的创建方式"></a>关于线程的创建方式</h2><p><strong>三种方法</strong>：</p>
<ul>
<li><p>继承Thread类</p>
</li>
<li><p>实现Runnable接口 &#x2F; 通过匿名内部类来创建线程对象</p>
</li>
<li><p>使用Callable结合Task实现多线程</p>
</li>
</ul>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p><strong>方法一</strong>：继承<strong>Thread</strong>类，重写<code>run()</code>方法</p>
<pre><code class="java">package com.os467.thread;

public class ThreadDemo01 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象
        ThreadImpl01 threadImpl01 = new ThreadImpl01();
        ThreadImpl01 threadImpl02 = new ThreadImpl01();

        //开启线程
        threadImpl01.start();
        threadImpl02.start();

    &#125;

&#125;


class ThreadImpl01 extends Thread&#123;

    /**
     * 让程序跑起来的方法
     */
    @Override
    public void run() &#123;

        for (int i = 0; i &lt; 10; i++) &#123;

            System.out.println(&quot;第&quot;+(i + 1)+&quot;个数为&quot;+i);

        &#125;


    &#125;
&#125;
</code></pre>
<h4 id="设置线程的名称"><a href="#设置线程的名称" class="headerlink" title="设置线程的名称"></a>设置线程的名称</h4><pre><code class="java">//设置线程的名称
threadImpl01.setName(&quot;t1&quot;);
threadImpl02.setName(&quot;t2&quot;);
</code></pre>
<p><strong>获取当前正在运行的线程</strong></p>
<pre><code class="java">class ThreadImpl01 extends Thread&#123;

     //获取当前正在运行的线程
    Thread thread = Thread.currentThread(); 
    
    System.out.println(thread.getName()+&quot;正在执行&quot;);

&#125;
</code></pre>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p><strong>方法二</strong>：实现一个Runnable接口</p>
<p>此方法的实现类只是一个<strong>可运行类</strong>，不能被称为线程类</p>
<pre><code class="java">package com.os467.thread;

public class ThreadDemo02 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象
        RunnableImpl02 runnableImpl02 = new RunnableImpl02();

        //创建线程类
        Thread thread1 = new Thread(runnableImpl02);

        Thread thread2 = new Thread(runnableImpl02);


        //设置线程名称
        thread1.setName(&quot;t1&quot;);

        //设置线程名称
        thread2.setName(&quot;t2&quot;);

        //开启线程
        thread1.start();

        //开启线程
        thread2.start();


    &#125;

&#125;

/**
 * 可运行类
 */
class RunnableImpl02 implements Runnable&#123;


    @Override
    public void run() &#123;

        for (int i = 0; i &lt; 10; i++) &#123;

            //获取当前正在运行的线程
            Thread thread = Thread.currentThread();

            System.out.println(thread.getName()+&quot;正在执行：&quot;+(i + 1)+&quot;个数为&quot;+i);

        &#125;

    &#125;

&#125;
</code></pre>
<h3 id="通过匿名内部类来创建线程对象"><a href="#通过匿名内部类来创建线程对象" class="headerlink" title="通过匿名内部类来创建线程对象"></a>通过匿名内部类来创建线程对象</h3><pre><code class="java">package com.os467.thread;

public class ThreadDemo03 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象
        Thread thread1 = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;

                for (int i = 0; i &lt; 10; i++) &#123;

                    System.out.println(Thread.currentThread().getName()+&quot; : &quot;+i);

                &#125;

            &#125;
        &#125;);

        //创建线程对象
        Thread thread2 = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;

                for (int i = 0; i &lt; 10; i++) &#123;

                    System.out.println(Thread.currentThread().getName()+&quot; : &quot;+i);

                &#125;

            &#125;
        &#125;);

        thread1.setName(&quot;t1&quot;);
        thread2.setName(&quot;t2&quot;);

        //开启线程
        thread1.start();
        thread2.start();

    &#125;

&#125;
</code></pre>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul>
<li><p>新建状态</p>
<p>​	创建出线程对象之后，线程就处于新建状态</p>
</li>
<li><p>就绪状态</p>
</li>
</ul>
<p>​			当一个线程调用了<code>start()</code>方法之后，该线程处于就绪状态，处于就绪状态的线程拥有争夺CPU资源的使用权力</p>
<ul>
<li>运行状态</li>
</ul>
<p>​			当一个线程<strong>争夺到了CPU使用权</strong>之后，就回去执行线程，运行run方法，这个时候的线程处于运行状态</p>
<ul>
<li>阻塞状态</li>
</ul>
<p>​			当线程在运行的过程中出现了控制台打印、睡眠sleep等需要等待的操作，这个时候线程会处于阻塞状态，处于阻塞状态的线程，会释放CPU使用权</p>
<ul>
<li>死亡状态</li>
</ul>
<p>​			当一个线程执行完run方法中所有的代码就会跳出run方法，这个时候线程处于死亡状态   <code>isAlive()方法</code>可以判断线程是否存活</p>
<pre><code class="java">package com.os467.thread;

public class ThreadDemo04 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象,该线程处于新建状态
        ThreadImpl02 threadImpl01 = new ThreadImpl02();
        ThreadImpl02 threadImpl02 = new ThreadImpl02();

        threadImpl01.setName(&quot;t1&quot;);
        threadImpl02.setName(&quot;t2&quot;);

        //该线程处于就绪状态
        threadImpl01.start();
        threadImpl02.start();

    &#125;

&#125;


class ThreadImpl02 extends Thread&#123;

    @Override
    public void run() &#123;//当某一个线程争夺到cpu使用权后才会进入run方法

        for (int i = 0; i &lt; 10; i++) &#123;

            System.out.println(Thread.currentThread().getName() + &quot;======&gt;&quot;+i);

            //睡眠的方法，可以让程序处于阻塞状态
            try &#123;
                Thread.sleep(500);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;

    &#125;

    //当某一线程执行完了run方法，那该线程处于死亡状态
&#125;
</code></pre>
<p><strong>Run方法和start方法的区别</strong></p>
<p>Run是执行方法，start是启动方法</p>
<p>start启动不一定执行run方法</p>
<p><strong>线程调度模型</strong></p>
<ul>
<li>抢占式调度模式</li>
</ul>
<p>​		哪个线程的优先级比较高，抢到的CPU时间片的概率就多一些，java采用的就是抢占式调度模型			</p>
<ul>
<li>均分式调度模型</li>
</ul>
<p>​		平均分配CPU时间片，每个线程占用的CPU时间片时间长度一样，平均分配，一切平等，有一些编程语言，线程调度模型采用		的是这种方式</p>
<p>使用哪种方式<strong>创建线程</strong>比较好？</p>
<p>​		实现runnable接口，因为我们以后是面向接口开发</p>
<p>​		因为如果继承了Thread类，那么类的可扩展性就降低了</p>
<p>​		以后我们在写程序，尽量使用Runnable接口方式来创建线程对象，面向接口开发，程序的可扩展性会提高</p>
<p><strong>问题</strong>:以下代码一共开启了<strong>几个</strong>线程？</p>
<pre><code class="java">package com.os467.thread;

public class ThreadDemo05 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象
        Thread thread1 = new Thread(new MyRunnable());
        Thread thread2 = new Thread(new MyRunnable());
        Thread thread3 = new Thread(new MyRunnable());

        thread1.setName(&quot;t1&quot;);
        thread3.setName(&quot;t3&quot;);

        thread1.start();
        thread2.run();
        thread3.start();

        for (int i = 0; i &lt; 10; i++) &#123;

            System.out.println(Thread.currentThread().getName() + &quot; ==&gt; &quot;+i);

        &#125;

    &#125;


&#125;


class MyRunnable implements Runnable&#123;

    @Override
    public void run() &#123;


        for (int i = 0; i &lt; 10; i++) &#123;

            System.out.println(Thread.currentThread().getName() + &quot; ==&gt; &quot;+i);

        &#125;

        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;


    &#125;


&#125;
</code></pre>
<p><strong>答案</strong>:一共开启了4个线程：</p>
<p>​		两个普通线程	调用了<code>start()</code>方法</p>
<p>​		守护线程（后台线程）：垃圾回收线程</p>
<p>​		主线程（<code>main线程</code>）：JVM调用主函数</p>
<h4 id="线程在内存上的分布，以及执行流程"><a href="#线程在内存上的分布，以及执行流程" class="headerlink" title="线程在内存上的分布，以及执行流程"></a>线程在内存上的分布，以及执行流程</h4><ul>
<li>​		每一个线程都会去对应一个栈，创建的每个线程，JVM都会去开辟出一个分支栈</li>
<li>​		main中 针对于某个线程调用了start方法，这个时候，JVM会为这个线程单独的开辟出一个分支栈</li>
<li>​		假如程序中开启了t1、t2、t3 三个线程，<strong>栈与栈之间的资源是不共享的</strong></li>
<li>​		比如 t1对应的分支栈声明了一个集合对象List，这个集合的引用在别的栈是访问不到的</li>
</ul>
<p>在主线程调用了start方法之后，会开辟分支栈，每个栈都会去执行不同的任务，栈与栈之间的资源是不共享的</p>
<p>堆的资源是共享的，因为JVM上只有一个堆，只要你去创建引用数据类型的实例，都是在堆中开辟空间</p>
<p>方法区中的资源也是共享的，因为内存中只能有一个方法区</p>
<p><strong>获取、设置线程优先级方法</strong></p>
<pre><code class="java">//获取某个线程的优先级,java默认情况下线程优先级是5
int priority1 = thread1.getPriority();
</code></pre>
<pre><code class="java">//设置线程优先级方法，1-10，1优先级最低，10最高
thread1.setPriority(1);
</code></pre>
<h4 id="yield-让位方法"><a href="#yield-让位方法" class="headerlink" title="yield()让位方法"></a>yield()让位方法</h4><p>暂停当前正在执行的线程对象，并执行其他线程</p>
<p><code>yield()</code>方法的执行会让当前线程从”运行状态”回到”就绪状态”</p>
<p><code>Thread.yield();</code></p>
<h2 id="多线程其它方法"><a href="#多线程其它方法" class="headerlink" title="多线程其它方法"></a>多线程其它方法</h2><h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h4><p><code>join()</code>当前线程进入阻塞，指定线程执行，直到指定<strong>线程结束</strong>当前线程才可以继续</p>
<p>线程a{</p>
<p>​		线程b.join()</p>
<p>}</p>
<p>将线程b合并入线程a，线程a等待线程b<strong>结束</strong>后才继续运行</p>
<p><strong>注意</strong>：线程合并必须要有两个不同的线程</p>
<hr>
<p><code>suspend()</code>线程自己把自己挂起</p>
<p><code>resume</code>线程自己把自己唤醒</p>
<p><strong>龟兔赛跑案例</strong></p>
<p>兔子线程类</p>
<pre><code class="java">package com.os467.game;

//兔子线程
public class Rabbit extends Thread &#123;

    private String name;

    public Rabbit(String name) &#123;
        //给当前的线程实例设置名称
        super(name);
        this.name = name;
    &#125;


    @Override
    public void run() &#123;

        //模拟整个赛道跑步的过程
        for (int i = 0; i &lt;= 900; i+=100) &#123;

            if(i == 800)&#123;

                System.out.println(Thread.currentThread().getName()+&quot;开始睡觉&quot;);

                //自己把自己挂起
                Thread.currentThread().suspend();

            &#125;

            System.out.println(Thread.currentThread().getName() + &quot;跑了&quot;+(i+100)+&quot;米&quot;);

            try&#123;

                //模拟睡眠
                Thread.sleep(1000);


            &#125;catch (Exception e)&#123;

                e.printStackTrace();

            &#125;

        &#125;


        System.out.println(Thread.currentThread().getName()+&quot;跑完了全程,最终比赛失败&quot;);

    &#125;

&#125;
</code></pre>
<p>乌龟线程类</p>
<pre><code class="java">package com.os467.game;

//乌龟线程类
public class Tortoise extends Thread &#123;

    private String name;

    //兔子的引用
    private Rabbit rabbit;

    public Tortoise(String name, Rabbit rabbit) &#123;
        //给当前的线程实例设置名称
        super(name);
        this.name = name;
        this.rabbit = rabbit;
    &#125;

    //唤醒兔子的方法
    public void resumeRabbit()&#123;

        System.out.println(Thread.currentThread().getName()+&quot; 唤醒了 &quot;+rabbit.getName());

        //调用唤醒的方法
        this.rabbit.resume();

    &#125;

    @Override
    public void run() &#123;

        //模拟整个赛道跑步的过程
        for (int i = 0; i &lt;= 950; i+=50) &#123;

            System.out.println(Thread.currentThread().getName() + &quot;跑了&quot;+(i+50)+&quot;米&quot;);

            try&#123;

                //模拟睡眠
                Thread.sleep(1000);


            &#125;catch (Exception e)&#123;

                e.printStackTrace();

            &#125;

        &#125;

        //乌龟唤醒兔子
        this.resumeRabbit();

        System.out.println(Thread.currentThread().getName()+&quot;跑完了全程,取得了胜利&quot;);

    &#125;
&#125;
</code></pre>
<p>测试类</p>
<pre><code class="java">package com.os467.game;

public class Test &#123;

    public static void main(String[] args) &#123;

        //创建兔子线程
        Rabbit rabbit = new Rabbit(&quot;兔子&quot;);

        //创建乌龟线程
        Tortoise tortoise = new Tortoise(&quot;乌龟&quot;,rabbit);

        //开启线程
        rabbit.start();
        tortoise.start();

    &#125;

&#125;
</code></pre>
<hr>
<p>&#x2F;&#x2F;<code>tl.stop()</code>中断线程</p>
<p>&#x2F;&#x2F;<code>interrupt</code>中断睡眠</p>
<p>&#x2F;&#x2F;<code>tl.isAlive()</code>判断指定线程是否处于活动状态</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ul>
<li>java语言中线程分为两大类</li>
</ul>
<p>用户线程</p>
<p>守护线程（后台线程）</p>
<ul>
<li>守护线程的特点</li>
</ul>
<p>一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束</p>
<p>守护线程一般指的是后台线程，守护线程一般会去守护一个用户线程，用户线程启动，守护线程随之启动，用户线程结束，守护线程也结束，例如垃圾回收线程</p>
<p>设置守护线程<strong>方法</strong>:<code>普通线程对象.setDaemon(true)</code></p>
<pre><code class="java">package com.os467;

public class ThreadDemo01 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象
        Thread t1 = new Thread(new createThread());

        //将一个普通线程设置为守护线程
        t1.setDaemon(true);

        //开启线程
        t1.start();

        for (int i = 0; i &lt; 10; i++) &#123;

            System.out.println(Thread.currentThread().getName()+&quot; ===&gt; &quot;+i);

            try &#123;
                Thread.sleep(500);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;

    &#125;

&#125;

class createThread implements Runnable&#123;


    @Override
    public void run() &#123;

        //守护线程一般就是一个死循环
        while (true)&#123;

            System.out.println(&quot;守护线程正在执行&quot;);

            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>定时器</strong></p>
<ul>
<li>定时器的作用：间隔特定的时间，执行特定的程序</li>
</ul>
<p>​	在java的类库中已经写好了一个定时器：<code>java.util.Timer</code></p>
<h3 id="实现线程的第三种方式（Callable结合Task）"><a href="#实现线程的第三种方式（Callable结合Task）" class="headerlink" title="实现线程的第三种方式（Callable结合Task）"></a>实现线程的第三种方式（Callable结合Task）</h3><ul>
<li>使用Callable结合Task实现多线程编程</li>
</ul>
<p><code>FutureTask futureTask = new FutureTask(new Callable())</code></p>
<pre><code class="java">public class ThreadDemo02 &#123;

    public static void main(String[] args) &#123;

        //这个类官方称之为未来任务类，不是线程类
        FutureTask futureTask = new FutureTask(new Callable() &#123;

            //作用类似于run方法
            @Override
            public Object call() throws Exception &#123;

                int num = 0;

                for (int i = 0; i &lt; 10; i++) &#123;

                    num += i;

                    System.out.println(Thread.currentThread().getName() + &quot;===&gt;&quot; + i);

                    Thread.sleep(500);

                &#125;

                return num;

            &#125;
        &#125;);

        //创建线程对象
        Thread thread = new Thread(futureTask);

        //设置线程名称
        thread.setName(&quot;t1&quot;);

        //开启线程
        thread.start();

        //线程结束之后获取线程的返回值
        try &#123;

            Object o = futureTask.get();

            System.out.println(&quot;最终累加的结果为:&quot;+o);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; catch (ExecutionException e) &#123;
            e.printStackTrace();
        &#125;



    &#125;

&#125;
</code></pre>
<p><strong>缺点</strong>：由于需要获取返回值，此方法会造成原线程的阻塞</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li><strong>异步编程模型</strong></li>
</ul>
<p>​		线程A和线程B,各自执行各自的，A不管B，B不管A，谁也不需要等谁，这种编程模型叫做:异步编程模型，其实就是：多线程<strong>并发</strong>，效率较高</p>
<ul>
<li><strong>同步编程模型</strong></li>
</ul>
<p>​		线程A和线程B，在线程A执行的时候，必须等待B线程执行结束，或者说在A线程执行的时候，必须等待B线程执行结束，两个线程之间发生了等待关系，这就是同步程模型，效率较低</p>
<h2 id="锁池和等待池"><a href="#锁池和等待池" class="headerlink" title="锁池和等待池"></a>锁池和等待池</h2><ul>
<li><p><strong>锁池</strong></p>
<p>​		假设线程A已经拥有了某个<strong>对象</strong>(不是类)的锁，而其它线程B,C想要调用这个对象的某个<strong>synchronized方法</strong>(或者块)之前必须获得该对象锁的<strong>拥有权</strong>，而恰巧该对象的锁目前正被A所<strong>占有</strong>，此时B，C线程就会被<strong>阻塞</strong>，进入一个地方去<strong>等待</strong>锁的释放，这个地方便是该对象的锁池</p>
</li>
<li><p><strong>等待池</strong></p>
</li>
</ul>
<p>​		假设线程A调用了某个对象的<strong>wait方法</strong>，线程A就会<strong>释放</strong>该对象的锁，同时线程A就进入到了该对象的<strong>等待池</strong>中，进入等待池中的线程<strong>不会去竞争</strong>该对象的锁</p>
<h2 id="Object类中的wait和notify方法"><a href="#Object类中的wait和notify方法" class="headerlink" title="Object类中的wait和notify方法"></a>Object类中的wait和notify方法</h2><ul>
<li><code>wait()</code> 让正在该对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止。<code>wait()</code>方法的调用，会让正在改对象的当前线程进入等待状态</li>
</ul>
<p>此对象其实就是多线程中的<strong>共享对象</strong></p>
<p>使用此方法必须保证当前多线程处于<strong>线程同步状态</strong></p>
<p>当共享对象是类的实例的时候，可以直接在类的方法中写<code>wait</code>和<code>notify</code>方法</p>
<p><strong>notify()方法作用</strong></p>
<p>​		只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</p>
<p><strong><code>notifyAll()</code>方法的作用</strong></p>
<p>​		会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会</p>
<p><strong>需求：生产者和消费者关系</strong>：</p>
<p><strong>仓库</strong></p>
<p>仓库里面存放的就是生产者生产出来的商品，需要交给消费者去消费</p>
<p>要保证生产者与消费者均衡的状态：</p>
<p>如果仓库中没有产品了，这个时候消费者线程就不能再进行消费了，需要交给生产者线程去生产，如果仓库已经满了，仓库已经有产品的情况下，生产者线程就不用再生产了，要交由消费者线程去消费</p>
<p>生产者与消费者wait、notify</p>
<p>​		要想使用wait和notify方法，必须是在<strong>线程同步</strong>的前提下</p>
<p><strong>Consumer</strong></p>
<pre><code class="java">package com.os467.wait;

public class Consumer extends Thread &#123;

    private House house;

    public Consumer(String name,House house)&#123;

        super(name);
        this.house = house;

    &#125;

    @Override
    public void run() &#123;

        //模拟一直生产
        while (true) &#123;

            synchronized (this.house) &#123;

                if (this.house.getObjects().size() == 0) &#123;

                    //消费者不能再消费，要让这个消费者处于等待状态
                    try &#123;

                        //让处于该对象上活跃的线程处于等待状态
                        this.house.wait();

                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;

                &#125;

                //仓库中有产品，消费者就要去消费
                Object obj = this.house.getObjects().remove(0);

                System.out.println(Thread.currentThread().getName() + &quot;消费了一个产品，产品实例为&quot; + obj);

                try &#123;
                    //模拟睡眠
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;

                //唤醒生产者去生产
                this.house.notifyAll();

            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>House</strong></p>
<pre><code class="java">package com.os467.wait;

import java.util.List;

//仓库，用于存放产品的
public class House &#123;

    private List&lt;Object&gt; objects;

    public House(List&lt;Object&gt; objects) &#123;
        this.objects = objects;
    &#125;

    public List&lt;Object&gt; getObjects() &#123;
        return objects;
    &#125;

    public void setObjects(List&lt;Object&gt; objects) &#123;
        this.objects = objects;
    &#125;

&#125;
</code></pre>
<p><strong>Producer</strong></p>
<pre><code class="java">package com.os467.wait;

/**
 * 需求：
 *      生产者线程在什么情况下不需要生产产品？
 *      当仓库中的产品满足一定数量之后，就不用再生产了
 *
 *      只要当仓库中有产品，就要交由消费者去消费，消费者消费完了，仓库中没产品了，就继续交由生产者去生产
 */
public class Producer extends Thread &#123;

    //创建仓库的引用
    private House house;

    public Producer(String name,House house)&#123;

        super(name);
        this.house = house;

    &#125;

    @Override
    public void run() &#123;

        //模拟一直生产
        while (true) &#123;

            synchronized (this.house) &#123;

                if (this.house.getObjects().size() &gt; 0) &#123;

                    //生产者不能再生产，要让这个生产者处于等待状态
                    try &#123;

                        //让处于该对象上活跃的线程处于等待状态
                        this.house.wait();

                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;

                &#125;

                //如果仓库中没有产品，生产者要继续生产
                this.house.getObjects().add(new Object());

                System.out.println(Thread.currentThread().getName() + &quot;生产了一个产品，产品实例为&quot; + this.house.getObjects().get(0));

                try &#123;
                    //模拟睡眠
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;

                //唤醒此对象的消费者线程去消费
                this.house.notifyAll();

            &#125;
        &#125;

    &#125;

&#125;
</code></pre>
<p><strong>WaitDemo</strong></p>
<pre><code class="java">package com.os467.wait;

import java.util.ArrayList;

public class WaitDemo &#123;

    public static void main(String[] args) &#123;

        //创建仓库对象
        House house = new House(new ArrayList&lt;&gt;());

        //创建生产者线程
        Producer producer = new Producer(&quot;生产者&quot;,house);

        //创建消费者线程
        Consumer consumer = new Consumer(&quot;消费者&quot;,house);

        //启动线程
        producer.start();
        consumer.start();


    &#125;

&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/12/多线程/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/10/IO流/">
        <h2>
            IO流
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/10
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h2><p><strong>什么是IO流</strong></p>
<p>​	io流就是内存和硬盘上完成对数据的读和写</p>
<p>I：Input</p>
<p>O：Output</p>
<p>通过IO可以完成硬盘文件的读和写</p>
<p>往内存中去，叫做<strong>输入</strong>（Input），或者叫做<strong>读</strong>（Read）</p>
<p>从内存中出来，叫做<strong>输出</strong>（Output），或者叫做<strong>写</strong>（Write）</p>
<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><p><strong>字节和字符</strong>：</p>
<p>​		字节（Byte）是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位</p>
<p>​		字符就是键盘上所有的符号，包括英文，汉字等</p>
<p>​		针对于每一个字符，都有固定的Ascll码与之对应，<code>!</code>占了一个字节，然后根据字节流读取数据的时候，读取的是<code>!</code>这个字符所对应的AscII码</p>
<p>​		像特殊符号、英文在java中占了一个字节，汉字<code>你</code>在java中占了两个字节</p>
<p>有的流时按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制位</p>
<p>按照字符的方式读取数据的，一次读取一个字符，这种流是为了方便读取普通文本文件而存在的</p>
<ul>
<li><strong>字节流</strong></li>
</ul>
<p>​			字节流在读取数据的时候，会遍历文件中的字符，然后读取的是每个字符所对应的asII码</p>
<p>​			字节流可以读取任意类型的文件（普通文本，视频，录音，图片…）</p>
<ul>
<li><strong>字符流</strong></li>
</ul>
<p>​			在读取数据的时候，就是一个字符一个字符的进行读取，字符流的效率比较高，但是只能读取普通文本</p>
<p><strong>流的分类</strong></p>
<p><strong>java.io.InputStream</strong>		字节输入流</p>
<p>读取硬盘数据到内存</p>
<p><strong>java.io.OutputStream</strong>		字节输出流</p>
<p>存储内存数据到硬盘</p>
<p><strong>java.io.Reader</strong>		字符输入流</p>
<p><strong>java.io.Writer</strong>		字符输出流</p>
<h3 id="流的关闭"><a href="#流的关闭" class="headerlink" title="流的关闭"></a>流的关闭</h3><p>所有的<strong>流</strong>都实现了java.io.Closeable接口，都是可关闭的，都有<code>close()</code>方法</p>
<p>所有的<strong>输出流</strong>都实现了java.io.Flushable接口，都是可刷新的，都有<code>flush()</code>方法 </p>
<h5 id="文件专属流"><a href="#文件专属流" class="headerlink" title="文件专属流"></a>文件专属流</h5><ul>
<li>java.io.FileInputStream</li>
<li>java.io.FileOutputStream</li>
<li>java.io.FileReader</li>
<li>java.io.FileWriter</li>
</ul>
<pre><code class="java">//创建一个字节流对象
FileInputStream fileInputStream = new FileInputStream(&quot;D:\\pythonschool\\PY_lab\\File\\html.txt&quot;);

//调用读取数据的方法,一次读取一个字符
//fileInputStream.read() 这个方法的返回值是指定字符的ascii码，在文件中数据都读取完的情况下会返回-1
int read = fileInputStream.read();

//输出一次读取的字符的Ascii码
System.out.println(read);

//读取数据
int read = fileInputStream.read();

//通过循环的方式来读取数据
do &#123;

    System.out.println(read);

    read = fileInputStream.read();
&#125;while (read !=-1);
</code></pre>
<p><code>fileInputStream.read()</code> 如果传了字符数组，那么返回的是读取的字符个数</p>
<pre><code class="java">//通过字节数组的方式可以一次性读取多个字节
//1、创建一个字节数组
byte[] bytes = new byte[10];

int read = fileInputStream.read(bytes);

//read是读取字符的个数
System.out.println(read);
</code></pre>
<p><strong>FileInputStream这个字节流如何将ascII转成对应的字符</strong></p>
<p>可以根据String这个类来完成</p>
<pre><code class="java">//创建一个String类
//参数：读取数组，读取起始位置，读取字符数量
//默认从0开始读，读取长度为bytes.length
String s = new String(bytes);

System.out.println(s);
</code></pre>
<p><strong>注</strong>：第二次读取会对之前数组中已经存储的数据进行覆盖</p>
<h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><pre><code class="java">package com.os467.io;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class IoTest03 &#123;

    public static void main(String[] args) &#123;

        //创建输入流对象
        FileInputStream fileInputStream = null;

        try &#123;

            fileInputStream = new FileInputStream(&quot;D:\\pythonschool\\PY_lab\\File\\html.txt&quot;);

            //创建字节数组 1kb=1024b
            byte[] bytes = new byte[1024];

            int read = 0;

            //遍历字节数组,读取数据
            while ((read = fileInputStream.read(bytes)) != -1)&#123;

                //根据字符串将读取到的字节转换成字符串,读取到多少个就转换多少个
                System.out.print(new String(bytes,0,read));

            &#125;


        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;

            try &#123;
                //关闭流对象
                fileInputStream.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;

    &#125;




&#125;
</code></pre>
<p><strong>方法2</strong>：只适合小文件</p>
<pre><code class="java">fileInputStream = new FileInputStream(&quot;D:\\pythonschool\\PY_lab\\File\\html.txt&quot;);

//获取指定文件的字节总个数
int available = fileInputStream.available();

byte[] bytes = new byte[available];

int read = fileInputStream.read(bytes);

System.out.println(new String(bytes,0,read));
</code></pre>
<h4 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h4><pre><code class="java">//创建字节输出流
fileOutputStream = new FileOutputStream(&quot;C:\\Users\\tly20\\Desktop\\test.txt&quot;);

//写入数据到硬盘上
fileOutputStream.write(97);

//创建一个字节数组
byte[] bytes = &#123;98,99,100,101&#125;;

fileOutputStream.write(bytes);
</code></pre>
<p><strong>将字符串数据写入</strong></p>
<pre><code class="java">//创建一个字符串
String str = &quot;你好，Tom&quot;;

//将字符串转成对应的字节数组
byte[] bytes1 = str.getBytes();

//写入数据
fileOutputStream.write(bytes1);

//刷新
fileOutputStream.flush();
</code></pre>
<p><strong>开启写入追加(默认是false，覆盖写入)</strong></p>
<pre><code class="java">fileOutputStream = new FileOutputStream(&quot;C:\\Users\\tly20\\Desktop\\test.txt&quot;,true);
</code></pre>
<p><strong>字符输入输出流</strong></p>
<pre><code class="java">package com.os467.io;

import java.io.*;

/**
 * 通过字符输入流和字符输出流来完成一个普通文本文件的拷贝
 */
public class IoTest06 &#123;
    public static void main(String[] args)&#123;

        //文件字符输入流
        FileReader fileReader = null;

        //文件字符输出流
        FileWriter fileWriter = null;


        //创建文件字符输入流
        try &#123;

            //创建文件字符输入流
            fileReader = new FileReader(&quot;C:\\Users\\tly20\\Desktop\\test.txt&quot;);

            fileWriter = new FileWriter(&quot;C:\\Users\\tly20\\Desktop\\test_copy.txt&quot;,true);

            //创建字符数组 一次读取1024字符
            char[] chars = new char[100];

            //读数据
            int readCount = 0;

            //一边读，一边写
            while ((readCount = fileReader.read(chars) )!= -1)&#123;

                //数据的转换
                String str = new String(chars,0,readCount);

                //数据的写入,可以直接写入字符串
                fileWriter.write(str);

            &#125;

            //刷新输出流
            fileWriter.flush();

        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;

            //关闭资源
            if (fileReader != null)&#123;

                try &#123;
                    fileReader.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;

            if (fileWriter != null)&#123;

                try &#123;
                    fileWriter.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;

        &#125;


    &#125;




&#125;
</code></pre>
<p><strong>注意点</strong>：</p>
<ul>
<li>字节流要创建<strong>字节数组</strong>bytes[]接收读取的数据，字符流要创建<strong>字符数组</strong>chars[]接收读取的数据</li>
<li>输入流和输出流在最后都需要通过<code>close()</code>方法<strong>关闭资源</strong></li>
<li>输出流需要通过<code>flush()</code>方法进行<strong>刷新</strong></li>
</ul>
<h5 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h5><ul>
<li>java.io.BufferedReader</li>
<li>java.io.BufferedWriter</li>
<li>java.io.BufferedInputStream</li>
<li>java.io.BufferedOutputStream</li>
</ul>
<p>缓冲流会将字节先写到一个缓冲区中，然后通过<code>flush()</code>或者关闭这个缓冲流来实现将缓冲流中的数据回显</p>
<p><strong>特点</strong>：不需要创建数组</p>
<pre><code class="java">package com.os467.io;

import java.io.*;

/**
 * 缓冲流:
 *      自带缓冲区的流，在一次读取多个字符的时候，可以不用创建数组
 */
public class IoTest08 &#123;
    public static void main(String[] args) throws Exception&#123;

        String readLine = null;

        //创建缓冲流对象
        BufferedReader bufferedReader = new BufferedReader(new FileReader(&quot;C:\\Users\\tly20\\Desktop\\test.txt&quot;));

        //调用读取数据的方法
        //读取一行数据

        while ((readLine = bufferedReader.readLine()) != null)&#123;

            System.out.println(readLine);

        &#125;


        bufferedReader.close();
    &#125;

&#125;
</code></pre>
<h5 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h5><p>可以将字符流转换成字节流，也可以将字节流转换成字符流  InputStreamReader</p>
<p>包装流和节点流： new 流(new 流()) 外层是包装流，里面的是节点流</p>
<p>在关闭流对象的时候，只需要关闭<strong>最外层</strong>的包装流即可</p>
<pre><code class="java">//创建转换流 将字节流转换成字符流
        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;C:\\Users\\tly20\\Desktop\\test.txt&quot;));

//关闭流的时候只需要关闭最外层的包装流即可
inputStreamReader.close();
</code></pre>
<h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><ul>
<li>java.io.DataInputStream</li>
<li>java.io.DataOutputStream</li>
</ul>
<p>数据流在写入数据到文件中的时候，要根据数据类型来写入，而且写入之后的文件是加密的，是我们看不懂的文件，如果想读取这些数据的话，只能通过数据输入流来读取</p>
<p>数据输入流在读取数据的时候，是要按照写入的顺序来读取，而且需要按照指定的数据类型来读取</p>
<p><strong>存入数据流数据</strong></p>
<pre><code class="java">public static void main(String[] args) throws  Exception &#123;

    //创建一个数据输出流
    DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(&quot;C:\\Users\\tly20\\Desktop\\test_copy.txt&quot;));

    //指定数据
    boolean b = false;
    float f = 10f;
    int i = 20;
    double d = 3.14;
    
    //调用写入的方法
    dataOutputStream.writeBoolean(b);
    dataOutputStream.writeFloat(f);
    dataOutputStream.writeInt(i);
    dataOutputStream.writeDouble(d);
    
    //刷新输出流
    dataOutputStream.flush();
    
    //关闭流
    dataOutputStream.close();
    
&#125;
</code></pre>
<p><strong>按照存储的顺序读取加密数据</strong></p>
<pre><code class="java">public static void main(String[] args) throws  Exception &#123;

    //创建一个数据输出流
    DataInputStream dataInputStream = new DataInputStream(new FileInputStream(&quot;C:\\Users\\tly20\\Desktop\\test_copy.txt&quot;));

    //读取数据要根据写入的顺序来读取
    boolean b = dataInputStream.readBoolean();

    float v = dataInputStream.readFloat();

    int i = dataInputStream.readInt();

    double v1 = dataInputStream.readDouble();

    System.out.println(b);
    System.out.println(v);
    System.out.println(i);
    System.out.println(v1);
    
    dataInputStream.close();


&#125;
</code></pre>
<h5 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h5><ul>
<li>java.io.PrintWriter</li>
<li>java.io.PrintStream</li>
</ul>
<p>默认情况是我们经常使用的控制台打印，我们可以去改变输出流的输出方向</p>
<p>标准输出流的默认输出方向就是控制台</p>
<p><strong>标准输出流以后适用的场景</strong>：</p>
<p>可以去收集日志</p>
<p>比如说程序在某个时间点发生了某某异常，然后可以根据这个流来收集异常信息</p>
<p>或者去收集模块域模块之间的调用次数</p>
<pre><code class="java">//创建输出流对象，使用相对路径
PrintStream printStream = new PrintStream(new FileOutputStream(&quot;data.txt&quot;));

//打印hello world在data.txt文件中
printStream.print(&quot;hello world&quot;);
</code></pre>
<pre><code class="java">//创建输出流对象，不设置路径会默认打印在控制台
PrintStream printStream = System.out;

printStream.print(&quot;Hello world&quot;);
</code></pre>
<pre><code class="java">//设置输出的方向
PrintStream printStream = new PrintStream(new FileOutputStream(&quot;data.txt&quot;));

System.setOut(printStream);

//打印在data.txt中
System.out.println(&quot;hello world&quot;);

//刷新输出流
printStream.flush();

//关闭资源
printStream.close();
</code></pre>
<h5 id="异常日志收集工具类"><a href="#异常日志收集工具类" class="headerlink" title="异常日志收集工具类"></a>异常日志收集工具类</h5><pre><code class="java">package com.os467.utils;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.PrintStream;
import java.text.Format;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 日志收集工具类
 */
public class LoggerUtils &#123;

    private LoggerUtils()&#123;

    &#125;

    /**
     * 收集日志的方法
     * @param message
     */
    public static void logger(String message)&#123;

        PrintStream printStream = null;

        try &#123;

            //创建标准输出流对象
            printStream = new PrintStream(new FileOutputStream(&quot;logger&quot;,true));

            //设置输出路径
            System.setOut(printStream);

            //创建日期对象
            Date date = new Date();

            //创建日期格式化对象
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);

            //将日期转成字符串
            String time = simpleDateFormat.format(date);

            //记录日志
            System.out.println(time +&quot; : &quot;+message );

            //刷新输出流对象
            printStream.flush();

        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;

            if (printStream != null)&#123;

                printStream.close();

            &#125;

        &#125;


    &#125;

&#125;
</code></pre>
<h3 id="对象专属流"><a href="#对象专属流" class="headerlink" title="对象专属流"></a>对象专属流</h3><p>java.io.ObjectInputStream</p>
<p>java.io.ObjectOutput</p>
<p><strong>可序列化接口</strong>：</p>
<p>写入的对象必须实现序列化的<strong>接口</strong><code>Serializable</code></p>
<ul>
<li>对象专属流可以完成在一个内存和硬盘上对java对象进行<strong>序列化</strong>与<strong>反序列化</strong></li>
</ul>
<h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p><strong>序列化</strong>：</p>
<p>​		序列化就是将java对象写入到硬盘上，写入之后的文件也是加密的格式</p>
<p><strong>反序列化</strong>：</p>
<p>​		将文件中我们看不懂的加密数据读取出来，读取的就是java对象</p>
<ul>
<li><p>以后我们搭建的分布式项目，模块与模块间如果想完成数据的传输，需要通过<strong>序列化与反序列化</strong>来完成</p>
</li>
<li><p>序列化java对象的时候，该对象需要去实现一个序列化的接口</p>
</li>
<li><p><code>Serializable</code>序列化接口，这个接口没有任何的方法，只是一个标识性接口</p>
<p>因为我们在执行加载某一个类的时候会生成该类对应的字节码文件，这个时候jvm虚拟机会检查该类是否有<code>Serializable</code>这个接口</p>
<p>如果有，则赋予该类序列化的权限，如果没有则不能进行序列化</p>
</li>
</ul>
<p><strong>对User类的对象进行序列化操作</strong></p>
<pre><code class="java">public static void main(String[] args) throws  Exception &#123;

    //创建输出流对象(序列化对象)
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;users.txt&quot;));

    //创建user对象
    User user = new User();

    //将java对象写到文件中
    objectOutputStream.writeObject(user);

    //刷新输出流
    objectOutputStream.flush();

    //关闭流
    objectOutputStream.close();

&#125;
</code></pre>
<p><strong>对文件中存储的user数据进行反序列化操作</strong></p>
<pre><code class="java">public static void main(String[] args) throws  Exception &#123;

    //创建输入流对象
    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;users.txt&quot;));

    //读取数据
    Object object = objectInputStream.readObject();

    //判断数据类型
    if (object instanceof User)&#123;

        User user = (User)object;

        System.out.println(user);

    &#125;

    //关闭流
    objectInputStream.close();


&#125;
</code></pre>
<p><strong>对多个对象进行序列化与反序列化（通过ArrayList来完成）</strong></p>
<pre><code class="java">序列化多个对象
-----------------------------------------------------------------------------------------
//创建输出流对象(序列化对象)
ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;users.txt&quot;));

//创建user对象
User user1 = new User(1,&quot;张三1&quot;,&quot;男&quot;);
User user2 = new User(2,&quot;张三2&quot;,&quot;男&quot;);
User user3 = new User(3,&quot;张三3&quot;,&quot;男&quot;);
User user4 = new User(4,&quot;张三4&quot;,&quot;男&quot;);

//创建集合对象
ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;();

users.add(user1);
users.add(user2);
users.add(user3);
users.add(user4);

//将java对象写到文件中
objectOutputStream.writeObject(users);

//刷新输出流
objectOutputStream.flush();

//关闭流
objectOutputStream.close();
------------------------------------------------------------------------------------------
反序列化多个对象
------------------------------------------------------------------------------------------
//创建输入流对象
ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;users.txt&quot;));

//用一个数组来接收
ArrayList&lt;User&gt; arrayList = (ArrayList&lt;User&gt;)objectInputStream.readObject();

for (User user : arrayList) &#123;

    System.out.println(user);

&#125;

//关闭流
objectInputStream.close();
</code></pre>
<p><strong>关于序列化版本号的问题</strong>：</p>
<p>如果在反序列化之前修改了类中的代码，在类加载的时候会<strong>重新生成字节码文件</strong>，那么jvm给该类生成的<strong>序列化版本号</strong>就会<strong>改变</strong>，在反序列化时，旧的序列化版本号与新生成的版本号不对应，就无法完成反序列化</p>
<p><strong>解决方案</strong>：</p>
<p>我们可以在类中写死一个序列化版本号</p>
<pre><code class="java">private static final long serialVersionUID = 8683452581122892189L;
</code></pre>
<h4 id="关键字transient"><a href="#关键字transient" class="headerlink" title="关键字transient"></a>关键字transient</h4><p><code>transient</code>可以使得某一属性不参与序列化的操作，在反序列化后会得到null值</p>
<p><strong>JAVA	I&#x2F;O读取文件</strong></p>
<p><strong>读取文本文件</strong></p>
<p><code>new BufferedReader(new InputStreamReader(new FileInputStream(&quot;a.txt&quot;),&quot;UTF-8&quot;))</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/10/IO流/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/07/javaScript/">
        <h2>
            javaScript
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/7
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p><strong>什么是JavaScript？</strong></p>
<ul>
<li><p>JavaScript语言诞生主要是完成页面的数据验证</p>
<p>因此它运行在客户端，需要运行浏览器来解析执行JavaScript代码 ，简称JS</p>
</li>
<li><p>JS是Netscape网景公司的产品，最早取名为LiveScript 为了吸引更多java开发人员，更名为JavaScript，JS是弱类型，Java是强类型</p>
</li>
</ul>
<p><strong>JavaScript和html代码的结合</strong></p>
<ul>
<li>使用script标签来书写JavaScript代码</li>
<li>使用script标签引入单独的JavaScript代码文件</li>
</ul>
<p><strong>JavaScript是运行在客户端的一门编程语言，简称js</strong></p>
<h2 id="js的代码该如何去编写"><a href="#js的代码该如何去编写" class="headerlink" title="js的代码该如何去编写"></a>js的代码该如何去编写</h2><p>​		我们需要结合html来编写js代码：</p>
<p>​		a、在html文件中定义一个<code>&lt;script&gt;&lt;/script&gt;</code>标签，在该标签的内部去写js代码</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;JavaScript&lt;/title&gt;
&lt;/head&gt;

&lt;!--定义一个script去写js代码--&gt;
&lt;script&gt;

    //js中封装的有对应的函数
    alert(&quot;网页弹窗&quot;);

&lt;/script&gt;
&lt;body&gt;



&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>​		b、会声明一个js文件，在js文件中去写js代码，然后通过<code>&lt;script&gt;</code>标签去引入js文件</p>
<pre><code class="html">&lt;!--引入js文件--&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/test.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="JavaScript变量"><a href="#JavaScript变量" class="headerlink" title="JavaScript变量"></a>JavaScript变量</h2><ul>
<li>数值类型：number</li>
<li>字符串类型：string</li>
<li>对象类型：object</li>
<li>布尔类型：boolean</li>
<li>函数类型：function</li>
</ul>
<p><strong>在js中如何去声明一个变量</strong></p>
<p>​	<code>var、let</code>这两个关键字可以去接收一个变量</p>
<p>而且任何变量都可以用这两个关键字接收</p>
<p>var i &#x3D; 100</p>
<p>let str &#x3D; “123456”</p>
<p>关于js中的逻辑运行算（与 &amp;&amp;	或 ||	非 ! ）：</p>
<p>在js中 null、undefined、0 、false参与逻辑运算时本身代表的是false，其余所有的数据都表示true</p>
<p><strong>与运算</strong></p>
<ul>
<li>如果参与&amp;&amp;与运算两者都为真的情况下，会取到后者的值</li>
<li>如果参与&amp;&amp;与运算有一者为假的情况下，会取到为假的那个值</li>
<li>如果参与&amp;&amp;与运算两者都为假的情况下，会取到前者的值</li>
</ul>
<p><strong>或运算</strong></p>
<ul>
<li>如果参与||或运算两者都为真的情况下，会取到前者的值</li>
<li>如果参与||或运算有一者为假的情况下，会取到为真的那个值</li>
<li>如果参与||或运算两者都为假的情况下，会取到后者的值</li>
</ul>
<p><em>都有惰性取值的特点，最后计算完的值返回</em></p>
<p>取非！运算，首先要搞清楚，数据本身是为真还是为假，取非之后，真就是假，假就是真</p>
<h3 id="数组的定义方式"><a href="#数组的定义方式" class="headerlink" title="数组的定义方式"></a>数组的定义方式</h3><p>JS中数组的定义：</p>
<p><strong>格式：</strong></p>
<p><code>var 数组名 = [];</code>&#x2F;&#x2F;空数组</p>
<p><code>var 数组名 = [1,&#39;abc&#39;,true];</code>&#x2F;&#x2F;定义数组同时赋值元素</p>
<p>js数组可以在一个数组中存放任意类型的值</p>
<p>js数组可以给任意一个下标赋值，未赋值的默认为<strong>undefined</strong></p>
<p><strong>遍历数组</strong></p>
<pre><code class="javascript">for (let i = 0;i &lt; array.length; i++)&#123;

    alert(array[i]);

&#125;
</code></pre>
<h3 id="JS对象"><a href="#JS对象" class="headerlink" title="JS对象"></a>JS对象</h3><p>在js中也能new对象，但是必须使用js封装好的对象</p>
<p>通过<code>对象.属性 = 值</code>的方法赋值，属性和值都可以自定义</p>
<pre><code class="javascript">let object = new Object();

object.name = &quot;tom&quot;;
object.age = 15;
object.address = &quot;北京市&quot;;
object.key = &quot;value&quot;;

alert(object.name);
alert(object.age);
alert(object.address);

//正则对象
let regExp = new RegExp();
</code></pre>
<h2 id="函数的两种定义方式"><a href="#函数的两种定义方式" class="headerlink" title="函数的两种定义方式"></a>函数的两种定义方式</h2><ul>
<li><p>function 函数名(形参列表){函数体}</p>
<pre><code class="javascript">function function01(num1,num2)&#123;
    
    let num = num1 + num2;
    
    return num;
    
&#125;
</code></pre>
</li>
<li><p>let  函数名 &#x3D; function(形参列表){函数体}</p>
</li>
</ul>
<pre><code class="javascript">let function02 = function(num1,num2)&#123;
    
    let num = num1 + num2;
    
    return num;
    
&#125;
</code></pre>
<p><strong>注：</strong>js中的函数，在定义参数的时候可以不用写数据类型，参数与参数之间用逗号分割</p>
<p><strong>注：</strong>js中的函数没有返回值类型，在函数体中写完代码之后，有返回值就返回，没有返回值就不用返回</p>
<p><strong>注：</strong>js中的函数是不支持重载的，如果你同时定义了两个同名的函数，下面那个会覆盖上面那个</p>
<p>在JavaScript语言中，定义带有返回值的函数<strong>只需要在函数体内直接使用return语句返回值即可</strong></p>
<p><strong>JS隐式参数</strong></p>
<pre><code class="javascript">//arguments js 中的隐式参数，是一个数组类型，可以去接收所有数据
function function02()&#123;

    alert(arguments[0]);
    alert(arguments[1]);
    alert(arguments[2]);

&#125;

alert(function02(100,true,&quot;hello&quot;));
</code></pre>
<p><strong>简单的数字相加函数</strong></p>
<pre><code class="javascript">let function02 = function(num1,num2) &#123;

       let num = null;

       if ((typeof num1) == &quot;number&quot; &amp;&amp; (typeof num2) == &quot;number&quot;) &#123;

           let num = num1 + num2;

       &#125; else &#123;

           return &quot;你传的数据不合法&quot;;

       &#125;

       return num;
   &#125;
</code></pre>
<h2 id="JS中的事件"><a href="#JS中的事件" class="headerlink" title="JS中的事件"></a>JS中的事件</h2><ul>
<li><strong>onload</strong> 加载完成事件：页面加载完成之后，常用于做页面js代码初始化操作</li>
<li><strong>onclick</strong> 单机事件：常用于按钮的点击响应操作</li>
<li><strong>onblur</strong> 失去焦点事件：常用于输入框失去焦点后验证其输入内容是否合法</li>
<li><strong>onchange</strong> 内容发生改变事件：常用于下拉列表和输入框内容发生改变后操作</li>
<li><strong>onsubmit</strong> 表单提交事件：常用于表单提交前，验证所有表单项是否合法</li>
</ul>
<p><strong>关于js中的事件（分为静态注册和动态注册）：</strong></p>
<p>​	<strong>静态注册</strong>：通过html标签内部的事件属性来完成事件的注册</p>
<pre><code class="javascript">&lt;body onload=&quot;alert(&#39;静态注册页面加载完成事件&#39;)&quot;&gt; &lt;/body&gt;
</code></pre>
<pre><code class="javascript">&lt;!--鼠标单机事件：静态注册--&gt;
&lt;input type=&quot;button&quot; value=&quot;测试鼠标单机事件&quot; onclick=&quot;alert(&#39;鼠标单机事件静态注册&#39;)&quot;&gt;
</code></pre>
<p>​	</p>
<p>​	<strong>动态注册</strong>：先通过dom对象获取到某一个具体的html元素，然后对这个标签进行绑定，注册事件</p>
<p><code>document.getElementById()</code>通过id这个属性查找html元素</p>
<p><strong>注</strong>：动态注册一定要写在<code>script</code>标签中，或者js文件中</p>
<pre><code class="javascript">//页面加载完成事件动态注册
//window是html内置对象
  window.onload = function ()&#123;
      
    //在该函数中完成页面初始化的操作
      
      alert(&quot;动态绑定页面加载完成事件&quot;)

  &#125;
</code></pre>
<p>动态注册单击事件</p>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;JavaScript&lt;/title&gt;
&lt;/head&gt;

&lt;!--定义一个script去写js代码--&gt;
&lt;script type=&quot;text/javascript&quot;&gt;


  //页面加载完成事件动态注册
  //window是html内置对象
    window.onload = function ()&#123;

        alert(&quot;动态绑定页面加载完成事件&quot;)

        //通过动态注册的方式来注册单击事件
        let elementInput = document.getElementById(&quot;onclickTest&quot;);

        //[object HTMLInputElement] dom对象
        alert(elementInput)

        //动态注册单击事件
        elementInput.onclick=function ()&#123;

            alert(&quot;触发了单击事件，动态注册的方式&quot;)

        &#125;
    &#125;


    

&lt;/script&gt;

&lt;!--引入js文件--&gt;
&lt;!--&lt;script type=&quot;text/javascript&quot; src=&quot;../js/test.js&quot;&gt;&lt;/script&gt;--&gt;
&lt;body&gt;

    &lt;!--鼠标单机事件：静态注册--&gt;
    &lt;input type=&quot;button&quot; value=&quot;测试鼠标单机事件(静态)&quot; onclick=&quot;alert(&#39;鼠标单机事件静态注册&#39;)&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;button&quot; value=&quot;测试鼠标单机事件(动态)&quot; id=&quot;onclickTest&quot;&gt;&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>加载完成事件（<strong>onload</strong>）：</p>
<p>​		浏览器在解析html页面的时候是一个标签一个标签的往下解析</p>
<p>​		在浏览器解析完所有的html元素之后会触发的操作</p>
<p>失去焦点事件（<strong>onblur</strong>）</p>
<pre><code class="html">测试鼠标失去焦点事件(静态):&lt;input type=&quot;text&quot; id=&quot;onblur&quot; onblur=&quot;alert(&#39;触发了失去焦点事件&#39;)&quot;&gt;&lt;br&gt;
</code></pre>
<pre><code class="javascript">//动态绑定失去焦点事件
let elementOnblur = document.getElementById(&quot;onblurTest&quot;);

//绑定事件
elementOnblur.onblur = function ()&#123;

    alert(&quot;触发了失去焦点事件，动态注册的方式&quot;);

&#125;
</code></pre>
<p>内容发送改变事件（<strong>onchange</strong>）</p>
<pre><code class="html">测试内容发生改变事件(静态):&lt;input type=&quot;text&quot; value=&quot;123&quot; onchange=&quot;alert(&#39;内容已发生改变&#39;)&quot;&gt;&lt;br&gt;
</code></pre>
<pre><code class="javascript">//内容发生改变事件
let elementSelect = document.getElementById(&quot;onchangeTest&quot;);

//绑定事件
elementSelect.onchange = function ()&#123;

    alert(&quot;内容已发生改变,动态注册的方式&quot;);

&#125;
</code></pre>
<h4 id="关于html的上下文文本对象document"><a href="#关于html的上下文文本对象document" class="headerlink" title="关于html的上下文文本对象document"></a>关于html的上下文文本对象document</h4><p>这个是html内置的对象，通过这个对象可以去获取html对象（标签）</p>
<p>而且获取的方式有很多种（比如：根据id属性获取，根据name属性获取，根据具体的标签名称获取）</p>
<p><strong>DOM模型和document对象</strong></p>
<p><strong>DOM</strong>全称是Document Object Model 文档对象模型</p>
<p><strong>document</strong>对象</p>
<p>1.Document它管理了所有的HTML文档内容</p>
<p>2.document它是一种树结构的文档，有层级关系</p>
<p>3.它让我们把所有的标签都对象化</p>
<p>4.我们可以通过document访问所有的标签对象</p>
<p><strong>Document对象中的方法</strong></p>
<ul>
<li><code>document.getElementById(elementId)</code>通过标签的id属性查找标签dom对象，elementId是标签的id属性值</li>
<li><code>document.getElementsByName(elementName)</code>通过标签的name属性查找标签dom对象，elementName标签的name属性值</li>
<li><code>document.getElementsByTagName(tagname)</code>通过标签名找标签dom对象，tagname是标签名</li>
<li><code>document.createElement(tagName)</code>方法，通过给定的标签名，创建一个标签对象，tagName是要创建的标签名</li>
</ul>
<pre><code class="javascript">//获取所有name属性值为username的标签
let inputEls = document.getElementsByName(&quot;username&quot;);

//[object NodeList]
alert(inputEls);

for (let i = 0; i &lt; inputEls.length; i++) &#123;

    alert(inputEls[i]);

&#125;
</code></pre>
<h5 id="标签的常用属性"><a href="#标签的常用属性" class="headerlink" title="标签的常用属性"></a>标签的常用属性</h5><ul>
<li>childNodes属性，获取当前节点的所有子节点</li>
<li>firstChild属性，获取当前节点的第一个子节点</li>
<li>lastChild属性，获取当前节点的最后一个子节点</li>
<li>parentNode属性，获取当前节点的父节点</li>
<li>nextSibling，获取当前节点的下一个节点</li>
<li>previousSibling属性，获取当前节点的上一个节点</li>
<li>className用于获取或设置标签的class属性值</li>
<li>innerHTML属性，表示获取&#x2F;设置起始标签和结束标签中的内容</li>
<li>innerText属性，表示获取&#x2F;设置起始标签和结束标签中的文本</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/07/javaScript/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/06/XML/">
        <h2>
            XML
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/6
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p><strong>什么是xml?</strong></p>
<p>xml是可扩展的标记性语言</p>
<p><strong>xml的作用</strong></p>
<p>xml的主要作用有：</p>
<p>1.用来保存数据，而且这些数据具有自我描述性</p>
<p>2.它还可以作为项目或者模块的配置文件</p>
<p>3.还可以作为网络传输数据的格式</p>
<h2 id="xml语法"><a href="#xml语法" class="headerlink" title="xml语法"></a>xml语法</h2><h3 id="xml命名规则"><a href="#xml命名规则" class="headerlink" title="xml命名规则"></a>xml命名规则</h3><ul>
<li>名称可以含字母、数字以及其他的字符</li>
<li>名称不能以数字或者标点符号开始</li>
<li>名称不能包含空格</li>
</ul>
<p><strong>1.文档声明</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</code></pre>
<p><strong>2.元素（标签）</strong></p>
<p>元素是指开始标签到结束标签的内容</p>
<pre><code class="xml">&lt;!--根标签--&gt;
&lt;students&gt;

    &lt;!--子标签--&gt;
    &lt;student id=&quot;1001&quot;&gt;
        &lt;name&gt;张三&lt;/name&gt;
        &lt;age&gt;25&lt;/age&gt;
        &lt;address&gt;镇江市&lt;/address&gt;
    &lt;/student&gt;

    &lt;!--子标签--&gt;
    &lt;student id=&quot;1002&quot;&gt;
        &lt;name&gt;李四&lt;/name&gt;
        &lt;age&gt;29&lt;/age&gt;
        &lt;address&gt;南京市&lt;/address&gt;
    &lt;/student&gt;

    &lt;!--子标签--&gt;
    &lt;student id=&quot;1003&quot;&gt;
        &lt;name&gt;王五&lt;/name&gt;
        &lt;age&gt;19&lt;/age&gt;
        &lt;address&gt;上海市&lt;/address&gt;
    &lt;/student&gt;

&lt;/students&gt;
</code></pre>
<p><strong>3.xml属性</strong></p>
<p><strong>id属性为1003</strong></p>
<pre><code class="xml">&lt;student id=&quot;1003&quot;&gt;
</code></pre>
<p><strong>4.xml注释</strong></p>
<p> ctrl + shift + &#x2F;</p>
<pre><code class="xml">&lt;!--此处写注释--&gt;
</code></pre>
<h2 id="xml解析技术"><a href="#xml解析技术" class="headerlink" title="xml解析技术"></a>xml解析技术</h2><p>​	xml可扩展的标记语言，不管是html文件还是xml文件它们都是标记型文档，都可以使用w3c组织制定的dom技术来解析</p>
<p>​	document对象表示的是整个文档（可以是html文档，也可以是xml文档）</p>
<p>​		w3c是一个制定规范的组织，针对于xml，html都制定了相关的规范，元素都是以标签的形式体现的，每个标签都是一个对象，而且每个标签都是有层级关系的，w3c通过一种树形图来管理这种关系，而且提供了一个文本对象dom对象，通过这个dom对象可以去获取所有的标签对象</p>
<p><strong>dom解析技术</strong></p>
<ul>
<li><p>dom解析技术是W3C组织制定的，而所有的编程语言都对这个解析技术使用了自己语言的特点进行实现，Java对<strong>dom技术解析</strong>标记也做了实现</p>
</li>
<li><p>sun公司在JDK5版本对dom解析技术进行升级：<strong>SAX</strong>（Simple API for XML） SAX解析，它跟W3C制定的解析不太一样，它是以类似事件机制通过回调告诉用户当前正在解析的内容，它是一行一行的读取xml文件进行解析的，不会创建大量的dom对象，所以它在解析xml的时候，在<strong>内存</strong>的使用上，和<strong>性能</strong>上，都优于Dom解析。</p>
</li>
<li><p>jdom在dom基础上进行了封装</p>
</li>
<li><p>dom4j又对jdom进行了封装</p>
</li>
<li><p>pull主要用在Android手机开发，实在跟sax非常类似都是事件机制解析xml文件</p>
</li>
</ul>
<h2 id="Dom4j"><a href="#Dom4j" class="headerlink" title="Dom4j"></a>Dom4j</h2><ul>
<li>Dom4j是第三方的解析技术，我们需要使用第三方给我们提供好的类库才可以解析xml文件</li>
<li></li>
<li>由于dom4j它不是sun公司的技术，而属于第三方公司的技术，需要使用dom4j就需要到dom4j官网下载dom4j的jar包</li>
</ul>
<h3 id="dom4j编程步骤"><a href="#dom4j编程步骤" class="headerlink" title="dom4j编程步骤"></a>dom4j编程步骤</h3><p>1.先加载xml文件创建Document对象</p>
<p>2.通过Document对象拿到根元素对象 <code>getRootElement()</code></p>
<p>3.通过<code>根元素.elements(标签名)</code>；可以返回一个集合，这个集合里放着。所有你指定的标签名的元素对象</p>
<p>4.找到你想要修改、删除的子元素，进行相应的操作</p>
<p>5.保存到硬盘上</p>
<p>将xml文件内容解析封装为java对象</p>
<pre><code class="java">package com.os467.xml;

import com.os467.beans.Student;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.util.ArrayList;
import java.util.List;

public class Dom4jTest &#123;

    public static void main(String[] args) &#123;

        try &#123;
            //创建流对象
            SAXReader saxReader = new SAXReader();

            //通过流对象读取xml文件，然后返回document对象
            Document document = saxReader.read(&quot;src/xml/test.xml&quot;);

            //通过document获取到根标签
            Element rootElement = document.getRootElement();

            //获取根标签中所有的子标签对象
            List&lt;Element&gt; elements = rootElement.elements(&quot;student&quot;);

            //创建集合对象
            List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();

            //遍历集合
            for (Element element : elements) &#123;

                //获取子标签中的数据
                String name = element.elementText(&quot;name&quot;);
                String age = element.elementText(&quot;age&quot;);
                String address = element.elementText(&quot;address&quot;);
                

                //将这些数据封装成java对象
                Student student = new Student(name, Integer.parseInt(age), address);

                //将这些对象添加到集合中
                studentList.add(student);


            &#125;

            for (Student student : studentList) &#123;

                System.out.println(student);

            &#125;

        &#125; catch (DocumentException e) &#123;
            e.printStackTrace();
        &#125;


    &#125;

&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/06/XML/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/06/cookie和session/">
        <h2>
            Cookie和session
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/6
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie 是服务器通知客户端保存键值对的一种技术</p>
<p>客户端</p>
<p>有了Cookie后，每次请求都发送给服务器</p>
<p>每个Cookie的大小不能超过4kb</p>
<p>1.什么是cookie？</p>
<p>​	cookie是客户端保存数据的一种技术，而且保存的方式是键值对形式</p>
<p>2.如何去创建cookie，在客户端保存数据</p>
<p>​	cookie这个对象是servlet的jar包给我们提供的，我们只需要去创建cookie，并且通知浏览器保存cookie就可了</p>
<p>创建cookie对象</p>
<p><code>Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);</code></p>
<p>通知浏览器保存cookie</p>
<p><code>response.addCookie(cookie);</code></p>
<p>3.cookie的生命周期</p>
<p>​	cookie默认的生命周期是一个session级别的，是浏览器的开启到关闭</p>
<p>服务器获取Cookie</p>
<p>​	获取cookie方法</p>
<p>​	<code>request.getCookies()</code></p>
<pre><code class="java">package com.os467.cookie;

import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class CookieDemo01 extends HttpServlet &#123;

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        addCookie(request,response);
        getCookies(request,response);

        getCookieFilter(request,response);
    &#125;

    /**
     * 向客户端添加cookie
     * @param request
     * @param response
     */
    public void addCookie(HttpServletRequest request,HttpServletResponse response)&#123;

        //创建cookie对象
        Cookie cookie1 = new Cookie(&quot;username&quot;,&quot;tom&quot;);
        Cookie cookie2 = new Cookie(&quot;password&quot;,&quot;123&quot;);
        Cookie cookie3 = new Cookie(&quot;address&quot;,&quot;beijing&quot;);
        Cookie cookie4 = new Cookie(&quot;idCard&quot;,&quot;123124325&quot;);


        //通知浏览器保存cookie
        response.addCookie(cookie1);
        response.addCookie(cookie2);
        response.addCookie(cookie3);
        response.addCookie(cookie4);

    &#125;


    /**
     * 获取单个cookie的方式，只能通过遍历cookie数组，然后进行过滤
     * @param request
     * @param response
     */
    public void getCookieFilter(HttpServletRequest request,HttpServletResponse response)&#123;

        //根据请求对象获取客户端的cookie
        Cookie[] cookies = request.getCookies();

        //遍历cookie数组
        for (Cookie cookie : cookies) &#123;

            if(cookie.getName().equals(&quot;username&quot;))&#123;

                //设置响应对象支持html文本
                response.setContentType(&quot;text/html;charset=utf-8&quot;);

                //cookie.getName()获取cookie的key
                //cookie.getValue()获取cookie的value
                try &#123;
                    response.getWriter().print(cookie.getName()+&quot; &quot;+cookie.getValue()+&quot;&lt;br&gt;&quot;);
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;

        &#125;

    &#125;


    /**
     * 获取浏览器端所有的cookie
     *
     * 获取cookie没有提供获取单个cookie的方法，只能获取所有然后再筛选出需要的cookie
     * @param request
     * @param response
     */
    public void getCookies(HttpServletRequest request,HttpServletResponse response)&#123;

        //根据请求对象获取客户端的cookie
        Cookie[] cookies = request.getCookies();

        //遍历cookie数组
        for (Cookie cookie : cookies) &#123;

            //设置响应对象支持html文本
            response.setContentType(&quot;text/html;charset=utf-8&quot;);

            //cookie.getName()获取cookie的key
            //cookie.getValue()获取cookie的value
            try &#123;
                response.getWriter().print(cookie.getName()+&quot; &quot;+cookie.getValue()+&quot;&lt;br&gt;&quot;);
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;

    &#125;

&#125;
</code></pre>
<h2 id="Cookie值的修改"><a href="#Cookie值的修改" class="headerlink" title="Cookie值的修改"></a>Cookie值的修改</h2><p>方案一</p>
<p>1.先创建一个要修改的同名Cookie对象</p>
<p>2.再构造器，同时赋予新的Cookie值</p>
<p>3.调用response.addCookie(Cookie)</p>
<p>方案二</p>
<p>1.先查找到需要修改的Cookie对象</p>
<p>2.调用setValue()方法赋予新的Cookie值</p>
<p>3.调用response.addCookie()通知客户端保存修改</p>
<pre><code class="java">/**
 * 修改对象的cookie值
 * @param request
 * @param response
 */
public void setCookie(HttpServletRequest request,HttpServletResponse response)&#123;

    //把username的值改成jack
    Cookie cookie1 = new Cookie(&quot;username&quot;, &quot;jack&quot;);

    //通知浏览器保存cookie
    response.addCookie(cookie1);

    //将密码改成654321

    //先获取浏览器所有的cookie
    Cookie[] cookies = request.getCookies();

    Cookie c = null;

    //遍历cookie
    for (Cookie cookie : cookies) &#123;

        if (cookie.getName().equals(&quot;password&quot;))&#123;

            cookie.setValue(&quot;654321&quot;);

            c = cookie;

        &#125;

    &#125;

    //通知浏览器保存cookie
    response.addCookie(c);

&#125;
</code></pre>
<h2 id="封装Cookie工具类"><a href="#封装Cookie工具类" class="headerlink" title="封装Cookie工具类"></a>封装Cookie工具类</h2><p>Cookie类无法获取浏览器端单个cookie，每次需要去遍历，因此我们选择把对cookie的操作封装成一个工具类</p>
<pre><code class="java">package com.os467.utils;

import javax.servlet.http.Cookie;

/**
 *根据cookie的key来找到某一个具体的cookie,因为api中我们只能获取所有cookie
 * 获取单个cookie的话只能通过标识去过滤，这样就很麻烦，所以我们可以封装一个工具类
 * 来提高开发速率
 */
public class FindCookieUtils &#123;

    //构造方法私有化
    private FindCookieUtils()&#123;

    &#125;

    /**
     * 根据key来获取cookie
     * @return
     */
    public static Cookie findCookie(Cookie[] cookies,String name)&#123;

        if (cookies == null || cookies.length == 0 || name == null)&#123;

            return null;

        &#125;

        //遍历cookie数组
        for (Cookie cookie : cookies) &#123;

            if (cookie.getName().equals(name))&#123;

                return cookie;

            &#125;

        &#125;

        return null;


    &#125;


&#125;
</code></pre>
<h2 id="Cookie的生命周期"><a href="#Cookie的生命周期" class="headerlink" title="Cookie的生命周期"></a>Cookie的生命周期</h2><p>cookie默认的生命周期是一个session级别的，是浏览器的开启到关闭</p>
<h3 id="Cookie生命控制"><a href="#Cookie生命控制" class="headerlink" title="Cookie生命控制"></a>Cookie生命控制</h3><p><code>setMaxAge()</code></p>
<p>正数，表示在指定的秒数后过期</p>
<p>负数，表示浏览器一关，Cookie就会被删除（默认值是-1）</p>
<p>零，表示马上删除Cookie</p>
<p><strong>设置cookie的生命周期</strong></p>
<pre><code class="java">/**
 * 设置cookie的生命周期
 * @param request
 * @param response
 */
public void setMaxAgeCookie(HttpServletRequest request,HttpServletResponse response)&#123;

    //1.将所有的cookie的生命周期设置为一年
    for (Cookie cookie : request.getCookies()) &#123;

        cookie.setMaxAge(60 * 60 * 24 * 365);

        //通知浏览器保存cookie
        response.addCookie(cookie);

    &#125;

    //将密码所对应的cookie的生命周期改为一周
    Cookie cookie = FindCookieUtils.findCookie(request.getCookies(), &quot;password&quot;);

    //修改生命周期
    cookie.setMaxAge(60 * 60 * 24 * 7);

    //通知浏览器保存
    response.addCookie(cookie);

&#125;
</code></pre>
<p><strong>删除一个具体的cookie</strong></p>
<pre><code class="java">/**
 * 删除一个具体的cookie
 * @param request
 * @param response
 */
public void deleteCookie(HttpServletRequest request,HttpServletResponse response) &#123;

    //删除idCard所对应的cookie
    Cookie cookie = FindCookieUtils.findCookie(request.getCookies(), &quot;idCard&quot;);

    cookie.setMaxAge(0);

    //通知浏览器保存cookie

    response.addCookie(cookie);

&#125;
</code></pre>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session是一个接口（HttpSession）</p>
<p>Session就是会话，它是用来维护一个客户端和服务器之间关联的一种技术</p>
<p>每个客户端都有自己的一个Session会话</p>
<p>Session会话中，我们经常用来保存用户登录之后的信息</p>
<p>session是在服务端保存数据的一种技术，而且session可以关联客户端和服务端</p>
<p>session跟cookie是有关系的</p>
<p>以后会用session来保存用户登录之后的用户信息，我们之前所完成的登录功能是不完整的</p>
<p>前端校验会话中是否有用户数据，如果有，才能登录成功</p>
<p><strong>如何去创建session对象？</strong></p>
<p>创建session对象，需要用到request对象</p>
<p><code>HttpSession session = request.getSession()</code></p>
<p>session也可以说是一个域对象，可以存取值，取值范围，是浏览器的开启到关闭</p>
<p><code>request.getSession()</code>第一次调用是：创建Session会话</p>
<p><code>isNew()</code>判断到底是不是刚创建出来的</p>
<p><code>getId()</code>得到Session的会话id值</p>
<p>session对象是一个<strong>单例</strong>的对象</p>
<h2 id="Session域数据的存取"><a href="#Session域数据的存取" class="headerlink" title="Session域数据的存取"></a>Session域数据的存取</h2><pre><code class="java">//存数据
request.getSession().setAttribute(&quot;key&quot;,&quot;value&quot;);

//取数据
request.getSession().getAttribute(&quot;key&quot;);
</code></pre>
<h2 id="Session生命周期"><a href="#Session生命周期" class="headerlink" title="Session生命周期"></a>Session生命周期</h2><h3 id="Session生命周期控制"><a href="#Session生命周期控制" class="headerlink" title="Session生命周期控制"></a>Session生命周期控制</h3><p><code>public void setMaxInactiveInterval(int interval)</code></p>
<p>设置Session的超时时间，超过指定的时长，Session就会被销毁</p>
<p>值为正数的时候，设定Session的超时时长，负数表示永不超时</p>
<p><code>getMaxInactiveInterval()</code>获取Session的超时时间</p>
<p><code>invalidate()</code>让当前Session会话马上超时无效</p>
<p>session默认超时时间是<strong>30分钟</strong></p>
<p><strong>设置生命周期与cookie区别：</strong></p>
<p>负数，cookie代表浏览器关闭则删除，session代表永不超时</p>
<p>删除cookie可以设置0，删除session不可以，需要用指定的方法</p>
<h4 id="设置session的超时时间"><a href="#设置session的超时时间" class="headerlink" title="设置session的超时时间"></a>设置session的超时时间</h4><p><strong>设置session的超时时间</strong></p>
<pre><code class="java">session.setMaxInactiveInterval(3600 * 24);
</code></pre>
<p><strong>通过配置文件设置默认超时时间</strong></p>
<p>xml中配置是按照<strong>分钟</strong>配置的</p>
<pre><code class="xml">&lt;!--配置默认的超时时间--&gt;
&lt;session-config&gt;
    &lt;session-timeout&gt;45&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre>
<p><strong>让当前的session立即超时无效</strong></p>
<p>这个方法在以后做注销的时候会用到</p>
<pre><code class="java">session.invalidate();
</code></pre>
<pre><code class="java">public class SessionDemo01 extends HttpServlet &#123;

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        response.setContentType(&quot;text/html;charset=utf-8&quot;);

        //创建session对象
        HttpSession session = request.getSession();
        HttpSession session2 = request.getSession();

        /*session.setMaxInactiveInterval(3600 * 24);*/


        response.getWriter().print(&quot;session是否是新创建的：&quot;+session.isNew()+&quot;&lt;br&gt;&quot;);

        response.getWriter().print(&quot;session的会话id值为：&quot;+session.getId()+&quot;&lt;br&gt;&quot;);

        response.getWriter().print(&quot;session对象是否是单例的：&quot;+ (session == session2)+&quot;&lt;br&gt;&quot;);

        //往session域中存数据
        session.setAttribute(&quot;key1&quot;,&quot;value1&quot;);
        session.setAttribute(&quot;key2&quot;,&quot;value2&quot;);

        //取出session中的数据
        response.getWriter().print(&quot;取出session中key1的数据&quot;+session.getAttribute(&quot;key1&quot;)+&quot;&lt;br&gt;&quot;);

        response.getWriter().print(&quot;取出session中key2的数据&quot;+session.getAttribute(&quot;key2&quot;)+&quot;&lt;br&gt;&quot;);

        //获取session超时时间
        response.getWriter().print(&quot;session默认超时时间&quot;+session.getMaxInactiveInterval()+&quot;&lt;br&gt;&quot;);

    &#125;
&#125;
</code></pre>
<h1 id="session和cookie的关系和区别"><a href="#session和cookie的关系和区别" class="headerlink" title="session和cookie的关系和区别"></a>session和cookie的关系和区别</h1><h2 id="session和cookie的关系"><a href="#session和cookie的关系" class="headerlink" title="session和cookie的关系"></a>session和cookie的关系</h2><p>cookie保存数据的原理就是通过http协议响应头的方式把数据传递过去</p>
<p>在浏览器访问服务端的时候，假设我们并没有手动的去创建session对象，但是我们在响应头会发现一个现象：会有一个<strong>set-cookie : JESSIONID &#x3D; 74045E2CC5F9FA30EE9CEBE1D092E1CD</strong></p>
<p>JSEEIONID &#x3D; session的会话id</p>
<p>所以说要想获得会话id，就必须得有session对象</p>
<p>总结：浏览器访问服务端的时候，会自动的去创建session会话id，自动生成会话id，然后在底层通过创建cookie对象的方式将会话id保存下来</p>
<p><code>Cookie cookie = new Cookie(&quot;JESSIONID&quot;,session的会话id)</code></p>
<h2 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h2><p><strong>cookie</strong></p>
<p>​		cookie是客户端保存数据的技术：只能去存放一些最基本的字符串，json串，不能存放java对象</p>
<p>​		cookie相对来说不安全，因为数据存在浏览器的内存里面，所以可以通过一些途径来获取到这些数据</p>
<p><strong>session</strong></p>
<p>​		session是服务端保存数据的技术，可以存放的数据类型有很多，String、List、Map、java对象</p>
<p>​		session相对来说是安全的，但是会占用服务器的资源，cookie是不会占用服务器资源的</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/06/cookie和session/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/02/servlet/">
        <h2>
            Servlet
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/2
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h2><p>JavaEE规范之一</p>
<p>是运行在服务端上的一个java小程序，它可以接收客户端发过来的数据请求，并且响应数据给客户端</p>
<p><strong>部署tomcat的时候记得部署工程</strong></p>
<p><strong>Servlet的生命周期</strong></p>
<p>1.浏览器根据地址来发起调用，tomcat容器在接收到请求之后会根据地址栏上的地址进行一个数据的解析</p>
<p>会找到具体的工程，然后再定位到工程下面具体的资源</p>
<p>2.定位到资源以后，首先会创建当前servlet类的实例，所以调用的是<strong>无参构造方法</strong></p>
<p>3.会执行初始化<strong>init</strong>方法，初始化servlet上下文配置对象ServletConfig</p>
<p>4.会去执行<strong>service</strong>方法，service方法以后我们会用来执行请求的分发处理</p>
<p>5.当容器关闭的时候，会执行销毁方法<strong>destroy</strong></p>
<p>使用浏览器去访问项目资源时候，记得在xml文件下注册资源路径，例如将HelloServlet注册路径设置为&#x2F;hello</p>
<pre><code class="xml">  &lt;!--资源注册--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.os467.servlet.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;!--资源路径的配置--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
<p>servlet的实例是由容器所创建的</p>
<pre><code class="java">package com.os467.servlet;

import javax.servlet.*;
import java.io.IOException;

public class HelloServlet implements Servlet &#123;

    public HelloServlet()&#123;

        System.out.println(&quot;无参构造方法执行了!&quot;);

    &#125;


    /**
     * 初始化的方法
     * @param servletConfig
     * @throws ServletException
     */
    @Override
    public void init(ServletConfig servletConfig) throws ServletException &#123;

        System.out.println(&quot;init初始化方法执行了！&quot;);

    &#125;

    @Override
    public ServletConfig getServletConfig() &#123;
        return null;
    &#125;

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;

        System.out.println(&quot;service方法执行了！&quot;);

    &#125;

    @Override
    public String getServletInfo() &#123;
        return null;
    &#125;

    @Override
    public void destroy() &#123;

        System.out.println(&quot;destroy方法执行了！&quot;);

    &#125;
&#125;
</code></pre>
<h3 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h3><p>HttpServlet中的<strong>service</strong>方法为我们提供了请求分发的处理</p>
<p>创建一个HelloServlet类，继承HttpServlet</p>
<p>先由service方法接收到request对象，与response对象</p>
<p>再根据客户端提交的方式调用不同的方法</p>
<pre><code class="java">package com.os467.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class HelloServlet extends HttpServlet &#123;

    /**
     * servlet中的service方法实际上就是完成请求的分发处理，会根据客户端不同提交的方式来执行不同的方法
     * @param request 请求对象 一般用于请求客户端传递过来的数据或者用于获取浏览器的一些信息
     * @param response 响应对象 响应数据给前端
     * @throws ServletException
     * @throws IOException
     */

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        //获取客户端的提交方式
        String method = request.getMethod();

        //客户端的提交方式
        System.out.println(&quot;客户端的提交方式为：&quot;+method);

        if (method.equals(&quot;GET&quot;))&#123;

            doGet(request,response);

        &#125;else if (method.equals(&quot;POST&quot;))&#123;

            doPost(request,response);

        &#125;



    &#125;

    public void doGet(HttpServletRequest request,HttpServletResponse response)&#123;

        System.out.println(&quot;执行了doGet方法!!!&quot;);

    &#125;

    public void doPost(HttpServletRequest request,HttpServletResponse response)&#123;

        System.out.println(&quot;执行了doPost方法!!!&quot;);

    &#125;

&#125;
</code></pre>
<p>&#x2F;&#x2F;前端资源</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;form action=&quot;http://localhost:8080/servlet/hello&quot; method=&quot;post&quot;&gt;

        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;

    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h4><p>通过<strong>ServletConfig</strong>的对象来获取上下文配置信息（即xml文件内配置的信息）</p>
<pre><code class="java">  /**
     * ServletConfig用于获取上下文配置信息
     * @param config
     * @throws ServletException
     */
    @Override
    public void init(ServletConfig config) throws ServletException &#123;

        //获取初始化的数据
        String mysql_url = config.getInitParameter(&quot;mysql_url&quot;);

        System.out.println(mysql_url);
    &#125;
</code></pre>
<p>配置文件</p>
<pre><code class="xml"> &lt;servlet&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.os467.servlet.HelloServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;mysql_url&lt;/param-name&gt;
            &lt;param-value&gt;jdbc:mysql://localhost:3306&lt;/param-value&gt;
        &lt;/init-param&gt;

        &lt;init-param&gt;
            &lt;param-name&gt;username&lt;/param-name&gt;
            &lt;param-value&gt;root&lt;/param-value&gt;
        &lt;/init-param&gt;

        &lt;init-param&gt;
            &lt;param-name&gt;driver&lt;/param-name&gt;
            &lt;param-value&gt;com.mysql.jdbc.Driver&lt;/param-value&gt;
        &lt;/init-param&gt;

    &lt;/servlet&gt;
</code></pre>
<p>servlet配置对象和servlet域对象都是<strong>单例</strong>的(从工程启动时，这两个实例就创建成功了，使用的都是同一个对象)</p>
<p>单例模式（提高了系统资源，提高了程序的执行效率）</p>
<pre><code class="java">public void doGet(HttpServletRequest request,HttpServletResponse response)&#123;

        //获取servlet核心配置对象，打印结果为true
        ServletConfig servletConfig01 = getServletConfig();
        ServletConfig servletConfig02 = getServletConfig();

        System.out.println(servletConfig01 == servletConfig02);

        //获取servlet域对象,打印结果为true
        //1.
        ServletContext servletContext = getServletConfig().getServletContext();

        //2.
        ServletContext servletContext1 = getServletContext();

        System.out.println(servletContext == servletContext1);
    &#125;
</code></pre>
<h5 id="servlet域对象"><a href="#servlet域对象" class="headerlink" title="servlet域对象"></a>servlet域对象</h5><p><strong>ServletConfig</strong> 是servlet核心配置对象，而且该对象的生命周期是随着容器的创建而创建，<br>容器的销毁而销毁,在工程的任意位置去获取该实例的时候，指向的都是同一份内存地址<br><strong>作用</strong>：在servlet实例加载的时候去获取局部的初始化信息</p>
<p><strong>servletContext</strong> 是servlet中的一个上下文本对象，而且该对象的生命周期是随着容器的创建而创建，<br>容器的销毁而销毁，在工程的任意位置去获取该实例的时候，指向的都是同一份内存地址<br><strong>作用</strong>：可以像map一样存放数据，取出数据，而且是在工程的任意位置取出数据，范围是<strong>整个web工程</strong>，可以去读取全局的初始化信息，可以在工程的任何位置读取</p>
<p>后面会接触到的域对象：</p>
<p>request（也是一个域对象，也可以去存放数据，只不过该对象的取值范围比较小），session（会话对象，会对客户端和服务端进行一个绑定）</p>
<pre><code class="java">public void doGet(HttpServletRequest request,HttpServletResponse response)&#123;

        //获取servlet核心配置对象
        ServletConfig servletConfig0 = getServletConfig();

        //获取servlet域对象
        ServletContext servletContext = getServletConfig().getServletContext();

        //往域中存放数据
        servletContext.setAttribute(&quot;username&quot;,&quot;root&quot;);
        servletContext.setAttribute(&quot;password&quot;,&quot;123456&quot;);

        //取出域中的数据
        System.out.println(&quot;username的值为：&quot;+servletContext.getAttribute(&quot;username&quot;)+
        &quot;  password的值为：&quot;+servletContext.getAttribute(&quot;password&quot;));

    &#125;
</code></pre>
<p>取出全局的初始化数据</p>
<pre><code class="java"> //取出全局的初始化数据
        String name = servletContext.getInitParameter(&quot;name&quot;);
        String age = servletContext.getInitParameter(&quot;age&quot;);
        String sex = servletContext.getInitParameter(&quot;sex&quot;);

        System.out.println(name+&quot; &quot;+age+&quot; &quot;+sex);
</code></pre>
<p>配置文件（需要写在根标签web-app内部）</p>
<pre><code class="xml"> &lt;/servlet-mapping&gt;

    &lt;!--配置全局的初始化数据--&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;name&lt;/param-name&gt;
        &lt;param-value&gt;jack&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;age&lt;/param-name&gt;
        &lt;param-value&gt;20&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;sex&lt;/param-name&gt;
        &lt;param-value&gt;男&lt;/param-value&gt;
    &lt;/context-param&gt;


&lt;/web-app&gt;
</code></pre>
<p>**<init-param>**标签内的数据用servletConfig对象取出</p>
<p>**<context-param>**标签内的数据用servletContext对象取出</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>所谓HTTP协议，客户端和服务器之间通信时，发送的数据，需要遵循的规则，叫HTTP协议</p>
<p>请求分为GET和POST两种</p>
<p><strong>响应HTTP协议格式</strong></p>
<p>1.响应行</p>
<ul>
<li>响应的协议和版本号</li>
<li>响应状态码</li>
<li>响应状态描述符</li>
</ul>
<p>2.响应头key ：value不同的请求头，有不同的含义</p>
<p>3.响应体 &#x3D;&#x3D;&#x3D;&gt;&gt;&gt;就是回传给客户端的数据</p>
<p><strong>常用响应码说明</strong></p>
<ul>
<li>200表示请求成功</li>
<li>302表示请求重定向</li>
<li>404表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误）</li>
<li>500表示服务器已经收到请求，但是服务器内部错误（代码错误）</li>
</ul>
<h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p><strong>请求行</strong></p>
<p>1.请求的方式GET</p>
<p>2.请求的资源路径[+?+请求参数]</p>
<p>3.请求的协议的版本号HTTP&#x2F;1.1</p>
<p><strong>请求头</strong></p>
<p>key : value 组成 不同的键值对，表示不同的含义</p>
<p>无论客户端给服务器传数据，还是服务端给客户端传数据，都是基于http协议来完成数据的互传</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>客户端如何访问服务端，如何给服务区发送数据?</p>
<p>1.要知道访问服务端具体的地址</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/servlet/hello">http://localhost:8080/servlet/hello</a></p>
<p>格式：http:&#x2F;&#x2F;本地IP地址:端口号&#x2F;工程路径&#x2F;资源路径</p>
<p>2.如何去传递数据</p>
<p>看一下浏览器端的提交方式是什么，如果是get，则把数据封装在地址后面：资源路径?key1&#x3D;value1&amp;key2&#x3D;value2</p>
<p>如果是post提交方式，则数据是被封装在请求体中的</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>服务端给客户端响应数据，直接是在当前页面上完成，没有地址的跳转，响应的数据则直接被封装在响应体中</p>
<p>以后在前端框架中，我们会根据后端的响应数据，来完成前端逻辑的判断（比如AJA异步技术）</p>
<h3 id="HttpServletRequest类"><a href="#HttpServletRequest类" class="headerlink" title="HttpServletRequest类"></a>HttpServletRequest类</h3><p>每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中。然后传递到service方法（doGet和doPost）中给我们使用。我们可以通过HttpServletRequest对象，获取到所有请求的信息</p>
<h5 id="HttpServletRequest类的常用方法"><a href="#HttpServletRequest类的常用方法" class="headerlink" title="HttpServletRequest类的常用方法"></a>HttpServletRequest类的常用方法</h5><ul>
<li><p>getRequestURI()  获取请求的资源路径</p>
</li>
<li><p>getRequestURL()  获取请求的统一资源定位符（绝对路径）</p>
</li>
<li><p>getRemoteHost()  获取客户端的ip地址iv.getHeader()获取求头</p>
</li>
<li><p>getParameter()  获取请求的参数</p>
</li>
<li><p>getParameterValues()  获取请求的参数（多个值的时候使用）</p>
</li>
<li><p>getMethod()  获取请求的方法GET或POST</p>
</li>
<li><p>setAttribute(key,value)  设置域数据</p>
</li>
<li><p>getAttribute(key)  获取域数据</p>
</li>
<li><p>getRequestDispatcher()  获取请求转发对象</p>
</li>
</ul>
<h4 id="配置资源路径的方式-基于注解"><a href="#配置资源路径的方式-基于注解" class="headerlink" title="配置资源路径的方式(基于注解)"></a>配置资源路径的方式(基于注解)</h4><p>在类名上注释<code>@WebServlet(&quot;/hello05&quot;)</code></p>
<h5 id="GET方法处理："><a href="#GET方法处理：" class="headerlink" title="GET方法处理："></a>GET方法处理：</h5><pre><code class="java">package com.os467.servlet;

import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;

@WebServlet(&quot;/hello05&quot;)
public class HelloServlet04 extends HttpServlet &#123;
    
     @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        doGet(request,response);

    &#125;

     @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        //获取请求的资源路径
        String requestURI = request.getRequestURI();

        System.out.println(&quot;请求的资源路径为:&quot;+requestURI);

        //基于浏览器的全路径
        StringBuffer requestURL = request.getRequestURL();

        //http://localhost:8080/servlet/hello04
        System.out.println(requestURL);

        //获取客户端的ip
        String remoteHost = request.getRemoteHost();

        //0:0:0:0:0:0:0:1
        System.out.println(remoteHost);

        String header = request.getHeader(&quot;User-Agent&quot;);

        System.out.println(header);

        //获取请求的参数，获取客户端传递过来的数据
        String key1 = request.getParameter(&quot;key1&quot;);
        String key2 = request.getParameter(&quot;key2&quot;);
        String key3 = request.getParameter(&quot;key3&quot;);
        String name = request.getParameter(&quot;name&quot;);

        System.out.println(key1+&quot; &quot;+key2+&quot; &quot;+key3+&quot; &quot;+name);


    &#125;

&#125;
</code></pre>
<h5 id="Post方法处理："><a href="#Post方法处理：" class="headerlink" title="Post方法处理："></a>Post方法处理：</h5><p><strong>接收数据的方法:</strong></p>
<p><code>request.getParameter(&quot;key的值&quot;)</code></p>
<p><strong>处理中文乱码的方法:</strong></p>
<pre><code class="java">//处理中文乱码
request.setCharacterEncoding(&quot;utf-8&quot;);
</code></pre>
<pre><code class="java">package com.os467.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(&quot;/hello04&quot;)
public class HelloServlet04 extends HttpServlet &#123;

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        //处理中文乱码
        request.setCharacterEncoding(&quot;utf-8&quot;);

        if (request.getMethod().equals(&quot;GET&quot;))&#123;

            doGet(request,response);

        &#125;else if (request.getMethod().equals(&quot;POST&quot;))&#123;

            doPost(request,response);

        &#125;

    &#125;


    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        
        //获取客户端传递来的数据
        String username = request.getParameter(&quot;username&quot;);
        String password = request.getParameter(&quot;password&quot;);
        String sex = request.getParameter(&quot;sex&quot;);
        String country = request.getParameter(&quot;country&quot;);

        System.out.println(username);
        System.out.println(password);
        System.out.println(sex);
        System.out.println(country);

    &#125;
&#125;
</code></pre>
<p>前端布局：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;form action=&quot;http://localhost:8080/servlet/hello04&quot; method=&quot;post&quot;&gt;
        username:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;

        password:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt;

        男:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt; 女:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;br&gt;
        
        国籍:&lt;select name=&quot;country&quot;&gt;
            &lt;option value=&quot;1&quot;&gt;----请选择----&lt;/option&gt;
            &lt;option value=&quot;中国&quot;&gt;中国&lt;/option&gt;
            &lt;option value=&quot;美国&quot;&gt;美国&lt;/option&gt;
            &lt;option value=&quot;日本&quot;&gt;日本&lt;/option&gt;
            &lt;option value=&quot;德国&quot;&gt;德国&lt;/option&gt;
            &lt;/select&gt;&lt;br&gt;

        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;

    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>接收具有多个value值的key的方法</p>
<pre><code class="java">//通过请求对象来接收value有多个的key
        String[] hobbies = request.getParameterValues(&quot;hobby&quot;);
        
        //遍历value
        for (String hobby : hobbies) &#123;

            System.out.println(hobby);

        &#125;
</code></pre>
<h3 id="HttpServletResponse类"><a href="#HttpServletResponse类" class="headerlink" title="HttpServletResponse类"></a>HttpServletResponse类</h3><p><strong>HttpServletResponse</strong>类和<strong>HttpServletRequest</strong>类一样，每次请求进来，Tomcat服务器都会创建一个<strong>Response</strong>对象传递给Servlet程序去使用，HttpServletRequest表示<strong>请求过来的信息</strong>，HttpServletResponse表示所有<strong>响应的信息</strong>，我们如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象来进行设置</p>
<h5 id="往客户端回传数据"><a href="#往客户端回传数据" class="headerlink" title="往客户端回传数据"></a>往客户端回传数据</h5><p>字节流<strong>getOutputStream()</strong></p>
<p>效率高</p>
<p>常用于下载（传递二进制数据）</p>
<p>字符流<strong>getWriter()</strong></p>
<p>效率低</p>
<p>常用于回传字符串（常用）</p>
<p>响应中文乱码解决方法，以及设置浏览器可读取文本类型</p>
<p><code>setContentType(&quot;text/html;charset=UTF-8&quot;)</code></p>
<pre><code class="java">package com.os467.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(&quot;/hello06&quot;)
public class HelloServlet06 extends HttpServlet &#123;

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        //让前后端字符集统一的方法
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);

        //向tomcat服务器请求字符流对象
        response.getWriter().print(&quot;hello servlet&quot;);
        response.getWriter().print(&quot;&lt;br/&gt;&quot;);
        response.getWriter().print(&quot;响应成功！&quot;);
        response.getWriter().print(&quot;&lt;br/&gt;&quot;);
        response.getWriter().print(&quot;&lt;input type=&#39;text&#39;&gt;&quot;);
        


    &#125;
&#125;
</code></pre>
<p>案例：（通过前端访问，后端响应数据库数据给前端）</p>
<p>User用户类</p>
<p>JdbcUtils工具类</p>
<pre><code class="java">package com.os467.servlet;

import com.os467.beans.User;
import com.os467.utils.JdbcUtils;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;

public class UserServlet extends HttpServlet &#123;

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        //处理中文乱码
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);

        //获取提交类型
        String method = request.getMethod();

        if (method.equals(&quot;GET&quot;))&#123;

            doGet(request,response);

        &#125;else if (method.equals(&quot;POST&quot;))&#123;

            doPost(request,response);

        &#125;

    &#125;

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        Connection connection = null;

        PreparedStatement preparedStatement = null;

        ResultSet resultSet = null;

        //创建集合对象
        ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;();

        //获取数据库对象
        try &#123;
             connection = JdbcUtils.getConnection();

             //获取数据库操作对象并且预编译sql
             preparedStatement = connection.prepareStatement(&quot;select * from tb_user&quot;);

             //执行sql
             resultSet = preparedStatement.executeQuery();

             //遍历结果集
             while (resultSet.next())&#123;

                 //取出数据
                 int uid = resultSet.getInt(&quot;uid&quot;);

                 String username = resultSet.getString(&quot;username&quot;);

                 String password = resultSet.getString(&quot;password&quot;);

                 //创建用户对象
                 User user = new User(uid, username, password);

                 //将用户对象添加到集合
                 users.add(user);


             &#125;

           //将集合对象响应到前端
            response.getWriter().print(users);

        &#125; catch (Exception throwables) &#123;
            throwables.printStackTrace();
        &#125;finally &#123;

            //关闭资源
            JdbcUtils.getClose(resultSet,preparedStatement,connection);

        &#125;




    &#125;
&#125;
</code></pre>
<h3 id="请求的转发"><a href="#请求的转发" class="headerlink" title="请求的转发"></a>请求的转发</h3><p>请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫做请求转发。（地址不会改变，即浏览器路径不会跳转）</p>
<p>getRequestDispatcher() 获取请求转发对象</p>
<pre><code class="java">package com.os467.servlet;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(&quot;/hello01&quot;)
public class HelloServlet extends HttpServlet &#123;

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        //往域中去存放数据
        request.setAttribute(&quot;username&quot;,&quot;jack&quot;);
        request.setAttribute(&quot;password&quot;,&quot;123456&quot;);

        //获取转发对象  相对路径
        RequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;/hello02&quot;);

        //走向具体的资源
        requestDispatcher.forward(request,response);
    &#125;
&#125;
</code></pre>
<p>request除了可以作为请求对象之外，还可以作为域对象，但是该域对象的取值范围，是一次请求范围之内</p>
<p>request通过<code>setAttribute(key,value)</code>方法存放数据</p>
<p>通过<code>getAttribute(key)</code>方法获取数据</p>
<p>请求转发：内部资源的跳转，通过浏览器发起访问，工程中的资源会从一个地址跳转到另外一个地址，浏览器的地址不会发生改变</p>
<p><strong>请求转发集合对象</strong>  (使用request域存放数据，要使用请求转发)</p>
<pre><code class="java">package com.os467.servlet;

import com.os467.beans.User;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;

@WebServlet(&quot;/hello06&quot;)
public class HelloServlet06 extends HttpServlet &#123;


    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        //创建集合对象
        ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;();

        //创建用户对象
        User user1 = new User(100,&quot;jack001&quot;,&quot;123&quot;);
        User user2 = new User(100,&quot;jack002&quot;,&quot;123&quot;);
        User user3 = new User(100,&quot;jack003&quot;,&quot;123&quot;);
        User user4 = new User(100,&quot;jack004&quot;,&quot;123&quot;);
        User user5 = new User(100,&quot;jack005&quot;,&quot;123&quot;);

        //将数据添加到集合中去
        users.add(user1);
        users.add(user2);
        users.add(user3);
        users.add(user4);
        users.add(user5);

        //将集合存放到域中
        request.setAttribute(&quot;users&quot;,users);

        //执行请求转发
        request.getRequestDispatcher(&quot;/jsp/test.jsp&quot;).forward(request,response);

    &#125;
&#125;
</code></pre>
<h5 id="渲染后端数据-（使用jsp）"><a href="#渲染后端数据-（使用jsp）" class="headerlink" title="渲染后端数据 （使用jsp）"></a>渲染后端数据 （使用jsp）</h5><p>jsp的底层是java</p>
<p>不使用html，html作为一个静态文件，是不能读取动态数据的，需要用jsp去操作</p>
<p><strong>el表达式：</strong><br>      作用：取出后端域中的数据，完成数据的校验和判断<br>        <code>$&#123;后端域中的key&#125;</code></p>
<pre><code class="jsp">&lt;%--
  Created by IntelliJ IDEA.
  User: tly20
  Date: 2022/7/3
  Time: 19:54
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%--
        el表达式：
        取出后端域中的数据
        $&#123;后端域中的key&#125;
    --%&gt;
        $&#123;users&#125;


&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>使用servletContext域存放数据（可以使用请求重定向）</p>
<pre><code class="java">//获取域对象
ServletContext servletContext = getServletContext();

servletContext.setAttribute(&quot;users&quot;,users);
response.sendRedirect(&quot;http://localhost:8080/servlet/jsp/test.jsp&quot;);
</code></pre>
<h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p>请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端去新地址访问，叫做请求重定向</p>
<p>请求重定向：也可以完成内部资源的跳转，而且浏览器的地址是会发生改变的，这种情况下是不能取到request域中的数据的</p>
<pre><code class="java">package com.os467.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(&quot;/hello03&quot;)
public class HelloServlet03 extends HttpServlet &#123;

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        //存数据
        request.setAttribute(&quot;key&quot;,&quot;value&quot;);

        //请求重定向  绝对路径
        response.sendRedirect(&quot;http://localhost:8080/servlet/hello04&quot;);


    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.os467.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(&quot;/hello04&quot;)
public class HelloServlet04 extends HttpServlet &#123;

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

        Object key = request.getAttribute(&quot;key&quot;);
        
        //打印key的值应该为null，因为request域中的数据的作用范围只在一次请求范围内
        System.out.println(key);


    &#125;
&#125;
</code></pre>
<p><strong>注意的点：</strong></p>
<p>重定向和转发使用的域对象有哪些</p>
<ul>
<li>采用重定向的时候:    servletContext  session</li>
<li>采用转发的时候:   servletContext  request  session</li>
</ul>
<h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p>什么是jsp？</p>
<ul>
<li><p>JSP（全称Java Server Pages）是由Sun公司专门为了解决动态生成HTML文档的技术</p>
</li>
<li><p>jsp的主要作用是代替Servlet程序回传html页面的数据，因为Servlet程序回传html页面数据是一件非常繁琐的事情，开发成本和维护成本都极高</p>
</li>
</ul>
<p><strong>jsp的运行原理</strong></p>
<p>jsp的本质，其实是一个Servlet程序</p>
<p>可以在<code>&lt;%...%&gt;</code>内写java代码</p>
<p>通过脚本表达式<code>&lt;%=...%&gt;</code>取到值</p>
<p>也可以通过el表达式<code>$&#123;...&#125;</code>取到域对象中的值</p>
<p>el表达式可以取到后端中的数据，而且取值的方式比较简单${域的key}</p>
<p>jsp脚本表达式&lt;%&#x3D;request.getAttribute(“key”)%&gt;</p>
<p>el表达式其实在底层封装的就是对应的<strong>jsp</strong>脚本表达式，它出现目的就是为了替换脚本表达式，使得我们在开发的时候更高效</p>
<p>el表达式的用法：相关的逻辑判断，判断一个容器是否为空，el表达式取到的数据只能是域中的数据，</p>
<pre><code class="jsp">&lt;%--
  Created by IntelliJ IDEA.
  User: tly20
  Date: 2022/7/4
  Time: 9:53
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;study&lt;/title&gt;
&lt;/head&gt;

&lt;%
    String username = &quot;123456&quot;;
    request.setAttribute(&quot;key1&quot;,&quot;value1&quot;);
    
     ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();

    strings.add(&quot;hello&quot;);
    strings.add(&quot;world&quot;);
    strings.add(&quot;java&quot;);
    strings.add(&quot;c++&quot;);

    request.setAttribute(&quot;strings&quot;,strings);
    
    HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();

    hashMap.put(&quot;key1&quot;,&quot;value1&quot;);
    hashMap.put(&quot;key2&quot;,&quot;value2&quot;);
    hashMap.put(&quot;key3&quot;,&quot;value3&quot;);
    hashMap.put(&quot;key4&quot;,&quot;value4&quot;);

    session.setAttribute(&quot;hashMap&quot;,hashMap);
%&gt;
&lt;body&gt;
    
    &lt;%=request.getAttribute(&quot;key1&quot;)%&gt;
    &lt;%=username%&gt;
    $&#123;key1&#125;
    
    &lt;%=strings%&gt;&lt;br&gt;
    集合中的一个对象:$&#123;strings[0]&#125;&lt;br&gt;
    集合中的一个对象:$&#123;strings[1]&#125;&lt;br&gt;
    集合中的一个对象:$&#123;strings[2]&#125;&lt;br&gt;
    集合中的一个对象:$&#123;strings[3]&#125;&lt;br&gt;
    map集合对象:$&#123;hashMap&#125;&lt;br&gt;
    根据下表取到某一个元素:$&#123;hashMap.get(&quot;key1&quot;)&#125;&lt;br&gt;



&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>判断一个对象是否为空（指的是对象是否存在，不是说容器长度为0）</p>
<pre><code class="jsp">$&#123;empty strings&#125;   判断是否为空
$&#123;not empty strings&#125;  判断是否不为空
</code></pre>
<h4 id="引入jstl标签库"><a href="#引入jstl标签库" class="headerlink" title="引入jstl标签库"></a>引入jstl标签库</h4><pre><code class="jsp">&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
</code></pre>
<p><strong>ForEach标签</strong></p>
<p>items表示遍历集合， var表示遍历集合中每一个对象</p>
<pre><code class="jsp">&lt;c:forEach items=&quot;$&#123;empList&#125;&quot; var=&quot;emp&quot;&gt;

    &lt;tr&gt;
        &lt;td&gt;$&#123;emp.empName&#125;&lt;/td&gt;
        &lt;td&gt;$&#123;emp.age&#125;&lt;/td&gt;
        &lt;td&gt;$&#123;emp.sex == 1? &#39;男&#39; : &#39;女&#39;&#125;&lt;/td&gt;
        &lt;td&gt;$&#123;emp.salary&#125;&lt;/td&gt;
        &lt;td&gt;$&#123;emp.birthday&#125;&lt;/td&gt;
        &lt;td&gt;
            &lt;a href=&quot;http://localhost:8080/servlet/emp?flag=showEmpByID&amp;eid=$&#123;emp.eid&#125;&quot;&gt;修改&lt;/a&gt;
            &lt;a href=&quot;http://localhost:8080/servlet/emp?flag=deleteEmpByID&amp;eid=$&#123;emp.eid&#125;&quot;&gt;删除&lt;/a&gt;
        &lt;/td&gt;
    &lt;/tr&gt;

&lt;/c:forEach&gt;
</code></pre>
<p><strong>If标签</strong></p>
<pre><code class="jsp">&lt;c:if test=&quot;$&#123;not empty user&#125;&quot;&gt;
代码执行
&lt;/c:if&gt;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/02/servlet/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/01/jdbc/">
        <h2>
            Jdbc
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/1
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p><strong>JDBC是什么？</strong></p>
<p>jdbc是一个由sun公司(Oracle)提出的规范（一套接口），jdbc指的就是java语言连接数据库</p>
<p>jdbc就是一套面向所有数据库厂家的接口</p>
<p>每一个数据库厂家都希望可以通过java语言连接到自己开发的数据库，</p>
<p>这个时候，厂家肯定要写一套程序，java语言连接数据库的具体实现，这个实现类必须要实现JDBC接口</p>
<ul>
<li>作为开发人员来说，我们可能会连接到很多组不同的数据库，根据公司的业务不同，可能会连接mysql，SqlServer等等，但是我们不需要关注数据库具体的实现类是什么。我们关注的是jdbc这样的一套接口，因为这个接口提供了具体获取数据库对象的方法，还有相关执行增删改查的方法，还有相关事务提交的方法，事物处理的方法，我们只需要关注接口中有哪些方法，方法具体的实现交由数据库的厂家去完成！</li>
</ul>
<p>例如：java语言连接 Mysql</p>
<p>mysql的厂家就必须要实现jdbc这个接口</p>
<p><strong>JDBC的驱动类型</strong></p>
<ul>
<li>ODBC是微软为了解决跨数据平台的一个方案，sun提供支持</li>
<li>部分java驱动程序使用特定数据库的API（一般是C和C++）将jdbc翻译成数据库的特定代码</li>
<li>Jdbc-net将jdbc翻译成不针对特定数据库的网络协议，由数据库服务器翻译成特定代码</li>
<li>本地协议纯java驱动程序将jdbc请求转化成针对特定数据库的网络协议</li>
</ul>
<p><strong>JDBC的用途</strong></p>
<ol>
<li>加载对应数据库驱动（Load Driver）</li>
<li>与数据库建立连接（connection）</li>
<li>发送操作数据库的语句（createStatement）</li>
<li>执行并处理返回结果（executeQuery）</li>
</ol>
<h2 id="Java链接数据库"><a href="#Java链接数据库" class="headerlink" title="Java链接数据库"></a>Java链接数据库</h2><p>保证mysql服务是开启的</p>
<p>将java包导入到工程lib下，并且添加到类路径下（保证版本对应）</p>
<p>注册驱动，使用Class类下的一个静态方法<strong>forName</strong>,使得类加载</p>
<p>获取数据库连接 DriverManager类提供了<strong>getConnection</strong>方法 （需要传入数据源信息）</p>
<p>获取数据库操作对象 <strong>createStatement</strong>方法</p>
<p>编写sql语句</p>
<p>按照sql语句的类别调用不同方法,获取到返回的结果</p>
<p>关闭数据库资源（放在<strong>finally</strong>语句块中）</p>
<pre><code class="java">package com.os467.test;

import java.sql.*;

/**
 * JDBC编程六步：
 * 1.注册驱动
 * 2.获取数据库连接
 * 3.获取数据库操作对象
 * 4.执行sql
 * 5.返回记录条数/获取结果集对象
 * 6.关闭资源
 */

public class JdbcTest01 &#123;

    public static void main(String[] args) &#123;

        //使三个实例作为成员变量存在在类中，使得finally语句块中可以读取到
        Connection connection = null;

        Statement statement = null;

        ResultSet resultSet = null;

        try&#123;

            //1.注册驱动
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

            //2.获取数据库链接
            /**
             * String url 链接数据库的地址
             * String user 数据库的用户名 root
             * String password 数据库密码 root
             * jdbc:mysql:// 协议
             * localhost 本地的ip地址
             * 3306 默认端口号
             * os467test 需要使用的数据库
             * ?serverTimezone=GMT 设置时区
             */

            String url = &quot;jdbc:mysql://localhost:3306/os467test?serverTimezone=GMT&quot;;

            String user = &quot;root&quot;;

            String password = &quot;root&quot;;

            connection = DriverManager.getConnection(url, user, password);

            System.out.println(connection);

            //3.获取数据库操作对象
            statement = connection.createStatement();

            //4.编写sql语句，执行sql
            String sql = &quot;select * from emp&quot;;

            //5.执行sql，获取返回的结果集对象,遍历结果集
            resultSet = statement.executeQuery(sql);

            while(resultSet.next())&#123;

                //取出结果集中的数据
                int empno = resultSet.getInt(&quot;EMPNO&quot;);

                String ename = resultSet.getString(&quot;ENAME&quot;);

                System.out.println(&quot;员工的编号为&quot;+empno+&quot; 员工的姓名为&quot;+ename);

            &#125;


        &#125;catch (Exception e)&#123;

            e.printStackTrace();

        &#125;finally &#123;

            //6.关闭数据库资源,先进行非空校验，对close()可能发生的异常进行处理
            if (resultSet != null)&#123;

                try &#123;
                    resultSet.close();
                &#125; catch (SQLException throwables) &#123;
                    throwables.printStackTrace();
                &#125;

            &#125;

            if (statement != null)&#123;

                try &#123;
                    statement.close();
                &#125; catch (SQLException throwables) &#123;
                    throwables.printStackTrace();
                &#125;

            &#125;

            if (connection != null)&#123;

                try &#123;
                    connection.close();
                &#125; catch (SQLException throwables) &#123;
                    throwables.printStackTrace();
                &#125;

            &#125;

        &#125;

    &#125;


&#125;
</code></pre>
<p><strong>注意：</strong>在为字符集添加中文数据时，在<strong>url</strong>后面用**&amp;<strong>拼接</strong>characterEncoding&#x3D;utf-8**来设置字符集</p>
<p>并且数据库校对中每个字段的字符集也要设置为utf-8</p>
<pre><code class="java">package com.os467.test;

import javax.swing.*;
import java.sql.*;

/**
 * 往学生表中添加数据
 */
public class JdbcTest03 &#123;

    public static void main(String[] args) &#123;

        Connection connection = null;

        Statement statement = null;

        try &#123;

            //加载jdbc驱动
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

            String url = &quot;jdbc:mysql://localhost:3306/os467test?serverTimezone=GMT&amp;characterEncoding=utf-8&quot;;

            String user = &quot;root&quot;;

            String password = &quot;root&quot;;

            //链接数据库
            connection = DriverManager.getConnection(url, user, password);

            //获取操作对象
            statement = connection.createStatement();

            String sql = &quot;insert into tb_student(name,age,hobby)&quot; +
                    &quot;value(&#39;Tom&#39;,18,&#39;打篮球&#39;)&quot;;

            int num = statement.executeUpdate(sql);

            if (num != 0)&#123;

                System.out.println(&quot;添加成功&quot;);
            &#125;else&#123;

                System.out.println(&quot;添加失败&quot;);

            &#125;

        &#125;catch (Exception e)&#123;

            e.printStackTrace();

        &#125;finally &#123;
            
          //关闭数据库资源,避免占用系统资源
          if (statement != null)&#123;

              try &#123;
                  statement.close();
              &#125; catch (SQLException throwables) &#123;
                  throwables.printStackTrace();
              &#125;

          &#125;

          if (connection != null)&#123;

              try &#123;
                  connection.close();
              &#125; catch (SQLException throwables) &#123;
                  throwables.printStackTrace();
              &#125;

          &#125;



        &#125;


    &#125;


&#125;
</code></pre>
<p>&#x2F;&#x2F;模拟用户登入</p>
<pre><code class="sql">package com.os467.test;

import java.sql.*;
import java.util.Scanner;

public class UserJDBCTest02 &#123;

    public static void main(String[] args) &#123;

        //创建控制台打印对象
        Scanner scanner = new Scanner(System.in);

        System.out.println(&quot;请输入用户名:&quot;);

        String username = scanner.next();

        System.out.println(&quot;请输入密码:&quot;);

        String password = scanner.next();


        Connection connection = null;

        Statement statement = null;

        ResultSet resultSet = null;

        try&#123;

            //注册驱动
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

            String url = &quot;jdbc:mysql://localhost:3306/web_test?serverTimezone=GMT&amp;characterEncoding=utf-8&quot;;

            //获取数据库对象
            connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;);

            //获取数据库操作对象
            statement = connection.createStatement();

            resultSet = statement.executeQuery(&quot;select * from tb_user where username = &#39;&quot; + username + &quot;&#39; and password = &#39;&quot; + password + &quot;&#39;&quot;);

            //判断结果集是否为空和集合中是否有元素
            if(resultSet != null &amp;&amp; resultSet.next())&#123;

                System.out.println(&quot;登入成功&quot;);

            &#125;else&#123;

                System.out.println(&quot;登入失败&quot;);

            &#125;

        &#125;catch (Exception e)&#123;

            e.printStackTrace();

        &#125;finally &#123;

            if (resultSet != null)&#123;

                try &#123;
                    resultSet.close();
                &#125; catch (SQLException throwables) &#123;
                    throwables.printStackTrace();
                &#125;

            &#125;

            //关闭数据库资源
            if (statement != null)&#123;

                try &#123;
                    statement.close();
                &#125; catch (SQLException throwables) &#123;
                    throwables.printStackTrace();
                &#125;

            &#125;

            if (connection != null)&#123;

                try &#123;
                    connection.close();
                &#125; catch (SQLException throwables) &#123;
                    throwables.printStackTrace();
                &#125;

            &#125;

        &#125;



    &#125;

&#125;
</code></pre>
<p>数据库中创建的每一张表 在java中都有一个实体与之对应</p>
<p>table中的字段对应的是实体beans中的属性</p>
<p>tb_user					User</p>
<p>uid							uid</p>
<p>username				username</p>
<p>password				password</p>
<p>通过jdbc来读取数据，这些数据也是以对象的形式被封装在结果集容器中<strong>ResultSet</strong></p>
<p><code>resultSet !=null &amp;&amp; resultSet.next()</code></p>
<p>第一个条件保证容器对象不为空，判断容器中是否有元素</p>
<p>我们会将读取的数据封装成对象，然后将对象装进集合中（ArrayList&#x2F;HashMap）</p>
<p>后面学习了前端之后，我们会将集合对象传到前端，在前端取出集合中的数据，渲染数据！</p>
<h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p><strong>java事务</strong></p>
<p>实际上，一个Java应用系统，如果要操作数据库，则通过JDBC来实现的。增加、修改、删除都是通过相应方法间接来实现的，事务的控制也相应转移到java程序代码中。因此，数据库操作的事务习惯上就称为Java事务。</p>
<p>通俗的理解，事务是一组原子操作单元，从数据库角度说，就是一组SQL指令，要么全部执行成功，若因为某个原因其中一条指令执行有错误，则撤销先前执行过的所有指令。更简单的说就是：要么全部执行成功，要么撤销不执行。</p>
<ul>
<li>事务必须服从ISO&#x2F;IEC所制定的ACID原则。ACID是原子性（atomicity），一致性（consistency），隔离性（isolation）和持久性（durability）的缩写</li>
<li>通常的观念认为，事务仅与数据库相关</li>
<li>事务只存在于增删改状态下</li>
</ul>
<p><strong>事务的原子性：</strong>表示事务执行过程中的任何失败都将导致事务所作的任何修改失败</p>
<p><strong>事务的一致性：</strong>表示当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态</p>
<p><strong>事务的隔离性：</strong>表示在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见</p>
<p><strong>事务的持久性：</strong>表示已提交的数据在事务执行失败时，数据的状态都应该正确</p>
<p>案例：</p>
<p>银行存钱</p>
<p>银行取钱</p>
<p>转账方法 A B</p>
<p>假设有一个转账的场景：A账户转账给B账户，这个时候我们需要在A账户上扣钱，在B账户上加钱</p>
<p>所以我们需要去写两条sql来完成这样的需求，但是我们要开启事务的支持，因为这两条sql是在一条事务线上的，所以要么同时执行成功，要么同时失败，要满足事务的原子性和一致性。</p>
<h4 id="事务设置setAuntoCommit"><a href="#事务设置setAuntoCommit" class="headerlink" title="事务设置setAuntoCommit()"></a>事务设置setAuntoCommit()</h4><p>事务案例代码：</p>
<p><strong>jdbc默认状态下是自动提交的</strong></p>
<ul>
<li><p>A账户向B账户转账1000</p>
</li>
<li><p>模拟一个异常</p>
</li>
<li><p>开启对事务的支持</p>
</li>
<li><p>在jdbc中如何开启对事务的支持</p>
</li>
<li><p>jdbc默认是关闭事务的，如果想开启事务的话需要 <code>connection.setAutoCommit();</code><br>然后在sql都执行成功的情况下我们要进行一个事务提交的操作<code> connection.commit();</code></p>
</li>
<li><p><code>connection.rollback()</code>是一个回滚的方法，是为了让事务回到执行之前的状态</p>
</li>
</ul>
<pre><code class="java">/**
 * A账户向B账户转账1000
 *
 * 模拟一个异常
 *
 * 开启对事务的支持
 *
 * 在jdbc中如何开启对事务的支持
 *
 * jdbc默认是关闭事务的，如果想开启事务的话需要 connection.setAutoCommit();
 */
public class JdbcDemo02 &#123;

    public static void main(String[] args) &#123;

        Connection connection = null;

        Statement statement = null;

        try&#123;

            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);

            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/web_test?serverTimezone=GMT&amp;characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;root&quot;);

            //将自动提交设置为手动提交
            connection.setAutoCommit(false);

            statement = connection.createStatement();

            //A账户扣钱
            int num = statement.executeUpdate(&quot;update tb_account set balance_A = balance_A - 1000 where id = 1&quot;);

            System.out.println(num==1 ? &quot;扣钱成功&quot; : &quot;扣钱失败&quot;);

            //模拟一个异常
            int i = 1 / 0;

            //B账户加钱
            num = statement.executeUpdate(&quot;update tb_account set balance_B = balance_B + 1000 where id = 1&quot;);

            System.out.println(num==1?&quot;转账成功&quot;:&quot;转账失败&quot;);

            //提交事务
            connection.commit();

        &#125; catch (Exception e) &#123;

            e.printStackTrace();

        &#125;finally&#123;

            if (statement != null)&#123;

                try &#123;
                    statement.close();
                &#125; catch (SQLException throwables) &#123;

                    //事务回滚
                    try &#123;
                        connection.rollback();
                    &#125; catch (SQLException e) &#123;
                        e.printStackTrace();
                    &#125;

                    throwables.printStackTrace();
                &#125;

            &#125;

            if (connection != null)&#123;

                try &#123;
                    connection.close();
                &#125; catch (SQLException throwables) &#123;
                    throwables.printStackTrace();
                &#125;

            &#125;

        &#125;

    &#125;

&#125;
</code></pre>
<h4 id="预编译PreparedStatement"><a href="#预编译PreparedStatement" class="headerlink" title="预编译PreparedStatement"></a>预编译PreparedStatement</h4><p><strong>sql注入</strong>：指的就是通过在sql中加入数据库的关键字，导致最终sql执行的结果是错误的</p>
<p><strong>PreparedStatement</strong> 这个对象可以防止sql注入 因为这个对象在执行sql的时候</p>
<p>是分为两个步骤： 1.先预编译sql，先把sql的架子给搭建出来，但是没有赋值，2.给sql中注入具体的数据，执行sql</p>
<p><strong>Statement</strong>对象没有预编译的过程，直接就是执行sql</p>
<p>考虑到安全性我们以后不会直接使用<code>Statement</code>而是使用<code>PreparedStatement</code></p>
<pre><code class="java">              //获取数据库操作对象并且预编译sql
             PreparedStatement preparedStatement = connection.prepareStatement(&quot;select * from tb_user where username = ? and password = ? &quot;);

             //给占位符?赋值,占位符从1开始
            preparedStatement.setString(1,&quot;jack001&quot;);
            preparedStatement.setString(2,&quot;123456&quot;);

            //执行sql
            resultSet = preparedStatement.executeQuery();

            if (resultSet != null &amp;&amp; resultSet.next())&#123;

                System.out.println(&quot;登录成功&quot;);

            &#125;
</code></pre>
<p>关于数据库的悲观锁和乐观锁（都是跟事务有关的）：</p>
<p>​	乐观锁：假设在多线程场景下，多个线程同时对数据库中的一个表进行操作</p>
<p>​	如果多个线程会去修改同一条数据，乐观锁的思想就是觉得这种情况不可能发生</p>
<p><strong>乐观锁：</strong>乐观锁可以不用去开启事务的支持（采用的是自动提交的策略）</p>
<pre><code class="sql">update tb_user set username = &#39;tom&#39; where id = 1 and version = &quot;影响记录条数只要大于等于1，这个	版本号就会改变&quot;
</code></pre>
<p><strong>悲观锁：</strong>针对于以上描述的情况，悲观锁思想就会觉得这种情况一定会发生，然后要提前去解决这个问题</p>
<p>悲观锁一定要去开启对事务的支持，采用手动提交的策略来解决问题，行级锁，在sql后面加上 for update</p>
<pre><code class="sql">select * from tb_account where id = 1 for update;
</code></pre>
<p>当一个线程在对某一条记录进行查询的时候，那么别的线程只能等待</p>
<h4 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h4><p>工具类不能实例化对象，构造函数被private修饰</p>
<p>所有的方法都要被static修饰</p>
<pre><code class="java">package com.os467.utils;

import java.sql.*;

/**
 * 封装工具类的步骤：
 *
 * 1.构造方法私有化
 * 2.所有的方法都得是静态方法
 *
 */

public class JdbcUtils &#123;

    //私有化构造方法
    private JdbcUtils()&#123;

    &#125;

    //注册驱动
    static &#123;

        try &#123;
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;

    /**
     * 获取数据库链接方法
     */
    public static Connection getConnection() throws SQLException&#123;

        return DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306&quot; +
                &quot;/web_test?serverTimezone=GMT&amp;characterEncoding=utf-8&quot;,
                &quot;root&quot;, &quot;root&quot;);

    &#125;

    /**
     * 用于关闭资源的方法
     */
    public static void getClose(ResultSet resultSet, Statement statement,Connection connection)&#123;

        if (resultSet != null)&#123;

            try &#123;
                resultSet.close();
            &#125; catch (SQLException throwables) &#123;
                throwables.printStackTrace();
            &#125;

        &#125;

        if (statement != null)&#123;

            try &#123;
                statement.close();
            &#125; catch (SQLException throwables) &#123;
                throwables.printStackTrace();
            &#125;

        &#125;

        if (connection != null)&#123;

            try &#123;
                connection.close();
            &#125; catch (SQLException throwables) &#123;
                throwables.printStackTrace();
            &#125;

        &#125;

    &#125;

&#125;
</code></pre>
<p>利用工具类来执行sql</p>
<pre><code class="java">package com.os467.demmo;

import com.os467.utils.JdbcUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class JdbcDemo03 &#123;

    public static void main(String[] args) &#123;

        PreparedStatement preparedStatement = null;

        ResultSet resultSet =null;

        Connection connection = null;

        try &#123;
            //获取数据库链接对象
            connection = JdbcUtils.getConnection();

            //获取数据库操作对象
            preparedStatement = connection.prepareStatement(&quot;select * from tb_user&quot;);

            //执行sql
            resultSet = preparedStatement.executeQuery();

            if (resultSet != null)&#123;

                while (resultSet.next())&#123;

                    int uid = resultSet.getInt(&quot;uid&quot;);

                    String username = resultSet.getString(&quot;username&quot;);

                    String password = resultSet.getString(&quot;password&quot;);

                    System.out.println(uid+&quot; &quot;+username+&quot; &quot;+password);

                &#125;

            &#125;

        &#125; catch (SQLException throwables) &#123;
            throwables.printStackTrace();
        &#125;finally &#123;

            JdbcUtils.getClose(resultSet,preparedStatement,connection);

        &#125;

    &#125;

&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/01/jdbc/" class="go-post">
        阅读全文
    </a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <svg class="fa-icon"><use xlink:href="#caret-right-solid"></use></svg>
            </span>
        </a>
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://img.gejiba.com/images/ad7295b88b395d72d985a0835695dd71.jpg " alt="avatar">
        </div>
        <div class="name">
            Os467
        </div>
        <div class="descriptions">
            
            <div class="description">
                Description...
            </div>
            
        </div>
        <div class="icon-links">
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2022 Tly的博客
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Os467
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>