
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Tly的博客</title>
        <meta name="author" content="Os467">
        <meta name="description" content="Welcome">
        <meta name="keywords" content="">
        <link rel="icon" href="https://img.gejiba.com/images/ad7295b88b395d72d985a0835695dd71.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Tly的博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Tly的博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(https://img.gejiba.com/images/d3d5ed8eab68b8414a1f6284d28676e7.png)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Tly的博客</h1>
                <h3>Hi,i'm os467</h3>
                <h5>Welcome</h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class=>
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/07/28/Maven/">
        <h2>
            Maven
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/28
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="Maven介绍"><a href="#Maven介绍" class="headerlink" title="Maven介绍"></a>Maven介绍</h2><ul>
<li>Maven是 Apache 下的一个纯 Java 开发的开源项目</li>
<li>基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤</li>
<li>Maven 是一个项目管理工具，可以对 Java 项目进行构建、<strong>依赖管理</strong></li>
</ul>
<p>Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</p>
<p>maven可以帮助管理我们的项目</p>
<p><strong>底层：</strong>基于java</p>
<p><strong>特色：</strong>完成对jar包资源的管理</p>
<p><strong>Maven常用命令</strong></p>
<ul>
<li>mvn archetype:generate 创建Maven项目</li>
<li>mvn compile 编译源代码</li>
<li>mvn deploy 发布项目</li>
<li>mvn test-compile 编译测试源代码</li>
<li>mvn test 运行应用程序中的单元测试</li>
<li>mvn site 生成项目相关信息的网站</li>
<li><strong>mvn clean</strong> 清除项目目录中的生成结果</li>
<li><strong>mvn package</strong> 根据项目生成的jar</li>
<li><strong>mvn install</strong> 在本地Repository中安装jar</li>
<li>mvn eclipse:eclipse 生成eclipse项目文件</li>
<li>mvnjetty:run 启动jetty服务</li>
<li>mvntomcat:run 启动tomcat服务</li>
<li>mvn clean package -Dmaven.test.skip&#x3D;true:清除以前的包后重新打包，跳过测试类</li>
</ul>
<h3 id="Maven核心配置文件"><a href="#Maven核心配置文件" class="headerlink" title="Maven核心配置文件"></a>Maven核心配置文件</h3><p><strong>pom.xml</strong></p>
<p><strong>存放资源坐标</strong></p>
<p>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;!--
        groupId、artifactId、version这三个标签对应的是一个坐标
        一个坐标会在仓库中映射到一个jar包资源
    --&gt;

    &lt;!--组织名称--&gt;
    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;!--工程名称--&gt;
    &lt;artifactId&gt;day31_maven_01&lt;/artifactId&gt;
    &lt;!--版本号--&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;


&lt;/project&gt;
</code></pre>
<h2 id="父（Super）POM"><a href="#父（Super）POM" class="headerlink" title="父（Super）POM"></a>父（Super）POM</h2><p>父（Super）POM是 Maven 默认的 POM。所有的 POM 都继承自一个父 POM（无论是否显式定义了这个父 POM）。父 POM 包含了一些可以被继承的默认设置。因此，当 Maven 发现需要下载 POM 中的 依赖时，它会到 Super POM 中配置的默认仓库 <a target="_blank" rel="noopener" href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a> 去下载。</p>
<p>Maven 使用 effective pom（Super pom 加上工程自己的配置）来执行相关的目标，它帮助开发者在 pom.xml 中做尽可能少的配置，当然这些配置可以被重写。</p>
<p>使用以下命令来查看 Super POM 默认配置：</p>
<pre><code class="cmd">mvn help:effective-pom
</code></pre>
<h2 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h2><p><strong>本地仓库</strong>：</p>
<p>存放的就是对应的jar包资源，在程序中可以根据坐标去映射</p>
<p><strong>远程仓库</strong>：</p>
<p>通过一个坐标映射去本地仓库去找资源，但是本地仓库没有对应的jar包资源，这个时候maven会自动的去连接远程仓库，根据坐标下载对应的jar包资源到本地仓库（这种情况下你的电脑是必须联网的，不然就会下载失败）</p>
<p>更改默认仓库标签，在xml文件中添加下面标签</p>
<p><strong>apache-maven-3.3.9\conf\settings.xml</strong></p>
<pre><code class="xml">&lt;localRepository&gt;D:/Maven/maven_work&lt;/localRepository&gt;
</code></pre>
<h2 id="Maven-阿里云-Aliyun-仓库"><a href="#Maven-阿里云-Aliyun-仓库" class="headerlink" title="Maven 阿里云(Aliyun)仓库"></a>Maven 阿里云(Aliyun)仓库</h2><p>Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库。</p>
<p>修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件，在 mirrors 节点上，添加内容如下：</p>
<pre><code class="xml">&lt;mirror&gt;
  &lt;id&gt;aliyunmaven&lt;/id&gt;
  &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
  &lt;name&gt;阿里云公共仓库&lt;/name&gt;
  &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
&lt;/mirror&gt;
</code></pre>
<h3 id="在idea中配置maven"><a href="#在idea中配置maven" class="headerlink" title="在idea中配置maven"></a>在idea中配置maven</h3><p>File → settings→搜索maven</p>
<p>配置Maven home directory路径</p>
<p>User settings file选中Override改成对应maven下的settings.xml文件</p>
<p>修改Runner中maven的JER运行时环境改成所使用的jdk版本</p>
<p><strong>全局生效需要在IDEA主页面Configure中设置</strong></p>
<h3 id="在pom-xml中手动添加坐标"><a href="#在pom-xml中手动添加坐标" class="headerlink" title="在pom.xml中手动添加坐标"></a>在pom.xml中手动添加坐标</h3><pre><code class="xml">&lt;!--这个标签里面是用来写坐标的--&gt;
&lt;dependencies&gt;
    
    &lt;!--导入单元测试的资源--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.13&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre>
<p>尝试搭建一个spring + springMVC + Maven这样的架构</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/28/Maven/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/26/spring/">
        <h2>
            Spring
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/26
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="spring概述"><a href="#spring概述" class="headerlink" title="spring概述"></a>spring概述</h2><p>Spring是分层的 Java SE&#x2F;EE 应用 full-stack <strong>轻量级开源框架</strong>，以<strong>IoC</strong>（Inverse Of Control：<strong>反转控制</strong>）和<strong>AOP</strong>（Aspect Oriented Programming：<strong>面向切面编程</strong>）为内核，提供了展现层<strong>Spring MVC</strong>和持久层<strong>Spring JDBC</strong>以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 <strong>Java EE</strong> 企业应用开源框架</p>
<p>spring官网：<a target="_blank" rel="noopener" href="http://spring.io/">http://spring.io/</a></p>
<h2 id="Spring的发展历程"><a href="#Spring的发展历程" class="headerlink" title="Spring的发展历程"></a>Spring的发展历程</h2><p>1997年IBM提出了EJB的思想</p>
<p>1998年，SUN制定开发标准规范EJB1.0</p>
<p>1999年，EJB1.1发布</p>
<p>2001年，EJB2.0发布</p>
<p>2003年，EJB2.1发布</p>
<p>2006年，EJB3.0发布</p>
<p>Rod Johnson（spring之父）</p>
<p>2017年9月份发布了spring的最新版本spring5.0通用版</p>
<p><strong>框架的定义</strong>：拥有一整套解决方案</p>
<p>1、spring是一个容器，这个容器会管理很多的组件（java bean）</p>
<p>2、spring可以很好的解决程序间的耦合</p>
<p>3、spring可以集成很多第三方框架，可以充当众多技术栈之间的一个粘合剂</p>
<h2 id="Spring的优势"><a href="#Spring的优势" class="headerlink" title="Spring的优势"></a>Spring的优势</h2><p><strong>方便解耦，简化开发</strong></p>
<p>通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合，用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于业务层上的应用</p>
<p><strong>AOP编程的支持</strong></p>
<p>通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付</p>
<p><strong>声明式事务的支持</strong></p>
<p>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明方式灵活的进行事务的管理，提高开发效率和质量</p>
<p><strong>方便程序的测试</strong></p>
<p>可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情</p>
<p><strong>方便集成各种优秀框架</strong></p>
<p>Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持</p>
<p><strong>降低 JavaEE API 的使用难度</strong></p>
<p>Spring 对 JavaEE API （如JDBC、JavaMail、远程调用等）进行了薄薄的封装，使这些API的使用难度大为降低</p>
<p><strong>Java源码是经典学习范例</strong></p>
<p>Spring 的源代码设计精妙，结构清晰，匠心独用，处处体现着大师对Java设计模式灵活运用以及对 Java 技术的高深造诣，它的源代码无疑是Java技术的最佳实践范例</p>
<h2 id="Spring的体系结构"><a href="#Spring的体系结构" class="headerlink" title="Spring的体系结构"></a>Spring的体系结构</h2><p><img src="https://img-blog.csdnimg.cn/2020031110534271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlbGxvX3dvcmQy,size_16,color_FFFFFF,t_70"></p>
<p><strong>Core Container （spring核心容器）</strong></p>
<p>为其它模块提供<strong>支持</strong></p>
<p><strong>Data Access&#x2F;Integration（持久层相关）</strong></p>
<p><strong>Test</strong>单元测试模块</p>
<h3 id="程序间的耦合"><a href="#程序间的耦合" class="headerlink" title="程序间的耦合"></a>程序间的耦合</h3><ul>
<li><p><strong>耦合性</strong>（Coupling），也叫耦合度，是对模块间<strong>关联程度的度量</strong>，耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过页面传送数据的多少</p>
</li>
<li><p>模块间的耦合度是指模块之间的<strong>依赖关系</strong>，包括控制关系、调用关系，数据传递关系，模块间联系越多，其耦合性越强，同时表明其独立性越差（降低耦合性，可以提高其独立性）</p>
</li>
<li><p>耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合</p>
</li>
</ul>
<p><strong>工厂模式解耦</strong></p>
<ul>
<li><p>在实际开发中我们可以把三层的对象都使用<strong>配置文件配置</strong>起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，<strong>把这些对象创建出来并存起来</strong>，在接下来的使用的时候，直接拿过来用就好了</p>
</li>
<li><p>那么，这个<strong>读取配置文件</strong>，创建和获取三层对象的类就是<strong>工厂</strong></p>
</li>
</ul>
<p><strong>spring中工厂的类结构图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200221113909842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIT05HWkVXRUk=,size_16,color_FFFFFF,t_70"></p>
<p><strong>控制反转 IoC</strong></p>
<ul>
<li><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种<strong>设计原则</strong>，可以用来<strong>降低</strong>计算机代码之间的<strong>耦合度</strong>，其中最常见的方式叫做<strong>依赖注入</strong>（Dependency Injection，简称DI）</p>
</li>
<li><p>还有一种方式叫<strong>依赖查找</strong>（Dependency Lookup），通过控制反转，对象在被创建的时候，依赖被注入到对象中</p>
</li>
</ul>
<p>明确IoC的作用：<strong>削减计算机程序的耦合</strong>（解除代码中的依赖关系）</p>
<p>IOC是解耦的一种思想：解耦的途径有很多：比如依赖注入<strong>DI</strong>（只是解耦的一种解决方案）</p>
<p>程序中核心业务代码由主动创建对象变成<strong>被动的接收对象</strong></p>
<p><strong>★创建对象的控制权发生了转变（控制反转）</strong></p>
<p>依赖注入：不在类中直接new对象，在外部需要使用本类时提供对象（可以通过工厂获取对象） （set注入，构造注入）</p>
<p><strong>例如在业务层不直接提供持久层的实例</strong></p>
<pre><code class="java">public class TestServiceImpl implements TestService &#123;

    private TestDao testDao;

    //提供一个构造方法覆盖掉原有构造
    public TestServiceImpl(TestDao testDao) &#123;
        this.testDao = testDao;
    &#125;

    @Override
    public void findData() &#123;

        testDao.findData();

    &#125;
&#125;
</code></pre>
<h1 id="★IOC"><a href="#★IOC" class="headerlink" title="★IOC"></a>★IOC</h1><h2 id="IOC-—-spring的IOC解决程序耦合"><a href="#IOC-—-spring的IOC解决程序耦合" class="headerlink" title="IOC — spring的IOC解决程序耦合"></a>IOC — spring的IOC解决程序耦合</h2><h2 id="基于xml的方式来创建spring核心容器对象"><a href="#基于xml的方式来创建spring核心容器对象" class="headerlink" title="基于xml的方式来创建spring核心容器对象"></a>基于xml的方式来创建spring核心容器对象</h2><p><strong>基于XML的配置</strong></p>
<p>导入配置文件约束</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;
</code></pre>
<p>创建一个xml文件，导入spring核心容器相关的约束 &#x3D;&#x3D;&gt; 创建核心容器对象 &#x3D;&#x3D;&gt; 从容器中去取出实例</p>
<p>1、spring是一个容器，里面存放了很多的实例</p>
<p>2、可以把spring理解成一个工厂，我们需要从工厂中获取实例</p>
<p>3、创建一个xml文件，导入spring核心容器相关的约束，可以使用spring提供的相关标签（标签里面是存放数据的）</p>
<p>4、spring会解析这个xml标签中的数据</p>
<p><strong>ApplicationContext 接口的实现类</strong>：</p>
<ul>
<li><p>ClassPathXmlApplicationContext：</p>
<p>它是从<strong>类的根路径</strong>下加载配置文件 推荐使用这种</p>
</li>
<li><p>FileSystemXmlApplicationContext：</p>
<p>它是从<strong>磁盘路径</strong>上加载配置文件，配置文件可以在磁盘的任意位置</p>
</li>
<li><p>AnnotationConfigApplicationContext：</p>
<p>当我们使用注解配置容器对象时，需要使用此类来创建spring容器，它用来<strong>读取注解</strong>，需要提供核心配置类的<strong>字节码</strong></p>
</li>
</ul>
<p>在spring中，如何将一个类的实例装载到spring容器中?</p>
<p><strong>基于xml的方式来创建spring核心容器对象</strong>：</p>
<p><strong>bean标签</strong>的作用：将一个类的实例通过反射机制创建出来，装载进核心容器中，默认情况下它调用的是类中的无参构造函数，如果<strong>没有无参构造函数</strong>则不能创建成功</p>
<p><strong>id属性</strong>：唯一标识，不能重复的，给对象在容器中提供唯一标识，用于获取对象<br><strong>class属性</strong>：指定类的全限定类名，用于反射创建对象，默认情况下调用无参构造函数</p>
<p><strong>scope属性</strong>：可以去设置该实例的<strong>作用范围</strong></p>
<pre><code class="xml"> &lt;bean id=&quot;aaa&quot; class=&quot;com.beans.User&quot;&gt;&lt;/bean&gt;
</code></pre>
<p><strong>从容器中取出实例</strong></p>
<pre><code class="java">public static void main(String[] args) &#123;

    //创建核心容器对象
    ApplicationContext applicationContext =

            new ClassPathXmlApplicationContext(&quot;xml/beans.xml&quot;);

    //要从容器中取出对应的实例
    Object bean = applicationContext.getBean(&quot;aaa&quot;);

    if (bean instanceof User)&#123;

        User user = (User)bean;

        //com.beans.User@42d80b78
        System.out.println(user);

    &#125;

&#125;
</code></pre>
<p>sping在获取实例时的执行流程：</p>
<p>会解析xml文件，去读取每一个标签，如果发现有bean标签，那么会解析bean标签对应的属性，会去读取class属性的属性值，然后通过反射机制创建实例，保存到容器中，会将id属性作为该实例的标识</p>
<p><strong>问：</strong>如果将一个实例存放进核心容器中，在程序中多次获取该实例，取得的实例是不是单例的?</p>
<p>​		<strong>默认情况下是单例的</strong>，但是我们可以将其<strong>修改为多例的</strong></p>
<p><strong>在标签下修改scope属性</strong></p>
<p><strong>singleton</strong>：默认值，单例的</p>
<p><strong>prototype</strong>：多例的</p>
<p><strong>request</strong>：WEB项目中，Spring创建一个Bean的对象，将对象存入到request域中</p>
<p><strong>session</strong>：WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中</p>
<p><strong>global session</strong>：WEB项目中，应用在Portlet环境，如果没有Porlet环境那么globalSession相当于session</p>
<pre><code class="xml">&lt;!--和默认情况相同，是单例的--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.beans.User&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;

&lt;!--修改为多例的--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.beans.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
</code></pre>
<h4 id="依赖注入-Dependency-Injection"><a href="#依赖注入-Dependency-Injection" class="headerlink" title="依赖注入 Dependency Injection"></a>依赖注入 Dependency Injection</h4><ul>
<li><p><strong>DI—Dependency Injection</strong>，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中</p>
</li>
<li><p>依赖注入的目的并非为软件系统带来更多功能，而是为了<strong>提升组件重用的频率</strong>，并为系统搭建一个灵活、可扩展的平台</p>
</li>
<li><p>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现</p>
</li>
</ul>
<h5 id="基于XML配置的依赖注入-set方式"><a href="#基于XML配置的依赖注入-set方式" class="headerlink" title="基于XML配置的依赖注入(set方式)"></a>基于XML配置的依赖注入(set方式)</h5><p><strong>property标签的作用</strong>：</p>
<p>要通过<strong>set方法在</strong>xml配置文件中实现依赖注入，<strong>在类中必须实现set方法</strong></p>
<p>name属性：类的属性名</p>
<p>value属性：类的属性值</p>
<p>ref属性：可以去引入容器中别的实例，属性值就是需要传入的实例的<strong>唯一标识</strong></p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;com.beans.User&quot; scope=&quot;prototype&quot;&gt;

    &lt;!--给id属性赋值--&gt;
    &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;name&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;
    
&lt;/bean&gt;
</code></pre>
<p><strong>给数组赋值</strong></p>
<pre><code class="xml">&lt;!--给数组注入数据--&gt;
&lt;property name=&quot;objects&quot;&gt;
    &lt;array value-type=&quot;java.lang.String&quot;&gt;
        &lt;value&gt;a&lt;/value&gt;
        &lt;value&gt;b&lt;/value&gt;
        &lt;value&gt;c&lt;/value&gt;
    &lt;/array&gt;
&lt;/property&gt;
</code></pre>
<p><strong>给自定义引用数据类型赋值</strong></p>
<pre><code class="xml">&lt;!--注入自定义的引用数据类型--&gt;
&lt;property name=&quot;student&quot; ref=&quot;student&quot;&gt;&lt;/property&gt;
&lt;!--将学生实例装载进核心容器中--&gt;
&lt;bean id=&quot;student&quot; class=&quot;com.beans.Student&quot;&gt;&lt;/bean&gt;
</code></pre>
<p><strong>List</strong></p>
<pre><code class="xml">&lt;!--给list类型的属性注入数据--&gt;
&lt;property name=&quot;list&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;123456&lt;/value&gt;
        &lt;value&gt;ture&lt;/value&gt;
        &lt;value&gt;false&lt;/value&gt;
        &lt;value&gt;1100&lt;/value&gt;
    &lt;/list&gt;
&lt;/property&gt;
</code></pre>
<p><strong>Map</strong></p>
<pre><code class="xml">&lt;!--给map类型的属性注入数据--&gt;
&lt;property name=&quot;map&quot;&gt;
    &lt;map&gt;
        &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt;
        &lt;entry key=&quot;key2&quot; value=&quot;value2&quot;&gt;&lt;/entry&gt;
        &lt;entry key=&quot;key3&quot; value=&quot;value3&quot;&gt;&lt;/entry&gt;
        &lt;entry key=&quot;key4&quot; value=&quot;value4&quot;&gt;&lt;/entry&gt;
    &lt;/map&gt;
&lt;/property&gt;
</code></pre>
<p><strong>Date</strong></p>
<pre><code class="xml">&lt;!--注入日期类型数据--&gt;
&lt;property name=&quot;date&quot; ref=&quot;date&quot;&gt;&lt;/property&gt;

&lt;!--注册一个日期实例--&gt;
&lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
</code></pre>
<hr>
<h5 id="基于XML配置的依赖注入-构造方式"><a href="#基于XML配置的依赖注入-构造方式" class="headerlink" title="基于XML配置的依赖注入(构造方式)"></a>基于XML配置的依赖注入(构造方式)</h5><p><strong>基于构造方法完成对值的注入</strong></p>
<p><strong>constructor-arg</strong></p>
<p>根据有参构造来创建实例</p>
<pre><code class="xml">&lt;!--注册User实例--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.os467.beans.User&quot;&gt;

    &lt;!--通过构造方法来为属性完成注入--&gt;
    &lt;constructor-arg name=&quot;username&quot; value=&quot;zs001&quot;&gt;&lt;/constructor-arg&gt;

&lt;/bean&gt;
</code></pre>
<p>多个参数构造创建实例</p>
<pre><code class="xml">&lt;!--注册User实例--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.os467.beans.User&quot;&gt;

    &lt;!--通过构造方法来为属性完成注入--&gt;
    &lt;constructor-arg name=&quot;username&quot; value=&quot;zs001&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;date&quot; ref=&quot;date&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;!--注册Date实例--&gt;
&lt;bean name=&quot;date&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
</code></pre>
<h3 id="关于组件的生命周期"><a href="#关于组件的生命周期" class="headerlink" title="关于组件的生命周期"></a>关于组件的生命周期</h3><p><strong>组件的作用范围是单例的：</strong></p>
<ul>
<li>组件会随着容器的销毁而销毁</li>
</ul>
<p><strong>init-method</strong>属性：对象在初始化时会执行的对应方法</p>
<p><strong>destroy-method</strong>属性：对象在销毁时会执行的对应方法</p>
<pre><code class="xml">&lt;bean id=&quot;user&quot; class=&quot;com.os467.beans.User&quot; scope=&quot;singleton&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt;
</code></pre>
<p><strong>需要在类中定义方法</strong></p>
<pre><code class="java">public void initMethod()&#123;

    System.out.println(&quot;初始化的方法执行了&quot;);

&#125;

public void destroyMethod()&#123;

    System.out.println(&quot;销毁的方法执行了&quot;);

&#125;
</code></pre>
<p>关闭容器对象的方法</p>
<p>但是要用<strong>ClassPathXmlApplicationContext</strong>去接收才能调用此方法</p>
<pre><code class="java">//关闭容器对象
applicationContext.close();
</code></pre>
<p>关闭后，容器中的实例会被销毁</p>
<p><strong>组件的作用范围是多例的：</strong></p>
<ul>
<li>容器销毁时，组件不会销毁，会等着垃圾回收机制去回收</li>
</ul>
<h3 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h3><p>BeanFactory才是Spring容器中的<strong>顶层接口</strong></p>
<p>ApplicationContext是它的<strong>子接口</strong></p>
<p><strong>创建对象的时间点不一样</strong></p>
<ul>
<li><p>ApplicationContext：只要一读取配置文件，默认情况下就会创建对象</p>
</li>
<li><p>BeanFactory：什么使用什么时候创建对象</p>
</li>
</ul>
<p>通过BeanFactory创建的容器，其中的实例在被用到的时候才会创建</p>
<pre><code class="java">//通过BeanFactory创建容器
BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;xml/beans.xml&quot;));

//此行执行User类实例的初始化函数
User user = beanFactory.getBean(&quot;user&quot;, User.class);
</code></pre>
<h4 id="三层架构通过xml配置进行依赖注入"><a href="#三层架构通过xml配置进行依赖注入" class="headerlink" title="三层架构通过xml配置进行依赖注入"></a>三层架构通过xml配置进行依赖注入</h4><pre><code class="xml">&lt;!--注册表现层实例--&gt;
&lt;bean id=&quot;accountServlet&quot; class=&quot;com.os467.account.servlet.AccountServlet&quot;&gt;

    &lt;!--注入业务层的引用--&gt;
    &lt;property name=&quot;accountService&quot; ref=&quot;accountService&quot;&gt;&lt;/property&gt;

&lt;/bean&gt;

&lt;!--注册业务层引用--&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.os467.account.service.AccountServiceImpl&quot;&gt;

    &lt;!--注入持久层的引用--&gt;
    &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;

&lt;/bean&gt;

&lt;!--注册持久层引用--&gt;
&lt;bean id=&quot;accountDao&quot; class=&quot;com.os467.account.dao.AccountDaoImpl&quot;&gt;&lt;/bean&gt;
</code></pre>
<h4 id="模拟springIOC底层基于工厂模式解耦"><a href="#模拟springIOC底层基于工厂模式解耦" class="headerlink" title="模拟springIOC底层基于工厂模式解耦"></a>模拟springIOC底层基于工厂模式解耦</h4><p>首先程序会去读取配置文件，然后获取文件中的全类名数据，根据反射创建对象（单例的），保存在容器里面，后面如果有用到实例的地方，我们从容器中去获取</p>
<pre><code class="java">import java.io.FileReader;
import java.io.IOException;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

/**
 * 工厂类
 */
public class BeanFactory &#123;

    //模拟一个容器
    private static Map beansMap;

    private static Properties properties;

    //在静态代码块中去创建容器对象，为了保证存入容器中的实例是单例的，
    //所有的存放实例的步骤也要在类加载的时候去完成
    static &#123;

        //实例化容器
        beansMap = new HashMap();

        //实例化properties集合
        properties = new Properties();

        FileReader fileReader = null;

        try &#123;

            //创建流对象
            fileReader = new FileReader(&quot;src/beans&quot;);

            //读取数据到集合中
            properties.load(fileReader);

            //获取properties集合中所有的key
            Enumeration keys = properties.keys();

            //遍历所有的key
            while (keys.hasMoreElements())&#123;

                //先获取对应key的字符串
                String key = keys.nextElement().toString();

                //根据key来获取value
                String propertyClass = properties.getProperty(key);

                //根据反射机制创建对象
                Object value = Class.forName(propertyClass).newInstance();

                //将实例存到容器里
                beansMap.put(key,value);

            &#125;

        &#125; catch (Exception e) &#123;

            e.printStackTrace();

        &#125;finally &#123;

            try &#123;

                if (fileReader != null)&#123;

                    //关闭流对象
                    fileReader.close();

                &#125;

            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;


    &#125;


    /**
     * 定义一个获取实例的方法
     */
    public static Object getBean(String beanId)&#123;

        //从集合中获取实例
        return beansMap.get(beanId);

    &#125;

&#125;
</code></pre>
<p>   通过工厂获得业务层的实例</p>
<pre><code class="java">package com.os467.factory.servlet;

import com.os467.factory.BeanFactory2;
import com.os467.factory.service.AccountService;

public class AccountServlet &#123;

    //聚合业务层引用
    private AccountService accountService;

    public void saveAccount() &#123;

        accountService = (AccountService) BeanFactory2.getBean(&quot;accountService&quot;);

        accountService.saveAccount();

    &#125;

&#125;
</code></pre>
<h5 id="基于注解的IOC配置"><a href="#基于注解的IOC配置" class="headerlink" title="基于注解的IOC配置"></a>基于注解的IOC配置</h5><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>把资源让spring来管理，相当于在xml中配置一个bean</td>
</tr>
<tr>
<td>@Controller</td>
<td>一般用于表现层的注解</td>
</tr>
<tr>
<td>@Service</td>
<td>一般用于业务层的注解</td>
</tr>
<tr>
<td>@Repository</td>
<td>一般用于持久层的注解</td>
</tr>
</tbody></table>
<p>1、在<strong>配置文件</strong>中<strong>开启spring对注解的支持</strong></p>
<p>2、直接在类上加对应的注解即可</p>
<p>在使用注解的IOC配置前需要先导入<strong>springAOP的jar包</strong>（<strong>底层需要</strong>）</p>
<p><strong>配置文件约束</strong></p>
<p><strong>名称空间：xmlns:context</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

 

&lt;/beans&gt;
</code></pre>
<p>开启spring对注解的支持，其实就是一个扫描包的过程</p>
<p>spring程序在执行的时候会去解析配置文件的数据，然后找到对应的<strong>包结构</strong>，并且扫描该包下对应的子包，然后会去检查每一个类上面有没有spring提供的<strong>注解</strong>，如果有，会将该类的实例装载进spring核心容器中</p>
<p><strong>base-package</strong>：指定的包结构</p>
<pre><code class="xml">&lt;!--开启spring对注解的支持--&gt;
&lt;context:component-scan base-package=&quot;com.os467&quot;&gt;&lt;/context:component-scan&gt;
</code></pre>
<p>在取出实例的时候，要注意，<strong>默认的标识是类的类名（首字符要小写）</strong></p>
<pre><code class="java">//创建核心容器对象
ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;xml/beans02.xml&quot;);

//取出实例
Student student = applicationContext.getBean(&quot;student&quot;, Student.class);

System.out.println(student);
</code></pre>
<p>类注解中的value值代表该类在获取时需要提供的<strong>id</strong>，给Student类自定义的提供一个id值</p>
<pre><code class="java">@Component(&quot;sss&quot;)
public class Student &#123;

&#125;
</code></pre>
<p><strong>改变作用范围的注解</strong></p>
<p><code>@Scope</code> 指定bean 的作用范围</p>
<p>取值：</p>
<blockquote>
<p>singleton</p>
<p>prototype</p>
<p>request</p>
<p>session</p>
<p>globalession</p>
</blockquote>
<p><strong>生命周期相关</strong></p>
<p><code>@PostConstruct</code> 用于指定初始化的方法</p>
<p><code>@PreDestroy</code> 用于指定销毁的方法</p>
<pre><code class="java">public class Student &#123;

    @PostConstruct
    public void initMethod()&#123;

        System.out.println(&quot;初始化的方法执行了&quot;);

    &#125;

    @PreDestroy
    public void destroyMethod()&#123;

        System.out.println(&quot;销毁的方法执行了&quot;);

    &#125;

&#125;
</code></pre>
<h5 id="基于注解的方式注入属性的值"><a href="#基于注解的方式注入属性的值" class="headerlink" title="基于注解的方式注入属性的值"></a>基于注解的方式注入属性的值</h5><p><strong>用于注入数据的注解</strong></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>根据类型注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>按名称注入，不能单独使用</td>
</tr>
<tr>
<td>@Resource</td>
<td>根据id注入的</td>
</tr>
<tr>
<td>@Value</td>
<td>用于注入基本数据类型和String类型</td>
</tr>
</tbody></table>
<p><strong>@Autowired注解</strong></p>
<p>注入流程：首先spring在扫描到该属性上有Autowired注解之后，会去容器中找到该属性对应的类型与之注入</p>
<p>如果spring容器中与该属性类型匹配的实例有多个，那么究竟该注入哪个实例，这种情况下程序会报错</p>
<p>给这个类的<strong>实例起标识</strong>，起的标识一定要跟被注入属性的属性名称一致</p>
<p><strong>@Qualifier注解</strong></p>
<p>跟Autowired结合使用，指由Qualifier来决定究竟要注入哪个实例，需要提供注入实例的标识</p>
<p>Qualifier<strong>不能单独使用</strong>，只能和Autowried配合使用</p>
<p><strong>@Resource注解</strong></p>
<p>根据id去注入，相当于Autowired和Qualifier的结合</p>
<pre><code class="java">//指定id
@Resource(name = &quot;accountService&quot;)
</code></pre>
<p><strong>@Value注解</strong></p>
<p>给属性赋值，能赋值基本数据类型和String类型</p>
<pre><code class="java">@Value(&quot;jack&quot;)
String name;
</code></pre>
<h4 id="模拟springIoC底层基于注解的方式进行注入"><a href="#模拟springIoC底层基于注解的方式进行注入" class="headerlink" title="模拟springIoC底层基于注解的方式进行注入"></a>模拟springIoC底层基于注解的方式进行注入</h4><p>通过设计模式+反射机制来模拟</p>
<p>1、spring的配置文件：beans.xml（开启扫描包的过程）spring会去扫描该包下所有子包的类，为了检查有没有spring提供的注解</p>
<p>2、要在指定的类上加注解，如果spring检查到该类上有注解的话，就会将该类的实例通过反射机制创建出来，装进spring中</p>
<p>3、检查该类中的属性上有没有spring提供的注解，如果有的话，会通过反射的方式去注入实例</p>
<hr>
<p><strong>修饰持久层的注解</strong></p>
<pre><code class="java">package com.os467.ioc.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Repository &#123;
&#125;
</code></pre>
<p><strong>修饰业务层的注解</strong></p>
<pre><code class="java">package com.os467.ioc.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Service &#123;
&#125;
</code></pre>
<p><strong>修饰表现层的注解</strong></p>
<pre><code class="java">package com.os467.ioc.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;


@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Controller &#123;
&#125;
</code></pre>
<p><strong>根据属性类型注入属性实例的注解</strong></p>
<pre><code class="java">package com.os467.ioc.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoWired &#123;
&#125;
</code></pre>
<p><strong>工厂类，用于储存实例</strong></p>
<pre><code class="java">package com.os467.ioc.factory;

import java.util.HashMap;
import java.util.Map;

/**
 * 工厂类，用于存放组件的实例（相当于容器）
 */
public class BeanFactory &#123;

    //创建Map集合对象
    private static Map beansMap = new HashMap();

    public static Map getBeansMap() &#123;
        return beansMap;
    &#125;

    /**
     * 获取实例的方法
     */

    public static Object getBean(String beanId)&#123;

        return beansMap.get(beanId);

    &#125;

&#125;
</code></pre>
<p><strong>模拟spring底层基于注解Ioc解耦（扫描指定包结构下的类，创建所需要的实例）</strong></p>
<pre><code class="java">package com.os467.ioc.scan;

import com.os467.ioc.annotation.AutoWired;
import com.os467.ioc.annotation.Controller;
import com.os467.ioc.annotation.Repository;
import com.os467.ioc.annotation.Service;
import com.os467.ioc.factory.BeanFactory;

import java.io.File;
import java.io.FileFilter;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * 模拟spring底层基于注解的Ioc解耦
 */
public class ComponentScan &#123;

    //创建一个集合对象，用于存放全类名
    private static List&lt;String&gt; classNameList = new ArrayList();

    /**
     * 模拟装配实例，注入实例的过程
     * @param pathName
     */
    public static void getComponentScan(String pathName)&#123;

        //把&quot;.&quot;替换成&quot;/&quot;
        pathName = pathName.replace(&quot;.&quot;,&quot;/&quot;);

        //获取当前工程的绝对路径
        String path = ClassLoader.getSystemResource(&quot;&quot;).getPath() + pathName;

        //创建一个File对象
        File file = new File(path);

        //过滤指定路径下的文件
        addFiles(file);

        //遍历集合
        for (String className : classNameList) &#123;

            try &#123;

                //创建字节码对象
                Class aClass = Class.forName(className);

                //根据反射检测类上有没有自定义的注解
                Controller controller = (Controller)aClass.getAnnotation(Controller.class);
                Service service = (Service)aClass.getAnnotation(Service.class);
                Repository repository = (Repository)aClass.getAnnotation(Repository.class);

                //如果类上有以上任意一个注解，我们就把该类添加到容器里面
                if (controller != null || service != null || repository != null)&#123;

                    //根据反射创建实例
                    Object obj = aClass.newInstance();

                    //获取类的简类名
                    String simpleName = aClass.getSimpleName();

                    //将实例添加到工厂
                    BeanFactory.getBeansMap().put(simpleName,obj);

                &#125;


            &#125; catch (ClassNotFoundException e) &#123;
                e.printStackTrace();
            &#125; catch (IllegalAccessException e) &#123;
                e.printStackTrace();
            &#125; catch (InstantiationException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;

        //继续遍历集合，将需要注入的属性进行注入
        for (String className : classNameList) &#123;

            try &#123;

                //创建字节码对象
                Class aClass = Class.forName(className);

                //根据反射检测类上有没有自定义的注解
                Controller controller = (Controller) aClass.getAnnotation(Controller.class);
                Service service = (Service) aClass.getAnnotation(Service.class);
                Repository repository = (Repository) aClass.getAnnotation(Repository.class);

                //如果类上有以上任意一个注解，继续检查类中的属性有没有自定义的注解
                if (controller != null || service != null || repository != null) &#123;

                    //获取属性字节码对象
                    Field[] declaredFields = aClass.getDeclaredFields();

                    //遍历属性数组
                    for (Field declaredField : declaredFields) &#123;

                        //检查属性上有没有自定义的注解
                        AutoWired autoWired = declaredField.getAnnotation(AutoWired.class);

                        //如果这个注解不为空，就意味着该属性需要注入
                        if (autoWired != null)&#123;

                            //获取容器对象
                            Map beansMap = BeanFactory.getBeansMap();

                            //将容器对象转成set集合
                            Set&lt;Map.Entry&gt; entrySet = beansMap.entrySet();

                            //遍历set集合
                            for (Map.Entry entry : entrySet) &#123;

                                //获取每个实例实现的接口
                                Class[] interfaces = entry.getValue().getClass().getInterfaces();

                                // 遍历接口数组，因为AutoWired是根据类型注入的，我们要保证注入的实例跟聚合的属性是同一类型
                                for (Class anInterface : interfaces) &#123;

                                    if (anInterface == declaredField.getType())&#123;

                                        //打破封装
                                        declaredField.setAccessible(true);

                                        //给属性赋值
                                        declaredField.set(BeanFactory.getBean(aClass.getSimpleName()),entry.getValue());

                                    &#125;

                                &#125;

                            &#125;

                        &#125;

                    &#125;

                &#125;


            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;

        &#125;

    &#125;

    /**
     * 定义一个递归的方法，用于过滤符合条件的文件
     * file.listFiles():将所有的文件或者是文件夹切成一个数组
     * @param file
     */
    public static void addFiles(File file)&#123;

        //获取该文件夹下面所有的子文件夹，FileFilter接口实现类用于返回符合条件的文件
        File[] files = file.listFiles(new FileFilter() &#123;
            @Override
            public boolean accept(File pathname) &#123;

                //判断文件的类型
                if (pathname.isDirectory())&#123;

                    //继续调用递归的方法
                    addFiles(pathname);

                &#125;

                //我们过滤的文件一般是以.class结尾的
                return pathname.getPath().endsWith(&quot;.class&quot;);

            &#125;
        &#125;);

        //遍历文件的数组，将符合要求的文件路径切割成全类名的形式
        for (File f : files) &#123;

            String path = f.getPath();

            //将所有的&quot;\&quot;替换成&quot;.&quot;

            path = path.replace(&quot;\\&quot;,&quot;.&quot;);

            //将com前面的字符串删了
            path = path.substring(path.lastIndexOf(&quot;com&quot;),path.length());

            //将&quot;.class&quot;切割掉
            path = path.replace(&quot;.class&quot;,&quot;&quot;);

            //将切割好的全类名添加到集合里面
            classNameList.add(path);

        &#125;

    &#125;

&#125;
</code></pre>
<hr>
<h3 id="基于注解的方式来创建核心容器对象"><a href="#基于注解的方式来创建核心容器对象" class="headerlink" title="基于注解的方式来创建核心容器对象"></a>基于注解的方式来创建核心容器对象</h3><p>​	1、之前创建核心容器对象都是基于xml的，必须得有配置文件</p>
<p>​	2、spring5.0版本之后也是支持基于注解的方式创建核心容器对象，这样我们的程序就可以脱离xml配置文件</p>
<p><strong>sping5.0版本后新的注解</strong>：</p>
<p><strong>@Configuration</strong>  </p>
<p>声明当前的类是一个配置类，仅起到标识作用</p>
<p><strong>@ComponentScan</strong></p>
<p>传入一个指定的包结构路线，开启扫描包，如果被<code>@Component</code>或其它特定注解修饰的类就会被添加到核心容器中</p>
<p><strong>@Bean</strong></p>
<ul>
<li><p>更多操作类似于在xml中的bean标签，<strong>用于修饰方法</strong>，可以将修饰方法的返回值作为一份实例添加到spring容器中</p>
</li>
<li><p>可以给实例起别名，<strong>默认情况下标识名称是方法名</strong>，而且修饰方法的参数实例会去<strong>容器中去匹配</strong>，匹配的规则和<code>@Autowired</code>是一样的，都是根据<strong>类型</strong>去匹配的</p>
</li>
<li><p>如果在获取配置类中的实例时，有相同类型的方法，那么就会根据方法被<strong>Bean修饰的标识名</strong>称来匹配实例，或者用<code>@Qualifier</code>来修饰参数指定实例标识</p>
</li>
</ul>
<p><strong>注意</strong>：如果方法名称相同，即使用@Bean起了别名，有参的也会覆盖掉无参的</p>
<p><strong>配置类</strong></p>
<pre><code class="java">@Configuration
public class SpringConfig &#123;

    @Bean
    public User getUser(Student student)&#123;
        
        User user = new User();
        
        user.setStudent(student);

        return user;

    &#125;

    @Bean(&quot;student&quot;)
    public Student getStudent()&#123;

        return new Student();

    &#125;

&#125;
</code></pre>
<p><strong>测试类</strong></p>
<pre><code class="java">public static void main(String[] args) &#123;

    //创建核心容器对象
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class);

    //从容器中取实例
    Object obj = applicationContext.getBean(&quot;getUser&quot;);

    if (obj instanceof User)&#123;

        User user = (User)obj;


    &#125;

&#125;
</code></pre>
<p> <strong>@PropertySource</strong></p>
<p>引入配置文件，可以通过<code>@Value</code>注解读取数据</p>
<p><strong>classpath:</strong> 读取的配置文件资源需要放在<strong>src</strong>文件下，可以通过el表达式取到值</p>
<pre><code class="java">@Configuration
@PropertySource(&quot;classpath:jdbc&quot;)
public class JdbcConfig &#123;

    @Value(&quot;$&#123;name&#125;&quot;)
    private String name;

    @Value(&quot;$&#123;password&#125;&quot;)
    private String password;

    @Bean(&quot;user&quot;)
    public User getUser()&#123;

        User user = new User();

        user.setName(name);
        user.setPassword(password);

        return user;

    &#125;

&#125;
</code></pre>
<p><strong>配置文件jdbc</strong></p>
<pre><code class="properties">name=root
password=root
</code></pre>
<p><strong>@Import</strong></p>
<p>可以让两个核心配置类之间存在继承的关系</p>
<p>引入其它核心配置类，需要提供一个配置类的字节码属性</p>
<pre><code class="java">@Import(SpringConfig.class)
</code></pre>
<h1 id="★AOP"><a href="#★AOP" class="headerlink" title="★AOP"></a>★AOP</h1><h2 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h2><p>AOP：全称是 <strong>Aspect  Oriente  Programming</strong> </p>
<p>(面向切面编程)</p>
<p><strong>作用</strong>：</p>
<p>在程序运行期间，不修改源码对已有方法进行增强</p>
<p><strong>优势</strong>：</p>
<ul>
<li>减少重复代码</li>
<li>提高开发效率</li>
<li>维护方便</li>
</ul>
<p><strong>Joinpoint（连接点）：</strong></p>
<p>​		连接点是指那些被拦截到的点，在spring中，这些点指的是方法，因为spring只支持方法类型的连接点，指的就是动态代理在底层可以访问到的<strong>所有方法</strong></p>
<p><strong>Pointcut（切入点）：</strong></p>
<p>​		所谓切入点是指我们要对哪些Joinpoint进行拦截的定义，就是要对哪些连接点（方法）进行<strong>增强</strong>，即<strong>需要被增强的方法</strong></p>
<p><strong>Advice（通知&#x2F;增强）：</strong></p>
<p>所谓通知是指拦截到<strong>Joinpoint</strong>之后所要做的事情就是通知，通知的类型：</p>
<ul>
<li><p>前置通知：</p>
<ul>
<li>调用目标方法之前执行的内容</li>
</ul>
</li>
<li><p>后置通知：</p>
<ul>
<li>调用目标方法之后执行的内容</li>
</ul>
</li>
<li><p>异常通知：</p>
<ul>
<li>在catch语句块中织入的内容</li>
</ul>
</li>
<li><p>最终通知：</p>
<ul>
<li>在finally语句块中织入的内容</li>
</ul>
</li>
<li><p>环绕通知：</p>
<ul>
<li>整个invoke方法执行的过程叫做环绕通知</li>
</ul>
</li>
</ul>
<p><strong>Target（目标对象）：</strong></p>
<p>​		代理的目标对象</p>
<p><strong>Weaving（织入）：</strong></p>
<p>​		是指把增强应用到目标对象来创建新的代理对象的过程（增强的过程）</p>
<p>spring采用动态代理织入，而AspectJ采用编译器织入和类装载器织入</p>
<p><strong>Proxy（代理）：</strong></p>
<p>一个类被AOP织入增强后，就产生一个结果代理类</p>
<p><strong>Aspect（切面）：</strong></p>
<p>是切入点（要增强的方法）和通知（怎么增强）之间的关系</p>
<h2 id="JDK动态代理模拟AOP底层"><a href="#JDK动态代理模拟AOP底层" class="headerlink" title="JDK动态代理模拟AOP底层"></a>JDK动态代理模拟AOP底层</h2><p><strong>场景：</strong></p>
<p>​		之前学习jdbc的时候我们接触到了事务，A账户给B账户赚钱，我们需要加入事务的操作，要满足事务的一致性</p>
<p>如果用代理模式来完成对事务的织入，程序该如何去写？</p>
<p><strong>使用JDK动态代理来为目标类创建代理类</strong></p>
<pre><code class="java">package com.os467.proxy;

import com.os467.account.service.AccountService;
import com.os467.utils.TransactionMangerUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 为业务层做代理
 */
@Component
public class AccountProxy &#123;

    //目标对象，需要被代理的对象
    @Autowired
    private AccountService accountService;

    /**
     * 获取代理对象
     * @return
     */
    public Object getProxy()&#123;

        return Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), new InvocationHandler() &#123;

            /**
             * 完成对目标方法的增强
             *
             * 在springAop中：
             *
             * 前置通知：调用目标方法之前执行的内容
             * 后置通知：调用目标方法之后执行的内容
             * 异常通知：在catch语句块中织入的内容
             * 最终通知：在finally语句块中织入的内容
             * 环绕通知：整个invoke方法执行的过程叫做环绕通知
             *
             * @param proxy
             * @param method
             * @param args
             * @return
             * @throws Throwable
             */
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;

                Object invoke = null;

                try &#123;

                    if (method.getName().equals(&quot;transfer&quot;))&#123;

                        //开启事务
                        TransactionMangerUtils.beginTransaction();

                    &#125;

                    //调用目标类方法
                    invoke = method.invoke(accountService, args);

                    if (method.getName().equals(&quot;saveAccount&quot;))&#123;

                        //提交事务
                        TransactionMangerUtils.commitTransaction();

                    &#125;

                &#125;catch (Exception e)&#123;

                    //回滚事务
                    TransactionMangerUtils.rollBackTransaction();

                    //关闭事务
                    TransactionMangerUtils.closeTransaction();

                    e.printStackTrace();
                &#125;finally &#123;

                    if (method.getName().equals(&quot;saveAccount&quot;))&#123;

                        //关闭事务
                        TransactionMangerUtils.closeTransaction();

                    &#125;

                &#125;

                return invoke;

            &#125;
        &#125;);

    &#125;
&#125;
</code></pre>
<p><strong>测试类</strong></p>
<pre><code class="java">public class AopTest01 &#123;

    private static ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class);


    public static void main(String[] args) &#123;

        //从容器中取出代理对象
        AccountProxy accountProxy = applicationContext.getBean(&quot;accountProxy&quot;, AccountProxy.class);

        AccountService proxy = (AccountService)accountProxy.getProxy();

        proxy.transfer();
        proxy.saveAccount();

    &#125;

&#125;
</code></pre>
<h3 id="基于XML的AOP配置"><a href="#基于XML的AOP配置" class="headerlink" title="基于XML的AOP配置"></a>基于XML的AOP配置</h3><p>通过xml来配置aop（切面）：我们配置的是切入点和通知之间的关系</p>
<p>​		我们想在项目中去加入收集日志的功能，但是不能在核心模块中出现，会通过aop配置切面的方式来完成对核心模块中核心方法的增强</p>
<p><strong>引入约束</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    
&lt;/beans&gt;
</code></pre>
<p><strong>标签</strong>：</p>
<p><strong>aop:config：</strong></p>
<p>作用：用于声明开始aop的配置</p>
<p><strong>aop:aspect：</strong></p>
<p>作用：配置切面</p>
<p><strong>aop:pointcut：</strong></p>
<p>作用：配置切入点表达式</p>
<pre><code class="xml">&lt;aop:before method=&quot;beforeAdvice&quot; pointcut=&quot;execution(* com.os467.aop.method.AopMethod.*(..))&quot;&gt;&lt;/aop:before&gt;
</code></pre>
<blockquote>
<p> 第一个*标识当前工程，后面是资源路径，类.*标识该类下的所有方法，（..）代表匹配所有无参，(String,int)表示匹配指定参数的方法</p>
</blockquote>
<p><strong>aop:before：</strong></p>
<p>作用：用于配置前置通知</p>
<p><strong>aop:after-returning：</strong></p>
<p>作用：用于配置后置通知</p>
<hr>
<p><strong>配置切面</strong></p>
<pre><code class="xml">&lt;!--配置一个目标类的实例--&gt;
&lt;bean id=&quot;aopMethod&quot; class=&quot;com.os467.aop.method.AopMethod&quot;&gt;&lt;/bean&gt;

&lt;!--配置通知类的实例--&gt;
&lt;bean id=&quot;aopLogger&quot; class=&quot;com.os467.aop.logger.Logger&quot;&gt;&lt;/bean&gt;

&lt;!--开始配置Aop--&gt;
&lt;aop:config&gt;

    &lt;!--
        配置切面:

        要去引入一个通知类

    --&gt;
    &lt;aop:aspect id=&quot;idAspect&quot; ref=&quot;aopLogger&quot;&gt;

        &lt;!--
            开始配置通知：
            pointcut：配置切入点表达式，就是要设置通知的作用范围
        --&gt;

        &lt;!--配置前置通知--&gt;
        &lt;aop:before method=&quot;beforeAdvice&quot; pointcut=&quot;execution(* com.os467.aop.method.AopMethod.*(..))&quot;&gt;&lt;/aop:before&gt;

        &lt;!--配置后置通知--&gt;
        &lt;aop:after-returning method=&quot;afterAdvice&quot; pointcut=&quot;execution(* com.os467.aop.method.AopMethod.*(..))&quot;&gt;&lt;/aop:after-returning&gt;

        &lt;!--配置异常通知--&gt;
        &lt;aop:after-throwing method=&quot;exceptionAdvice&quot; pointcut=&quot;execution(* com.os467.aop.method.AopMethod.*(..))&quot;&gt;&lt;/aop:after-throwing&gt;

        &lt;!--最终通知--&gt;
        &lt;aop:after method=&quot;endAdvice&quot; pointcut=&quot;execution(* com.os467.aop.method.AopMethod.*(..))&quot;&gt;&lt;/aop:after&gt;

    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;
</code></pre>
<p><strong>外部声明切入点表达式</strong></p>
<pre><code class="xml">&lt;!--声明一个切入点表达式--&gt;
&lt;aop:pointcut id=&quot;pt01&quot; expression=&quot;execution(* com.os467.aop.method.AopMethod.*(..))&quot;/&gt;

&lt;!--配置前置通知--&gt;
&lt;aop:before method=&quot;beforeAdvice&quot; pointcut-ref=&quot;pt01&quot;&gt;&lt;/aop:before&gt;

&lt;!--配置后置通知--&gt;
&lt;aop:after-returning method=&quot;afterAdvice&quot; pointcut-ref=&quot;pt01&quot;&gt;&lt;/aop:after-returning&gt;
</code></pre>
<p><strong>通知类</strong></p>
<pre><code class="java">package com.os467.aop.logger;

/**
 * 日志管理类（通知类）
 */
public class Logger &#123;

    /**
     * 前置通知
     */
    public void beforeAdvice()&#123;

        System.out.println(&quot;前置通知开始记录日志了&quot;);

    &#125;

    /**
     * 后置通知
     */
    public void afterAdvice()&#123;

        System.out.println(&quot;后置通知开始记录日志了&quot;);

    &#125;

    /**
     * 异常通知
     */
    public void exceptionAdvice()&#123;

        System.out.println(&quot;异常通知开始记录日志了&quot;);

    &#125;

    /**
     * 最终通知
     */
    public void endAdvice()&#123;

        System.out.println(&quot;最终通知开始记录日志了&quot;);

    &#125;

&#125;
</code></pre>
<p><strong>需要被增强的核心类</strong></p>
<pre><code class="java">package com.os467.aop.method;

/**
 * 需要加入收集日志功能的核心类
 */
public class AopMethod &#123;

    public void getMethod01()&#123;

        System.out.println(&quot;getMethod01方法正在执行&quot;);

    &#125;

    public void getMethod02()&#123;

        System.out.println(&quot;getMethod02方法正在执行&quot;);

    &#125;

    public void getMethod03()&#123;

        System.out.println(&quot;getMethod03方法正在执行&quot;);

    &#125;

&#125;
</code></pre>
<p><strong>测试类</strong></p>
<pre><code class="java">public class AopTest &#123;

    public static void main(String[] args) &#123;

        //从容器中把目标类的实例取出来
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;xml/beans.xml&quot;);

        //取出实例
        AopMethod aopMethod = applicationContext.getBean(&quot;aopMethod&quot;, AopMethod.class);

        //调用需要增强的方法
        aopMethod.getMethod01();

    &#125;


&#125;
</code></pre>
<hr>
<h3 id="基于注解的AOP配置"><a href="#基于注解的AOP配置" class="headerlink" title="基于注解的AOP配置"></a>基于注解的AOP配置</h3><p><strong>开启AOP对注解的支持</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--开启spring的扫描包--&gt;
    &lt;context:component-scan base-package=&quot;com.os467&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!--开启AOP对注解支持--&gt;
    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
    
    
&lt;/beans&gt;
</code></pre>
<p><strong>@Aspect</strong></p>
<p>声明当前的类是一个切面类</p>
<p><strong>@Pointcut</strong></p>
<p>修饰一个方法，注解中的值为<strong>切入点表达式</strong></p>
<p><strong>@Before</strong></p>
<p>前置通知</p>
<p><strong>@AfterReturning</strong></p>
<p>后置通知</p>
<p><strong>@AfterThrowing</strong></p>
<p>异常通知</p>
<p><strong>@After</strong></p>
<p>最终通知</p>
<p><strong>通过注解配置通知类</strong></p>
<pre><code class="java">/**
 * 日志管理类（通知类）
 */
@Component(&quot;logger&quot;)
@Aspect
public class Logger &#123;

    /**
     * 声明一个切入点表达式
     */
    @Pointcut(&quot;execution(* com.os467.aop.method.AopMethod.*(..))&quot;)
    public void pt01()&#123;&#125;;

    /**
     * 前置通知
     */
    @Before(&quot;pt01()&quot;)
    public void beforeAdvice()&#123;

        System.out.println(&quot;前置通知开始记录日志了&quot;);

    &#125;

    /**
     * 后置通知
     */
    @AfterReturning(&quot;pt01()&quot;)
    public void afterAdvice()&#123;

        System.out.println(&quot;后置通知开始记录日志了&quot;);

    &#125;

    /**
     * 异常通知
     */
    @AfterThrowing(&quot;pt01()&quot;)
    public void exceptionAdvice()&#123;

        System.out.println(&quot;异常通知开始记录日志了&quot;);

    &#125;

    /**
     * 最终通知
     */
    @After(&quot;pt01()&quot;)
    public void endAdvice()&#123;

        System.out.println(&quot;最终通知开始记录日志了&quot;);

    &#125;

&#125;
</code></pre>
<p><strong>测试类</strong></p>
<pre><code class="java">public class AopTest02 &#123;

    public static void main(String[] args) &#123;

        ApplicationContext applicationContext = new  ClassPathXmlApplicationContext(&quot;xml/beans02.xml&quot;);

        AopMethod aopMethod = applicationContext.getBean(&quot;aopMethod&quot;, AopMethod.class);

        aopMethod.getMethod01();

    &#125;
    
&#125;
</code></pre>
<p><strong>环绕通知</strong></p>
<p>在配置环绕通知的时候可以不去配置前置，后置，异常，结束这些通知，因为可以在环绕通知中定义这些通知</p>
<p><strong>xml配置环绕通知</strong></p>
<pre><code class="xml">&lt;!--配置环绕通知--&gt;
&lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;pt01&quot;&gt;&lt;/aop:around&gt;
</code></pre>
<p><strong>注解配置环绕通知</strong></p>
<pre><code class="java">@Around(&quot;pt01()&quot;)
public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint)&#123;环绕通知具体内容&#125;
</code></pre>
<p><strong>增强方法内容</strong></p>
<pre><code class="java">/**
 * 环绕通知，需要给它一个接口参数，spring会自动提供实例
 */
public void aroundAdvice(ProceedingJoinPoint proceedingJoinPoint)&#123;

    //获取调用目标方法时所对应的参数
    Object[] args = proceedingJoinPoint.getArgs();

    //调用目标方法
    try &#123;

        System.out.println(&quot;前置通知&quot;);

        //类似于invoke方法
        proceedingJoinPoint.proceed(args);

        System.out.println(&quot;后置通知&quot;);

    &#125; catch (Throwable throwable) &#123;

        System.out.println(&quot;异常通知&quot;);

        throwable.printStackTrace();
    &#125;finally &#123;

        System.out.println(&quot;结束通知&quot;);

    &#125;


&#125;
</code></pre>
<h1 id="单元测试junit"><a href="#单元测试junit" class="headerlink" title="单元测试junit"></a>单元测试junit</h1><p>单元测试在底层是封装了main函数的，在不写主函数的情况下，可以去让程序跑起来</p>
<p>通过spring来集成单元测试（可以在不创建核心容器的情况下，取到容器中的实例）</p>
<p><strong>@Test</strong></p>
<p>在方法上加上Test注解，该方法就会变成像主函数一样<strong>可以运行</strong></p>
<pre><code class="java">@Test
public void test01()&#123;

    System.out.println(&quot;成功运行了该方法&quot;);

&#125;
</code></pre>
<p>在程序运行的时候<strong>动态</strong>的<strong>获取核心容器对象</strong></p>
<p>@<strong>RunWith</strong></p>
<p>这个注解可以替换运行器，我们选用spring提供的运行器</p>
<p><strong>@ContextConfiguration</strong></p>
<p>指定如何创建核心容器对象，需要提供xml路径或者是配置类class</p>
<pre><code class="java">/**
 * @RunWith 这个注解可以替换运行器
 * SpringJUnit4ClassRunner 这个类实现了运行器接口，可以在spring程序运行的时候获取核心容器对象
 * @ContextConfiguration 以什么方式创建核心容器对象（xml/注解）
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &quot;classpath:xml/beans.xml&quot;)
public class JunitTest01 &#123;

    @Autowired
    private ApplicationContext applicationContext;

    @Test
    public void test01()&#123;

        //取出实例
        AccountServiceImpl service = applicationContext.getBean(&quot;service&quot;, AccountServiceImpl.class);

        service.saveAccount();
        
    &#125;
    
&#125;
</code></pre>
<p><strong>基于核心配置类创建容器（注解注册）</strong></p>
<pre><code class="java">@ContextConfiguration(classes = SpringConfig.class)
</code></pre>
<h3 id="jdbcTemplate模板对象"><a href="#jdbcTemplate模板对象" class="headerlink" title="jdbcTemplate模板对象"></a>jdbcTemplate模板对象</h3><p>jdbcTemplate对JDBC做了封装，相当于是一个工具类</p>
<pre><code class="java">//创建jdbcTemplate模板对象
JdbcTemplate jdbcTemplate = new JdbcTemplate();

//创建数据源的示例
DriverManagerDataSource driverManagerDataSource = new DriverManagerDataSource();

//设置连接地址
driverManagerDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/web_test?serverTimezone=GMT&amp;characterEncoding=utf-8&quot;);

//设置驱动全类名
driverManagerDataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);

//设置用户名
driverManagerDataSource.setUsername(&quot;root&quot;);

//设置密码
driverManagerDataSource.setPassword(&quot;root&quot;);

//给模板对象注入数据源的实例
jdbcTemplate.setDataSource(driverManagerDataSource);

//执行一个添加的功能
int num = jdbcTemplate.update(&quot;insert into tb_user(username,password)values(&#39;tom&#39;,&#39;10010011&#39;)&quot;);

System.out.println(num == 1 ?&quot;添加成功&quot;:&quot;添加失败&quot;);
</code></pre>
<h5 id="xml中的特殊符号"><a href="#xml中的特殊符号" class="headerlink" title="xml中的特殊符号"></a>xml中的特殊符号</h5><table>
<thead>
<tr>
<th>表达式</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;lt;</td>
<td>&lt;</td>
</tr>
<tr>
<td>&amp;gt;</td>
<td>&gt;</td>
</tr>
<tr>
<td>&amp;amp;</td>
<td>&amp;</td>
</tr>
<tr>
<td>&amp;apos;</td>
<td>&amp;apos;</td>
</tr>
<tr>
<td>&amp;quot;</td>
<td>&quot;</td>
</tr>
</tbody></table>
<p>通过xml配置注入<strong>jdbcTemplate</strong>模板实例</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--开启对注解的支持--&gt;
    &lt;context:component-scan base-package=&quot;com.os467&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!--配置一个jdbcTemplate实例--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;

        &lt;!--注入数据源的实例--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;

    &lt;/bean&gt;

    &lt;!--注入一个数据源的实例--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;

        &lt;!--注入源数据--&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/web_test?serverTimezone=GMT&amp;amp;characterEncoding=utf-8&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;

    &lt;/bean&gt;



&lt;/beans&gt;
</code></pre>
<p><strong>junit测试类</strong></p>
<pre><code class="java">package com.os467.test;

import com.os467.account.service.AccountService;
import com.os467.account.service.AccountServiceImpl;
import com.os467.beans.User;
import com.os467.config.SpringConfig;
import com.os467.user_test.service.UserService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.util.List;

/**
 * @RunWith 这个注解可以替换运行器
 * SpringJUnit4ClassRunner 这个类实现了运行器接口，可以在spring程序运行的时候获取核心容器对象
 * @ContextConfiguration 以什么方式创建核心容器对象（xml/注解）
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &quot;classpath:xml/beans.xml&quot;)
public class JunitTest01 &#123;

    @Autowired
    private AccountService accountService;

    @Autowired
    private UserService userService;

    @Test
    public void test01()&#123;

        accountService.saveAccount();

    &#125;

    /**
     * 通过jdbcTemplate模板连接数据库
     */
    @Test
    /**
     * 测试添加的功能
     */
    public void test02()&#123;

        int i = userService.addUser();

        System.out.println(i == 1 ?&quot;添加成功&quot;:&quot;添加失败&quot;);

    &#125;

    /**
     * 测试删除功能
     */
    @Test
    public void test03()&#123;

        int i = userService.deleteUserById();

        System.out.println(i == 1 ?&quot;删除成功&quot;:&quot;删除失败&quot;);

    &#125;

    /**
     * 测试修改功能
     */
    @Test
    public void test04()&#123;

        int i = userService.updateUserById();

        System.out.println(i == 1 ?&quot;修改成功&quot;:&quot;修改失败&quot;);

    &#125;

    /**
     * 测试查询的功能
     */
    @Test
    public void test05()&#123;

        List&lt;User&gt; userList = userService.findAllByUsers();

        for (User user : userList) &#123;

            System.out.println(user);

        &#125;

    &#125;

&#125;
</code></pre>
<p><strong>持久层</strong></p>
<pre><code class="java">package com.os467.user_test.dao;

import com.os467.beans.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

@Repository
public class UserDaoImpl implements UserDao &#123;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public List&lt;User&gt; findAllByUsers() &#123;
        return jdbcTemplate.query(&quot;select * from tb_user&quot;, new RowMapper&lt;User&gt;() &#123;
            @Override
            public User mapRow(ResultSet resultSet, int i) throws SQLException &#123;

                int id = resultSet.getInt(&quot;id&quot;);

                String username = resultSet.getString(&quot;username&quot;);

                String password = resultSet.getString(&quot;password&quot;);

                //对java对象的封装，创建User实例
                User user = new User(id, username, password);

                return user;
            &#125;
        &#125;);
    &#125;

    @Override
    public int deleteUserById() &#123;
        return  jdbcTemplate.update(&quot;delete from tb_user where id = 7&quot;);
    &#125;

    /**
     * 修改
     * @return
     */
    @Override
    public int updateUserById() &#123;
        return jdbcTemplate.update(&quot;update tb_user set username = ?,password = ? where id = ?&quot;,&quot;tom&quot;,&quot;123&quot;,6);
    &#125;

    @Override
    public int addUser() &#123;

        return jdbcTemplate.update(&quot;insert into tb_user(username,password)values(&#39;tom&#39;,&#39;111&#39;)&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="Spring中的事务控制"><a href="#Spring中的事务控制" class="headerlink" title="Spring中的事务控制"></a>Spring中的事务控制</h1><ul>
<li><p>JavaEE 体系进行分层开发，事务处理位于<strong>业务层</strong>，Spring提供了分层设计业务层的事务处理解决方案</p>
</li>
<li><p>spring框架为我们提供了一组事务控制的接口，具体在后面的第二小节介绍，这组接口是在<strong>spring-tx-5.0.2.RELEASE.jar</strong>中</p>
</li>
<li><p>spring的事务控制都是基于AOP的，它既可以使用编程的方式实现，也可以使用配置的方式实现，我们学习的重点是<strong>使用配置</strong>的方式实现</p>
</li>
</ul>
<h3 id="PlatformTransactionManager接口"><a href="#PlatformTransactionManager接口" class="headerlink" title="PlatformTransactionManager接口"></a>PlatformTransactionManager接口</h3><p>此接口是spring的事务管理器，它里面提供了我们常用的操作事务的方法</p>
<p>管理事务的子类对象：</p>
<p>1**.DataSourceTransactionManager<strong>使用</strong>SpringJDBC<strong>或</strong>iBatis**进行持久化数据时使用</p>
<p>2.<strong>HibernateTransactionManager</strong>使用<strong>Hibernate</strong>版本进行持久化数据时使用</p>
<h2 id="基于XML的声明式事务控制"><a href="#基于XML的声明式事务控制" class="headerlink" title="基于XML的声明式事务控制"></a>基于XML的声明式事务控制</h2><p><strong>配置步骤</strong>：</p>
<p>​		1、配置事务管理器</p>
<p>​		2、配置事务的通知引用事务管理器</p>
<p>​		3、配置事务的属性</p>
<p>​		4、配置AOP切入点表达式</p>
<p>​		5、配置切入点表达式和事务通知的对应关系</p>
<p>引入<strong>xmlns:tx</strong>相关约束</p>
<pre><code class="xml">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd 

&lt;!--配置一个事务管理器--&gt;
    &lt;bean class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        
        &lt;!--注入数据源实例--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
        
    &lt;/bean&gt;
</code></pre>
<p>场景：银行转账的场景</p>
<h3 id="TransactionDefinition事务属性"><a href="#TransactionDefinition事务属性" class="headerlink" title="TransactionDefinition事务属性"></a>TransactionDefinition事务属性</h3><p><strong>isolation</strong>：</p>
<p>​	获取事务的隔离级别</p>
<p>​	默认值是DEFAULT，数据库级别的</p>
<p> <strong>propagation</strong>：</p>
<p>​	获取事务的传播行为，表示是否开启事务，以什么样的策略开启 </p>
<p>​	REQUIRED表示一定会开启事务，无论是增删改查都会开启</p>
<p>​	SUPPORTS表示有事务就会开启事务，没有事务就不会开启，会在增删改	的场景下开启事务，查询场景不会开启</p>
<p><strong>timeout</strong>：</p>
<p>​	获取超时时间，默认值是-1，永不超时，如果是正数的话，可以以秒为单	位设置超时时间</p>
<p><strong>read-only</strong>：</p>
<p>​	会影响事务<strong>是否开启</strong></p>
<p>​	获取是否是只读事务（true&#x2F;false），默认值是false，在查询的业务场景下，会把该属性设置成true</p>
<p>rollback-for：</p>
<p>是否开启回滚，默认值是true 自定义一个异常，除了该异常回滚，所有异常都不回滚<br>no-rollback-for：</p>
<p>自定义一个异常，除了该异常不回滚，所有异常都回滚</p>
<p><strong>默认情况下，所有异常都回滚</strong></p>
<p>只有在增删改的业务场景下，才会取开启事务，查询业务场景下不用开启事务，或者是只读就行</p>
<p><strong>注意</strong>：spring中单个事务的生命周期只发生在在一个方法中（需要被AOP增强的每个方法）</p>
<p><strong>如何配置事务管理器</strong></p>
<pre><code class="xml">&lt;!--配置一个事务管理器--&gt;
&lt;bean id=&quot;dataSourceManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;

    &lt;!--注入数据源实例--&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;

&lt;/bean&gt;
</code></pre>
<p><strong>如何配置事务的通知</strong></p>
<pre><code class="xml">&lt;!--配置一个事务的通知--&gt;
&lt;tx:advice transaction-manager=&quot;dataSourceManager&quot;&gt;

    &lt;!--配置事务的属性--&gt;
    &lt;tx:attributes&gt;

        &lt;!--
            &lt;tx:method name=&quot;&quot;/&gt;
            name属性：用于匹配需要织入事务的方法
            设置匹配规则，匹配方法名称，*代表通配符
            isolation：事务的隔离级别
        --&gt;

        &lt;tx:method name=&quot;update*&quot; isolation=&quot;DEFAULT&quot; /&gt;

    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<p><strong>完整的spring事务织入xml配置</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--开启对注解的支持--&gt;
    &lt;context:component-scan base-package=&quot;com.os467&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!--配置一个jdbcTemplate实例--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;

        &lt;!--注入数据源的实例--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;

    &lt;/bean&gt;

    &lt;!--注入一个数据源的实例--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;

        &lt;!--注入源数据--&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/web_test?serverTimezone=GMT&amp;amp;characterEncoding=utf-8&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;

    &lt;/bean&gt;
    
&lt;/beans&gt;
</code></pre>
<h2 id="基于注解的声明式事务控制"><a href="#基于注解的声明式事务控制" class="headerlink" title="基于注解的声明式事务控制"></a>基于注解的声明式事务控制</h2><p><strong>配置步骤</strong>：</p>
<p>​	1、配置事务管理器并注入数据源</p>
<p>​	2、在业务层使用@Transactional注解</p>
<p>​	3、在配置文件中开启spring对注解事务的支持</p>
<p><strong>@Transactional</strong></p>
<p><strong>事务注解</strong>，可以修饰类，也可以修饰方法</p>
<p>修饰类：该类下所有的方法都会加入事务的支持</p>
<p>修饰方法：只有指定方法会加入事务支持，方法的优先级比类要高</p>
<p><strong>注意</strong>：使用注解，事务管理器还需要在xml中配置，但是事务通知可以不用配置了</p>
<pre><code class="java">package com.os467.account.service;
import com.os467.account.dao.AccountDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@Transactional(propagation = Propagation.REQUIRED)
public class AccountServiceImpl implements AccountService &#123;

    @Autowired
    private AccountDao accountDao;

    @Override
    public void saveAccount() &#123;

        accountDao.savAccount();

    &#125;
&#125;
</code></pre>
<h1 id="★MVC"><a href="#★MVC" class="headerlink" title="★MVC"></a>★MVC</h1><p><strong>什么是MVC？</strong></p>
<ul>
<li><p>MVC是模型（Model）、视图（View）、控制器（Controller）的简写，是一种软件设计规范</p>
</li>
<li><p>是将业务逻辑、数据、显示分离的方法来组织代码</p>
</li>
<li><p>MVC主要作用是<strong>降低了视图与业务逻辑间的双向耦合</strong></p>
</li>
<li><p>MVC不是一种设计模式，<strong>MVC是一种架构模式</strong>，不同的MVC存在差异</p>
</li>
</ul>
<p>Model（模型）：数据模型，<strong>提供前端要展示的数据</strong>，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao）和服务层（行为Service），也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务</p>
<p>View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西</p>
<p>Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示，也就是说控制器做了个调度员的工作</p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架</p>
<p>Spring MVC的特点：</p>
<p>​	1、轻量级，简单易学</p>
<p>​	2、高效，基于请求响应的MVC框架</p>
<p>​	3、与Spring兼容性好，无缝结合</p>
<p>​	4、约定优于配置</p>
<p>​	5、功能强大：RESTful、数据验证、格式化、本地化、主题化等</p>
<p>​	6、、简洁灵活</p>
<p>最开始我们在处理请求和响应是基于servlet的，那servlet是一个规范，不属于框架，springMVC是一个表现层的框架，在底层封装了servlet</p>
<h3 id="springMVC核心原理"><a href="#springMVC核心原理" class="headerlink" title="springMVC核心原理"></a>springMVC核心原理</h3><ol>
<li>用户发送请求给服务器，url：user.do</li>
<li>服务器收到请求，发现DispatcherServlet可以处理，于是调用DispatcherServlet</li>
<li>DispatcherServlet内部，通过HandlerMappings（处理映射器）检查这个url有没有对应的Controller，如果有，则通HandlerAdapters（处理适配器）调用Controller</li>
<li>Controller开始执行</li>
<li>Controller执行完毕后，如果返回字符串，则ViewResolvers将字符串转化成相应的视图对象，如果返回ModelAndView对象，该对象本身就包含了视图对象信息</li>
<li>DispatcherServlet通过ViewResolvers（视图解析器）将视图对象中的数据输出给服务器</li>
<li>服务器将数据输出给客户端</li>
</ol>
<p><strong>springMVC整体调度流程</strong></p>
<ul>
<li>客户端发送请求给服务端，springMVC框架会通过DispatcherServlet来做一个资源的拦截（<a target="_blank" rel="noopener" href="http://localhost:8080/servlet/test%EF%BC%89">http://localhost:8080/servlet/test）</a></li>
<li>DispatcherServlet会调用处理映射器HandlerMappings来完成对地址的解析，然后把解析的信息告诉DispacherServlet</li>
<li>DispacherServlet调用处理适配器HandlerAdapters从容器中找到对应的资源（会找到controller1对应的资源）</li>
<li>HandlerAdapters找到对应资源之后，会去执行具体的Controller（然后会去封装数据，设置视图名称）</li>
<li>执行完逻辑之后会将视图和模块（ModelAndView）返回给DispacherServlet</li>
<li>继续调用视图解析器ViewResolvers视图解析器来解析ModelAndView里面视图名称，然后根据视图解析器内部的匹配规则来定位到具体的前端资源（jsp）</li>
<li>ViewResolvers在解析完之后会将解析的信息告诉DispacherServlet，然后会去做具体的页面跳转，数据渲染等工作</li>
</ul>
<h3 id="配置springMVC"><a href="#配置springMVC" class="headerlink" title="配置springMVC"></a>配置springMVC</h3><p><strong>springMVC框架如何去使用，如何去配置？</strong></p>
<p>使用控制器</p>
<p>创建一个TestController类，实现Controller接口</p>
<pre><code class="java">package com.os467.controller;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class TestController implements Controller &#123;

    @Override
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;

        //创建一个模型视图对象
        ModelAndView modelAndView = new ModelAndView();

        //封装数据
        modelAndView.addObject(&quot;name&quot;,&quot;Hello spring MVC&quot;);

        //设置视图名称
        modelAndView.setViewName(&quot;test02&quot;);

        return modelAndView;

    &#125;

&#125;
</code></pre>
<p><strong>我们在定义了一个Controller之后如何通过mvc去访问这个资源？</strong></p>
<p><strong>1、在web.xml中配置DispatcherServlet：mvc框架前端总调度器</strong></p>
<p>具体会去完成web交互时的各自调度工作</p>
<ul>
<li>Spring的web框架围绕<strong>DispatcherServlet</strong>调度Servlet设计</li>
<li>DispatcherServlet的作用是将请求分发到不同的处理器，从Spring2.5开始，使用Java5或者以上版本的用户可以采用基于注解形式进行开发</li>
</ul>
<p>在<strong>web.xml</strong>中配置前端总调度器，所有的访问请求都会进入此资源</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    
   &lt;!--配置前端总调度器--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
        
        &lt;!--拦截所有的客户端的请求--&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<p><strong>2、由于MVC框架属于spring的功能模块，所以必须得有核心容器的支持，要去创建spring配置文件springMVC.xml</strong></p>
<p>创建<strong>springMVC.xml</strong>配置文件，引入springMVC的xml约束</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    
&lt;/beans&gt;
</code></pre>
<p>在<strong>web.xml</strong>中注册配置文件位置，核心容器对象可以交给DispacherServlet去创建，需要指定配置文件的位置，以及设置启动级别</p>
<pre><code class="xml">&lt;!--配置前端总调度器--&gt;
 &lt;servlet&gt;
     &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
     &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;

     &lt;!--绑定springMVC的配置文件--&gt;
     &lt;init-param&gt;
         &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
         &lt;!--配置文件的路径--&gt;
         &lt;param-value&gt;classpath:xml/springMVC.xml&lt;/param-value&gt;
     &lt;/init-param&gt;

     &lt;!--设置启动级别，需要在tomcat服务器启动的时候就去加载核心容器对象--&gt;
     &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;

 &lt;/servlet&gt;
</code></pre>
<p>继续配置<strong>springMVC.xml</strong>，注册controller组件，视图解析器实例</p>
<pre><code class="xml">&lt;!--注册controller组件--&gt;
&lt;bean id=&quot;/controller1&quot; class=&quot;com.os467.controller.TestController&quot;&gt;&lt;/bean&gt;

&lt;!--处理映射器和适配器可以不做注册，这里仅作演示--&gt;
&lt;!--注册一个处理映射器--&gt;
&lt;bean id=&quot;handlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;&lt;/bean&gt;

&lt;!--注册一个处理适配器--&gt;
&lt;bean id=&quot;handlerAdapter&quot; class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;&lt;/bean&gt;

&lt;!--必须要配置视图解析器--&gt;
&lt;!--注册一个视图解析器--&gt;
&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;

    &lt;!--设置视图的前缀--&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/jsp/&quot;&gt;&lt;/property&gt;

    &lt;!--设置视图的后缀--&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;

&lt;/bean&gt;
</code></pre>
<h2 id="SpringMVC基于注解"><a href="#SpringMVC基于注解" class="headerlink" title="SpringMVC基于注解"></a>SpringMVC基于注解</h2><p>&lt;mvc:default-servlet-handler&#x2F;&gt;</p>
<p>让SpringMVC不处理静态资源</p>
<p>&lt;mvc:annotation-driven&#x2F;&gt;</p>
<p>支持mvc注解驱动</p>
<p>InternalResourceViewResolver</p>
<p>视图解析器</p>
<p><strong>配置xml，开启对注解的支持</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!--开启扫描包--&gt;
    &lt;context:component-scan base-package=&quot;com.os467&quot;&gt;&lt;/context:component-scan&gt;

    &lt;!--过滤静态资源--&gt;
    &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;

    &lt;!--支持mvc注解的驱动--&gt;
    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;

    &lt;!--配置视图解析器--&gt;
    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;

        &lt;!--设置前缀--&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt;

        &lt;!--设置后缀--&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;

    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p><strong>@Controller注解</strong></p>
<p>这个注解如果只是在spring框架中使用的话，就是将当前类的实例存到容器中<br>但是如果在springMVC中去使用，它不仅可以存实例到容器，还能够将该类下任意一个方法的<strong>返回值是String</strong><br>的方法，返回值会作为视图名称，用于视图跳转</p>
<p><strong>@RequestMapping注解</strong></p>
<p>用于地址的映射，可以修饰类也可以修饰方法，也可以只在方法上使用，能够体现层级关系</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;user&quot;)
public class UserController &#123;

    @RequestMapping(&quot;test&quot;)
    public String getTest()&#123;

        return &quot;test&quot;;

    &#125;

&#125;
</code></pre>
<p>此时在前端访问：<a target="_blank" rel="noopener" href="http://localhost:8080/springMVC/user/test">http://localhost:8080/springMVC/user/test</a> 测试资源</p>
<p><strong>@ResponseBody注解</strong> </p>
<p>让当前视图失效，并且会直接返回数据</p>
<h4 id="springMVC如何去接收前端传递过来的值"><a href="#springMVC如何去接收前端传递过来的值" class="headerlink" title="springMVC如何去接收前端传递过来的值"></a>springMVC如何去接收前端传递过来的值</h4><p>​	springMVC可以支持参数接值，你在前端需要传递的数据，后端mvc可以使用参数进行接收</p>
<p>可以在接收参数的时候接收HttpServletrequest，再接收Parameter值</p>
<p><strong>也可以在参数中根据对应参数名接值</strong></p>
<pre><code class="java">//前端测试:http://localhost:8080/springMVC/user/test03?username=jack001&amp;password=123456&amp;i=10&amp;d=3.14
@RequestMapping(&quot;test03&quot;)
public String getTest03(String username,String password,int i,double d)&#123;

    System.out.println(username+&quot; &quot;+password+&quot; &quot;+i+&quot; &quot;+d);

    return &quot;test&quot;;

&#125;
</code></pre>
<p><strong>springMVC在参数列表中可以通过实体进行接值</strong></p>
<p>mvc会根据接收实例的属性名称来接收对应的前端数据，并且封装成java对象</p>
<pre><code class="java">@RequestMapping(&quot;test04&quot;)
public String getTest04(MvcVo mvcVo)&#123;

    System.out.println(mvcVo);

    return &quot;test&quot;;

&#125;
</code></pre>
<h4 id="springMVC如何将封装好的数据存到Model中"><a href="#springMVC如何将封装好的数据存到Model中" class="headerlink" title="springMVC如何将封装好的数据存到Model中"></a>springMVC如何将封装好的数据存到Model中</h4><p>在参数中接收一个Model接口的实例，是由springMVC提供的，底层封装了request域</p>
<p><strong>通过返回字符串的方式</strong></p>
<pre><code class="java">@RequestMapping(&quot;test05&quot;)
public String getTest05(MvcVo mvcVo, Model model)&#123;

    //把实体存到Model中，底层封装了一个request域
    model.addAttribute(&quot;mcvVo&quot;,mvcVo);

    return &quot;test02&quot;;

&#125;
</code></pre>
<p><strong>通过返回ModelAndView的方式</strong></p>
<pre><code class="java">@RequestMapping(&quot;list&quot;)
public ModelAndView getEmpList()&#123;

    ModelAndView modelAndView = new ModelAndView();

    List&lt;Emp&gt; empList = empService.getEmpList();

    //访问持久层查询数据
    modelAndView.addObject(&quot;empList&quot;,empList);

    //设置视图名称
    modelAndView.setViewName(&quot;list&quot;);

    return modelAndView;
&#125;
</code></pre>
<p>通过SpringMVC来实现转发和重定向</p>
<p>forward</p>
<p>redirect</p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p><strong>通过spring + springMVC + jdbcTemplate 来搭建一个web项目，完成员工列表</strong></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/26/spring/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/18/设计模式/">
        <h2>
            设计模式
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li><p>软件工程中，设计模式（design	pattern）是对软件设计中<strong>普遍存在</strong>（反复出现）的各种<strong>问题</strong>，所提出的<strong>解决方案</strong></p>
</li>
<li><p>这个术语是由埃里希·伽马（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的</p>
</li>
</ul>
<p>拿实际工作经历来说，当一个项目开发完成后，如果客户提出增新功能，怎么办</p>
<p>如果项目开发完后，原来程序员离职，你接收维护该项目怎么办？（维护性，可读性，规范性）</p>
<p>目前开发人员门槛越来越高，一线IT公司（大厂），都会问你在实际项目中使用过什么</p>
<p>设计模式，怎样使用的，解决了什么问题</p>
<p><strong>设计模式哪里使用</strong></p>
<p>基于面向对象</p>
<p>功能模块	[设计模式+算法（数据结构）]</p>
<p>&#x3D;&gt; 框架	[使用到多种设计模式]</p>
<p>&#x3D;&gt;架构	[服务器集群]</p>
<h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><p>编写软件过程中，开发人员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序（软件），具有更好的代码<strong>重用性、可读性、可扩展性、可靠性、使程序呈现高内聚，低耦合</strong>。</p>
<h2 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h3><p>​		对类来说，即一个类应该只负责一项职责，如类A负责两个不同职责：职责1，职责2</p>
<p>​		当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2</p>
<p><strong>一个类去做一类事，一个方法去做一件事</strong></p>
<p>降低类的复杂度，一个类只负责一项职责</p>
<p>提高类的可读性，可维护性</p>
<p>降低变更引起的风险</p>
<p>通常情况下，我们应当遵循单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则</p>
<h3 id="2-接口隔离原则"><a href="#2-接口隔离原则" class="headerlink" title="2.接口隔离原则"></a>2.接口隔离原则</h3><p>（Interface Segregation Principle）</p>
<p>客户端不应该<strong>依赖</strong>它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接 口上</p>
<p>类A通过接口Interface依赖类B，类C通过接口Interface1依赖类D，如果接口Interface对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法</p>
<p>按隔离原则应当这样处理：将接口Interface<strong>拆分</strong>为独立的几个接口，类A和类C分别与他们<strong>需要的接口</strong>建立<strong>依赖关系</strong>，也就是采用接口隔离原则</p>
<p>在接口中只去定义需要被实现类<strong>所需要</strong>的方法</p>
<p>​		以后在设计程序时，一个类实现的接口应该是最小接口，这个接口中的方法应该是这个类都需要用到的</p>
<h3 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3.依赖倒转原则"></a>3.依赖倒转原则</h3><p>（Dependence Inversion Principle）</p>
<ul>
<li><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象</p>
</li>
<li><p>抽象不应该依赖细节，细节应该依赖抽象</p>
</li>
<li><p>依赖倒转(倒置)的<strong>中心思想</strong>是<strong>面向接口编程</strong></p>
</li>
<li><p>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，<strong>抽象</strong>的东西要<strong>稳定</strong>的多，以<strong>抽象为基础</strong>搭建的架构比以细节为基础的架构要稳定的多，在java中，<strong>抽象</strong>指的是<strong>接口或抽象类</strong>，<strong>细节</strong>就是具体的<strong>实现类</strong></p>
</li>
<li><p>使用接口或抽象类的目的是制定好<strong>规范</strong>，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p>
</li>
</ul>
<p><strong>多态</strong>：面向多态、面向抽象、面向接口</p>
<p>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</p>
<p><strong>变量</strong>的<strong>声明类型</strong>尽量是<strong>抽象类</strong>或<strong>接口</strong>，这样我们的变量引用和实际对象间，就存在一个缓冲层，<strong>利于程序扩展和优化</strong></p>
<h3 id="4-里氏替换原则"><a href="#4-里氏替换原则" class="headerlink" title="4.里氏替换原则"></a>4.里氏替换原则</h3><ul>
<li><p>里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院的以为姓里的女士提出的</p>
</li>
<li><p>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型，换句话说，所有引用基类的地方必须能透明地使用其子类的对象</p>
</li>
<li><p>在使用继承时，遵循里氏替换原则，在子类中<strong>尽量不要重写父类的方法</strong></p>
</li>
<li><p>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过<strong>聚合，组合（依赖）</strong>来解决问题</p>
</li>
</ul>
<p><strong>继承包含这样层含义</strong>:</p>
<p>​		父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法<strong>任意修改</strong>，就会对整个继承体系造成<strong>破坏</strong></p>
<p>​		继承在给程序设计带来便利的同时，也带来了<strong>弊端</strong>，比如使用继承会给程序带来<strong>侵入性</strong>，程序的<strong>可移植性降低</strong>，增加对象间的<strong>耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须<strong>考虑到</strong>所有的<strong>子类</strong>，并且父类修改后，所有涉及到子类的功能都有可能产生故障</p>
<p>在子类和父类中如果存在一个同名方法，默认会构成重写</p>
<p>所以说默认类B就重写了类A的方法，数据会错乱，性质就变了</p>
<p><strong>继承</strong>会使得，类与类之间产生耦合性，同时也会给程序带来侵入性</p>
<p>所以说以后如果我们在一个类中需要使用另外一个类的资源，我们通常情况下会采用组合、聚合的方式来引入这个类的实例，而尽量不要采用继承的方式（使用<strong>组合、聚合</strong>等方式<strong>替换继承</strong>）</p>
<h4 id="组合、聚合："><a href="#组合、聚合：" class="headerlink" title="组合、聚合："></a>组合、聚合：</h4><pre><code class="java">class B&#123;
   
    //聚合：set、构造
    private A a;
    
    //组合
    private A a = new A();
    
    public B(A a)&#123;
        this.a = a;
    &#125;
    
    public void setA(A a)&#123;
        this.a = a;
    &#125;

&#125;
</code></pre>
<h3 id="5-开闭原则-OCP"><a href="#5-开闭原则-OCP" class="headerlink" title="5.开闭原则(OCP)"></a>5.开闭原则(OCP)</h3><ul>
<li><p>开闭原则（<strong>Open Closed Principle</strong>）是编程中最基础、最重要的设计原则</p>
</li>
<li><p>一个软件实体如类，模块和函数应该<strong>对扩展开放（提供方）</strong>，<strong>对修改关闭（使用方）</strong>，用抽象构建框架，用实现扩展细节</p>
</li>
<li><p>当软件需要变化时，尽量通过<strong>扩展软件实体行为</strong>来实现变化，而不是通过修改已有的代码来实现变化</p>
</li>
<li><p>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则</p>
</li>
</ul>
<h3 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6.迪米特法则*"></a>6.迪米特法则*</h3><ul>
<li><p>一个对象应该对其他对象保持最少的了解</p>
</li>
<li><p>类与类关系越密切，耦合度越大</p>
</li>
<li><p>迪米特法则（Demeter Principle）又叫最少知道原则，即一个类对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部，对外除了提供的public方法，不对外泄露任何信息</p>
</li>
<li><p>迪米特法则还有个更简单的定义：只与直接的朋友通信</p>
</li>
</ul>
<p>我们称出现<strong>成员变量、方法参数、方法返回值中的类</strong>为直接的朋友，而出现在局部变量中的类不是直接的朋友，也就是说陌生的类最好<strong>不要</strong>以<strong>局部变量</strong>的形式出现在类的内部</p>
<p>迪米特法则的<strong>核心</strong>是<strong>降低类之间的耦合</strong></p>
<p>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系</p>
<p>一个类对于他所依赖的实例知道的越少越好</p>
<p>​		<strong>耦合只能降低，不可能完全消除</strong></p>
<h3 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7.合成复用原则"></a>7.合成复用原则</h3><p>原则是尽量使用<strong>合成(组合)&#x2F;聚合</strong>的方式，而不是使用继承</p>
<h2 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h2><ul>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</li>
<li>针对接口编程，而不是针对实现编程</li>
<li>为了交互对象之间的松耦合（<strong>解耦</strong>）设计而努力</li>
</ul>
<h2 id="设计模式介绍"><a href="#设计模式介绍" class="headerlink" title="设计模式介绍"></a>设计模式介绍</h2><p>设计模式是程序员在面对同类软件工程设计问题所总结出来的<strong>有用的经验</strong>，模式不是代码，而是某类问题的<strong>通用解决方案</strong>，设计模式(Design pattern) 代表了<strong>最佳的实践</strong>，这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的</p>
<p>设计模式的<strong>本质</strong>是提高软件的维护性，通用性和扩展性，并降低软件的复杂度</p>
<h3 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h3><h4 id="1-创建型模式："><a href="#1-创建型模式：" class="headerlink" title="1.创建型模式："></a>1.创建型模式：</h4><p><strong>单例模式</strong></p>
<p>抽象工厂模式</p>
<p><strong>原型模式</strong></p>
<p>建造者模式</p>
<p><strong>工厂模式</strong></p>
<h4 id="2-结构型模式："><a href="#2-结构型模式：" class="headerlink" title="2.结构型模式："></a>2.结构型模式：</h4><p>适配器模式</p>
<p>桥接模式</p>
<p><strong>装饰模式</strong></p>
<p>组合模式</p>
<p>外观模式</p>
<p>享元模式</p>
<p><strong>代理模式</strong></p>
<h4 id="3-行为型模式："><a href="#3-行为型模式：" class="headerlink" title="3.行为型模式："></a>3.行为型模式：</h4><p>模板方法模式</p>
<p>命令模式</p>
<p>访问者模式</p>
<p>迭代器模式</p>
<p>观察者模式</p>
<p>中介者模式</p>
<p>备忘录模式</p>
<p>解释器模式（Interpreter模式）</p>
<p>状态模式</p>
<p>策略模式</p>
<p>职责链模式（责任链模式）</p>
<h3 id="★单例设计模式介绍"><a href="#★单例设计模式介绍" class="headerlink" title="★单例设计模式介绍"></a>★单例设计模式介绍</h3><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在<strong>一个对象实例</strong>，并且该类只提供<strong>一个取得其对象实例的方法</strong>（静态方法）</p>
<p>就是在软件系统中，对于某个类，在任何位置，只能存在一份对象实例</p>
<p><strong>解耦：</strong></p>
<p>​		类A	在项目中的很多模块都需要用到，这个时候如果正常的去获取该类的实例，需要用到<code>new A()</code>，每使用一个new关键字都会去开辟一份空间，占用系统的资源，指向不同的内存地址</p>
<p>​		我们能不能想一种解决方案，在模块需要调用A的资源的时候，不需要反复的去创建对象</p>
<p>单例模式：这个软件系统中你获得的<strong>A的实例</strong>指向的是<strong>一份内存地址</strong></p>
<p>​		</p>
<h4 id="1-饿汉式："><a href="#1-饿汉式：" class="headerlink" title="1.饿汉式："></a>1.饿汉式：</h4><pre><code class="java">public class SingletonDemo&#123;
    
    //对本类进行构造方法私有化，禁止外界new本类实例
    private SingletonDemo()&#123;&#125;
    
    //在本类中创建本类的实例(静态的，具有唯一内存地址)
    private static final SingletonDemo singletonDemo = new SingletonDemo();
    
    //为外界提供访问本类实例的静态方法
    public static SingletonDemo getInstance()&#123;
        
        return singletonDemo;
        
    &#125;
    
&#125;
</code></pre>
<p><strong>静态代码块的方式</strong></p>
<pre><code class="java">public class SingletonDemo02 &#123;

    //1.构造方法私有化,不希望在外界可以实例化对象
    private SingletonDemo02()&#123;&#125;

    //2.在本类实例化本类的实例(静态的,不会在每次调用重新加载实例)
    private static SingletonDemo02 singletonDemo02;

    static &#123;

        singletonDemo02 = new SingletonDemo02();

    &#125;

    //3.提供唯一一个获取这个类实例的方法(静态的)
    public static SingletonDemo02 getInstance()&#123;

        return singletonDemo02;

    &#125;

&#125;
</code></pre>
<h4 id="2-懒汉式："><a href="#2-懒汉式：" class="headerlink" title="2.懒汉式："></a>2.懒汉式：</h4><p>懒汉式会有<strong>线程安全</strong>的问题，如果t1线程和t2线程同时访问这个类，并且同时判断实例为空，两个线程就会同时去创建实例，就不再是<strong>单例</strong>了</p>
<p>如果直接在<strong>方法上加锁</strong>确实可以解决线程安全问题，但是效率却不是最好的</p>
<p>在保证线程安全的同时也要考虑效率问题</p>
<p>在实例还没有创建的时候，多线程确实需要同步执行，但是实例已经创建出来的时候，多线程可以并发的去获取实例</p>
<p><strong>volatile</strong>关键字修饰引用，实现多线程之间的可见性，在t1线程创建实例时及时的去通知t2线程</p>
<p><strong>最终解决方案</strong>：通过双重校验来实现当实例存在的情况下，多线程可以并发的去获取，实例不存在，多线程要同步的去创建</p>
<p>不会直接去创建实例，先去判断实例是否为空，如果实例为空再去创建</p>
<pre><code class="java">public class SingletonDemo03&#123;
    
    //构造方法的私有化
    private SingletonDemo03()&#123;&#125;
    
    //在本类中聚合本类的引用
    private volatile static SingletonDemo03 singletonDemo03;
    
    //提供获取本类中实例的方法
    public static SingletonDemo03 getInstance()&#123;
        
        //检查是否创建实例,如果创建了则直接获取实例，否则创建实例对象
        if(singletonDemo03 == null)&#123;
            
            //提供类锁
            synchronized(SingletonDemo03.class)&#123;
                
                //为上次被阻塞的线程添加一次判断是否在之前有线程创建过实例
                if(singletonDemo03 == null)&#123;
                    
                    singletonDemo03 = new SingletonDemo03();
                    
                &#125;
                
            &#125;
            
        &#125;
        
        //返回本类的实例
        return singletonDemo03;
        
    &#125;
    
    
&#125;
</code></pre>
<h3 id="★代理模式（Proxy）介绍"><a href="#★代理模式（Proxy）介绍" class="headerlink" title="★代理模式（Proxy）介绍"></a>★代理模式（Proxy）介绍</h3><p><strong>代理模式：</strong></p>
<ul>
<li><p>为一个对象提供一个<strong>替身</strong>，以控制对这个对象的访问，即通过<strong>代理对象</strong>访问目标对象，这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即<strong>扩展</strong>目标对象的<strong>功能</strong></p>
</li>
<li><p>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象</p>
</li>
<li><p>代理模式有不同的形式，主要有三种	<strong>静态代理</strong>，<strong>动态代理</strong>（JDK代理、接口代理）和 <strong>Cglib代理</strong>（可以在内存多态的创建对象，而不需要实现接口，他是属于动态代理的范畴）</p>
</li>
</ul>
<p><strong>代理模式是干什么的？</strong></p>
<p>代理模式就是为了<strong>完成对目标类的增强</strong>，完成对目标类的<strong>织入</strong></p>
<p>代理模式增强的是切入点(目标类方法)</p>
<h4 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h4><p>​	静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起<strong>实现相同的接口</strong>或者是<strong>继承相同的父类</strong></p>
<p><strong>优点</strong>：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展</p>
<p><strong>缺点</strong>：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，一旦接口增加方法，目标对象与代理对象都要维护</p>
<p>目标类（被代理类），代理类，逻辑发起点 ：</p>
<p>​	类似于中介（代理类）和房东（目标类）的关系</p>
<p>​	逻辑发起点：客户要找房</p>
<p>​	代理类：负责帮客户选房</p>
<p>​	目标类：签合同</p>
<hr>
<p><strong>逻辑发起点</strong></p>
<pre><code class="java">package com.os467.proxy;

/**
 * 客户（逻辑发起点）
 * 有找房需求：客户有中介的联系方式
 * 客户选好了房子，中介可以联系到房东
 */
public class ProxyApp &#123;

    public static void main(String[] args) &#123;

        //创建中介对象
        ProxyDao proxyDao = new ProxyDao(new ProxyDaoImpl());

        //调用找房子的方法
        proxyDao.findHouse();


    &#125;

&#125;
</code></pre>
<p><strong>代理类与目标类需要实现的接口</strong></p>
<pre><code class="java">package com.os467.proxy;

/**
 * 代理类与目标类需要实现的接口
 */
public interface ProxyInterface &#123;

    /**
     * 找房的方法
     */
    void findHouse();


&#125;
</code></pre>
<p><strong>代理类</strong></p>
<pre><code class="java">package com.os467.proxy;

/**
 * 代理类（中介）
 */
public class ProxyDao implements ProxyInterface&#123;

    //在中介这个类中要得有房东的引用,但是房东是有很多的是模糊的，
    //但是房东实现了这个接口，所以我们在类中聚合接口
    private ProxyInterface proxyInterface;

    //提供一个有参构造
    public ProxyDao(ProxyInterface proxyInterface) &#123;
        this.proxyInterface = proxyInterface;
    &#125;

    /**
     * 在不修改目标方法逻辑的前提下，完成对目标方法的增强
     * 代理类中对目标类方法逻辑的增强
     * 对目标类的织入
     */
    @Override
    public void findHouse() &#123;

        //前置通知(增强的业务逻辑)
        System.out.println(&quot;中介带着客户开始找房&quot;);

        //找到房东，然后签合同，目标方法所有的逻辑
        //代理模式可以通过代理类去增强目标类，增强的一般是切入点（方法）
        proxyInterface.findHouse();

        //后置通知(增强的业务逻辑)
        System.out.println(&quot;中介会告诉客户小区周围的环境，买菜在哪，逛街在哪&quot;);

    &#125;
&#125;
</code></pre>
<p><strong>目标类</strong></p>
<pre><code class="java">package com.os467.proxy;

/**
 * 目标类（房东）
 */
public class ProxyDaoImpl implements ProxyInterface&#123;

    @Override
    public void findHouse() &#123;

        System.out.println(&quot;客户选好了房子，中介直接带着客户来签合同&quot;);
        System.out.println(&quot;合同签署完毕&quot;);

    &#125;
&#125;
</code></pre>
<hr>
<h4 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h4><h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象</p>
<p><strong>实现步骤</strong>：需要调用JDK提供的相关方法</p>
<p><strong>创建的对象</strong>：目标对象、代理对象（不需要我们创建，通过反射去创建）、创建代理对象的对象</p>
<p>目标类和代理类<strong>实现了相同的接口</strong>，那么可以使用两者<strong>接口的方法字节码对象</strong>来调用两者的对应方法</p>
<hr>
<p><strong>代理类创建类</strong></p>
<pre><code class="java">package com.os467.jdkProxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 这个类不是代理类，是创建代理类的类
 */
public class CreateJdkProxy &#123;

    //目标对象
    private Object object;

    public CreateJdkProxy(Object object)&#123;

        this.object = object;

    &#125;

    /**
     * 通过反射机制来创建代理对象
     * @return
     */
    public Object getProxy()&#123;

        /**
         * ClassLoader loader ：目标类的类加载器对象
         * Class[] interfaces ：目标类所实现的接口字节码对象
         * InvocationHandler h ：是一个接口对象，这个接口提供了invoke方法
         * 方法里面完成对目标对象的增强
         */

        //目标类的类加载器对象
        ClassLoader classLoader = object.getClass().getClassLoader();

        //目标类所实现的接口字节码对象
        Class[] interfaces = object.getClass().getInterfaces();

        //接口实例,匿名内部类
        InvocationHandler invocationHandler = new InvocationHandler() &#123;

            /**
             * 这个方法的作用就是完成对目标对象的增强，对目标方法增强的整个过程都在这个方法内
             * @param proxy ：代理对象
             * @param method ：代理对象的与目标对象实现的共同接口方法字节码对象
             * @param args ：代理方法字节码对象对应的参数
             * @return 返回目标对象方法返回值
             * @throws Throwable
             */
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;

                System.out.println(&quot;前置通知----&quot;);

                //调用目标对象的方法，接口方法字节码对象调用目标对象的方法
                Object invoke = method.invoke(object, args);

                System.out.println(&quot;后置通知----&quot;);

                return invoke;
            &#125;
        &#125;;

        //这个方法返回的就是一个代理对象
        Object obj = Proxy.newProxyInstance(classLoader,interfaces,invocationHandler);

        return obj;
    &#125;

&#125;
</code></pre>
<p><strong>目标类</strong></p>
<pre><code class="java">package com.os467.jdkProxy;

/**
 * 目标类
 */
public class ProxyDao implements ProxyInterface &#123;

    /**
     * 目标类重写的方法
     * @param food
     * @return
     */
    @Override
    public String eat(String name,String food) &#123;

        System.out.println(&quot;目标方法中的逻辑&quot;);

        return name+&quot;正在吃&quot;+food;

    &#125;

&#125;
</code></pre>
<p><strong>共同接口</strong></p>
<pre><code class="java">package com.os467.jdkProxy;

/**
 * 代理类和目标类需要实现的共同接口
 */
public interface ProxyInterface &#123;

    /**
     * 吃的方法
     * @param food
     * @return
     */
    String eat(String name,String food);

&#125;
</code></pre>
<p><strong>逻辑发起点</strong></p>
<pre><code class="java">package com.os467.jdkProxy;

public class Test &#123;

    public static void main(String[] args) &#123;

        //创建目标对象
        ProxyInterface proxyInterface = new ProxyDao();

        //用于获取代理对象创建类的实例
        CreateJdkProxy createJdkProxy = new CreateJdkProxy(proxyInterface);

        //调用方法，获取到代理对象
        ProxyInterface proxy = (ProxyInterface)createJdkProxy.getProxy();

        //调用方法
        System.out.println(proxy.eat(&quot;张三&quot;,&quot;饭&quot;));

    &#125;

&#125;
</code></pre>
<hr>
<p><strong>InvocationHandler接口</strong> (调用处理程序对象)</p>
<p>用于返回目标对象方法调用后的<strong>返回值</strong></p>
<p>需要在创建代理对象的时候作为参数使用，通过<strong>匿名内部类</strong>方式创建实例</p>
<p>需要重写<strong>invoke</strong>方法，此方法回返值即目标对象方法的返回值</p>
<p>区分使用<strong>method</strong>字节码对象与使用<strong>invocationHandler</strong>实例调用invoke方法所需要的参数</p>
<p>假设在代理类中聚合了invocationHandler实例：</p>
<p>提供<strong>目标类实例</strong>，<strong>参数列表</strong></p>
<pre><code class="java">Object invoke1 = method.invoke(ProxyDao.class.newInstance(), new Object[]&#123;&#125;);
</code></pre>
<p>提供<strong>代理类实例</strong>，<strong>方法字节码对象</strong>，<strong>参数列表</strong></p>
<pre><code class="java">Object invoke = invocationHandler.invoke(this,method,new Object[]&#123;&#125;);
</code></pre>
<p><strong>模拟动态代理在底层的调用</strong></p>
<pre><code class="java">/**
 * 模拟jdk动态代理在底层调用过程
 */
public class Proxy implements ProxyInterface &#123;

    //聚合调用处理程序对象
    private InvocationHandler invocationHandler;

    public Proxy(InvocationHandler invocationHandler) &#123;

        this.invocationHandler = invocationHandler;

    &#125;

    @Override
    public void study() &#123;

        try &#123;

            //先定义目标类方法字节码对象，我们创建接口的方法字节码对象
            Method method = ProxyInterface.class.getDeclaredMethod(&quot;study&quot;);

            //调用目标类的方法
            Object invoke = invocationHandler.invoke(this, method, new Object[]&#123;&#125;);

            System.out.println(invoke);


        &#125; catch (NoSuchMethodException e) &#123;
            e.printStackTrace();
        &#125; catch (Throwable throwable) &#123;
            throwable.printStackTrace();
        &#125; 

    &#125;
&#125;
</code></pre>
<h5 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h5><ul>
<li><p>静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候可以<strong>使用目标对象子类来实现代理</strong> （这就是Cglib代理）</p>
</li>
<li><p>Cglib代理也叫做子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理</p>
</li>
<li><p>Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类与实现java接口，它广泛的被许多AOP的框架使用，例如Spring AOP，实现方法拦截</p>
</li>
<li><p>在AOP编程过程中如何选择代理模式：</p>
<p>​	1.目标对象需要实现接口，用JDK代理</p>
<p>​	2.目标对象不需要实现接口，用Cglib代理</p>
<p>​	</p>
</li>
<li><p>Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</p>
</li>
</ul>
<p><strong>目标类</strong></p>
<pre><code class="java">package com.os467.Cglib;

/**
 * 目标类
 */
public class CglibDao &#123;

    public void getMethod()&#123;

        System.out.println(&quot;需要增强方法的主题内容&quot;);

    &#125;

&#125;
</code></pre>
<p><strong>创建代理类</strong></p>
<pre><code class="java">package com.os467.Cglib;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class CreateCglib implements MethodInterceptor &#123;

    //聚合目标类
    private Object object;

    public CreateCglib(Object object) &#123;
        this.object = object;
    &#125;

    /**
     * 获取代理对象
     * @return
     */
    public Object getCglibProxy()&#123;

        //创建cglib对象
        Enhancer enhancer = new Enhancer();

        //设置代理对象的父类
        enhancer.setSuperclass(object.getClass());

        //设置回调函数
        enhancer.setCallback(this);

        //创建代理对象并且返回
        return enhancer.create();
    &#125;

    /**
     * 增强目标类
     * @param o 代理类对象 基本用不到
     * @param method 代理类方法字节码对象
     * @param objects 传递的参数
     * @param methodProxy 基本用不到
     * @return
     * @throws Throwable
     */
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;

        System.out.println(&quot;前置通知---&quot;);

        //调用目标方法
        Object invoke = method.invoke(object, objects);

        System.out.println(&quot;后置通知---&quot;);

     return invoke;
    &#125;
&#125;
</code></pre>
<p><strong>测试类</strong></p>
<pre><code class="java">package com.os467.Cglib;

public class Test &#123;

    public static void main(String[] args) &#123;

        //创建目标对象
        CglibDao cglibDao = new CglibDao();

        //创建代理对象
        CreateCglib createCglib = new CreateCglib(cglibDao);

        CglibDao cglibProxy = (CglibDao)createCglib.getCglibProxy();

        cglibProxy.getMethod();

    &#125;

&#125;
</code></pre>
<p><strong>总结JDK动态代理和Cglib动态代理</strong>：</p>
<p>​		<strong>相同点</strong>：都是在内存中去创建对象，功能也是一样的，都是完成对目标方法的增强</p>
<p>​		<strong>不同点</strong>：</p>
<p>​			<strong>jdk代理</strong>：要求目标类必须实现一个接口，内存中创建出来的代理类也会实现相同的接口</p>
<p>​			<strong>Cglib代理</strong>：目标类不用实现接口，可以只是一个普通的类，在内存中创建出来的代理类是目标类的子类</p>
<p><strong>总结</strong>：动态代理实际上都是用于<strong>增强目标方法</strong>，如果需要被增强的类实现了接口，我们需要采用JDK代理，如果没有实现接口，我们采用Cglib代理</p>
<p><strong>动态代理在以后开发中的作用</strong>：</p>
<p>​		SpringAop（面向切面编程：底层就是通过代理模式实现的）：</p>
<p>​		模块1：</p>
<p>​		模块2：</p>
<p>​		模块3：</p>
<p>​		假设某项目有很多模块，每个模块封装了不同的业务逻辑，我们以后使用框架进行开发，目的可以提高开发效率，可以让开发人员只去关注核心业务，不去关注一些非核心业务</p>
<p>​		<strong>提一个需求</strong>：希望每个模块都能完成日志的收集，当任意一个模块的代码发生了异常，这个时候希望整理成日志文档，方便开发人员排错</p>
<p>​		<strong>注意</strong>：日志收集的代码不属于核心业务，日志收集的代码是每个模块都需要的</p>
<p>​		SpringAop可以完成对核心模块的增强：</p>
<p>​		日志收集的代码（需要对每个模块增强的部分）</p>
<p>​		<strong>增强的步骤</strong>：</p>
<p>​				1、获取每个模块的目标方法</p>
<p>​				2、配置SpringAop的切面 &#x3D;&#x3D;&gt; 切面（指的就是增强的过程）</p>
<p>​		<strong>切面</strong>：</p>
<p>​				spring会去校验核心模块中的核心类是否实现了接口，如果实现了，在底层使用jdk代理来完成，如果没有实现，则使用Cglib代理来完成</p>
<p>核心类实现了接口需要在 invoke 方法当中完成对目标方法的增强</p>
<p>invoke{ </p>
<p>日志收集的代码1   </p>
<p>通过反射机制调用目标方法  </p>
<p>日志收集的代码2 </p>
<p>}</p>
<p>所以说，通过这种方式可以让非核心代码脱离核心模块，而且方便维护，易于管理</p>
<h3 id="★工厂模式"><a href="#★工厂模式" class="headerlink" title="★工厂模式"></a>★工厂模式</h3><h4 id="普通工厂模式"><a href="#普通工厂模式" class="headerlink" title="普通工厂模式"></a>普通工厂模式</h4><p>是指由一个工厂对象决定创建出哪一种产品类的实例，属于创建型模式</p>
<p>1、适用于工厂类负责创建的对象较少的场景</p>
<p>2、且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心</p>
<p>简单工厂模式<strong>缺点</strong>：</p>
<p>1、工厂类的职责相对过重，增加新的产品时需要<strong>修改工厂类的逻辑判断</strong>，<strong>违背开闭原则</strong>（ocp）</p>
<p>2、不易于扩展过于复杂的产品结构</p>
<p>由工厂来为我们生产对象</p>
<p>生产手机的工厂Phone_Factory：华为、苹果、小米</p>
<p><strong>普通工厂模式</strong>：根据标识去生产实例</p>
<pre><code class="java">/**
 * 生产手机：我们通过普通工厂模式来写这个类
 */
public class PhoneFactory &#123;

    /**
     * 获取手机实例的方法
     * @return
     */
    public Object getPhone(String flag)&#123;

        if (flag.equals(&quot;mi&quot;))&#123;

            //返回小米的实例
            return new Mi();

        &#125;else if (flag.equals(&quot;huawei&quot;))&#123;

            //返回的是苹果的实例
            return new HuaWei();

        &#125;else if (flag.equals(&quot;iphone&quot;))&#123;

            //返回的是苹果的实例
            return new Iphone();

        &#125;

        return null;
    &#125;

&#125;
</code></pre>
<pre><code class="java">/**
 * 需求：通过工厂获取手机实例
 */
public class FactoryTest01 &#123;

    public static void main(String[] args) &#123;

        //创建工厂对象
        PhoneFactory phoneFactory = new PhoneFactory();

        //获取华为实例
        HuaWei huawei = (HuaWei)phoneFactory.getPhone(&quot;huawei&quot;);

        huawei.make();

        //获取小米的实例
        Mi mi = (Mi)phoneFactory.getPhone(&quot;mi&quot;);

        mi.make();

    &#125;

&#125;
</code></pre>
<p>工厂模式为了避免程序过多的使用<strong>new关键字</strong>来创建对象，这样会产生耦合</p>
<hr>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><ul>
<li><p>是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行</p>
</li>
<li><p>用户只需要关心所需产品对应的工厂，无需关心创建的细节，而且加入新的产品符合开闭原则</p>
</li>
</ul>
<pre><code class="java">/**
 * 生产手机：我们通过工厂方法模式来写这个类
 */
public class PhoneFactory2 &#123;

    /**
     * 获取小米手机实例的方法
     * @return
     */
    public Phone getMi()&#123;

        return new Mi();
    &#125;

    /**
     * 获取华为手机实例的方法
     * @return
     */
    public Phone getHuaWei()&#123;

        return new HuaWei();
    &#125;

    /**
     * 获取苹果手机实例的方法
     * @return
     */
    public Phone getIphone()&#123;

        return new Iphone();
    &#125;

&#125;
</code></pre>
<p><strong>产品需要实现的接口</strong></p>
<pre><code class="java">public interface Phone &#123;

    void make();

&#125;
</code></pre>
<p><strong>测试类</strong></p>
<pre><code class="java">/**
 * 需求：通过工厂获取手机实例
 */
public class FactoryTest02 &#123;

    public static void main(String[] args) &#123;

        //创建工厂对象
        PhoneFactory2 phoneFactory2 = new PhoneFactory2();

        //获取华为实例
        Phone huaWei = phoneFactory2.getHuaWei();

        huaWei.make();

        //获取华为实例
        Phone iphone = phoneFactory2.getIphone();

        iphone.make();

    &#125;
&#125;
</code></pre>
<hr>
<p><strong>静态工厂</strong></p>
<p>将工厂类中的方法加上<strong>static关键字</strong>，这样就不需要创建工厂对象</p>
<hr>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>是指<strong>提供</strong>一个创建一系列相关或者相互依赖对象的<strong>接口</strong>，无需指定他们具体的类</p>
<p><strong>抽象工厂模式使用场景</strong>：</p>
<p>1、客户端（应用层）不依赖于产品类实例如何被创建，实现等细节</p>
<p>2、强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码</p>
<p>3、提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体的实现</p>
<p><strong>抽象工厂模式优点</strong>：</p>
<p>1、具体产品在应用层代码隔离，无需关系创建细节</p>
<p>2、将一个系列的产品族统一到一起创建</p>
<p>抽象工厂模式要求工厂和产品<strong>都需要基于接口开发</strong></p>
<p><strong>工厂类需要实现的工厂接口</strong></p>
<pre><code class="java">/**
 * 所有工厂都需要去实现的接口
 *
 *  工厂是用来生产产品的
 */
public interface Factory &#123;

    /**
     * 制作手机的方法
     */
    Phone makePhone(String className);

&#125;
</code></pre>
<p><strong>产品需要实现的接口</strong></p>
<pre><code class="java">public interface Phone &#123;

    void make();

&#125;
</code></pre>
<p><strong>创建手机工厂类实现工厂接口</strong></p>
<pre><code class="java">/**
 * 生产手机：通过抽象工厂模式来写这个类
 */
public class PhoneFactory3 implements Factory&#123;

    /**
     * 用于生产手机的方法
     * @param className
     * @return
     */
    @Override
    public Phone makePhone(String className) &#123;

        if (className != null)&#123;

            try &#123;

                //获取字节码对象
                Class&lt;?&gt; aClass = Class.forName(className);

                //通过反射机制来创建实例
                Object o = aClass.newInstance();

                if (o instanceof Phone)&#123;

                    return (Phone)o;

                &#125;

            &#125; catch (ClassNotFoundException e) &#123;
                e.printStackTrace();
            &#125; catch (IllegalAccessException e) &#123;
                e.printStackTrace();
            &#125; catch (InstantiationException e) &#123;
                e.printStackTrace();
            &#125;


        &#125;

        return null;
    &#125;
&#125;
</code></pre>
<p><strong>测试类</strong></p>
<pre><code class="java">/**
 * 需求：通过抽象工厂获取手机实例
 */
public class FactoryTest03 &#123;

    public static void main(String[] args) &#123;

        Factory factory = new PhoneFactory3();

        Phone phone = factory.makePhone(&quot;com.os467.phone.Mi&quot;);

        phone.make();

    &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/18/设计模式/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/17/Ajax/">
        <h2>
            Ajax
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/17
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</p>
<h2 id="AJAX-是什么？"><a href="#AJAX-是什么？" class="headerlink" title="AJAX 是什么？"></a>AJAX 是什么？</h2><p>AJAX &#x3D; Asynchronous JavaScript and XML</p>
<p>AJAX 是一种用于创建快速<strong>动态网页</strong>的技术</p>
<p>AJAX 通过在后台与服务器进行少量数据交换，使网页实现<strong>异步更新</strong>，这意味着可以在不重载整个页面的情况下，对网页的某些<strong>部分进行更新</strong></p>
<p>传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个页面</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/08/ajax.gif"></p>
<h2 id="AJAX-基于因特网标准"><a href="#AJAX-基于因特网标准" class="headerlink" title="AJAX 基于因特网标准"></a>AJAX 基于因特网标准</h2><p>AJAX 基于因特网标准，并使用以下技术组合：</p>
<ul>
<li>XMLHttpRequest 对象（与服务器异步交互数据）</li>
<li>JavaScript&#x2F;DOM（显示&#x2F;取回信息）</li>
<li>CSS（设置数据的样式）</li>
<li>XML（常用作数据传输的格式）</li>
</ul>
<p><img src="https://www.runoob.com/images/lamp.gif" alt="lamp"> AJAX 应用程序与浏览器和平台无关的！</p>
<h2 id="AJAX-创建-XMLHttpRequest-对象"><a href="#AJAX-创建-XMLHttpRequest-对象" class="headerlink" title="AJAX - 创建 XMLHttpRequest 对象"></a>AJAX - 创建 XMLHttpRequest 对象</h2><hr>
<p>XMLHttpRequest 是 AJAX 的基础。</p>
<hr>
<h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><p>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 <code>ActiveXObject</code>）。</p>
<p>XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在<strong>不重新加载整个网页的情况下，对网页的某部分进行更新</strong></p>
<hr>
<h3 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h3><p>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p>
<p>创建 XMLHttpRequest 对象的语法：</p>
<pre><code class="javascript">variable = new XMLHttpRequest();
</code></pre>
<p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：</p>
<pre><code class="javascript">variable = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
</code></pre>
<p>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 <code>ActiveXObject </code>：</p>
<pre><code class="javascript">var xmlhttp; 
if (window.XMLHttpRequest) &#123;

//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码   
    xmlhttp=new XMLHttpRequest(); 

&#125; else &#123;    

// IE6, IE5 浏览器执行代码    
xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);

&#125;
</code></pre>
<h2 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h2><p>如需将请求发送到服务器，我们使用 <strong>XMLHttpRequest</strong> 对象的 <strong>open()</strong> 和 <strong>send()</strong> 方法：</p>
<p><code>open(method,url,async)</code></p>
<p>规定请求的类型、URL 以及是否异步处理请求。</p>
<ul>
<li>method：请求的类型；GET 或 POST</li>
<li><code>url</code>：文件在服务器上的位置</li>
<li><code>async</code>：true（异步）或 false（同步）</li>
</ul>
<pre><code class="javascript">xmlhttp.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);
xmlhttp.send();
</code></pre>
<p><code>send(string)</code></p>
<p>将请求发送到服务器。</p>
<ul>
<li>string：仅用于 POST 请求</li>
</ul>
<h2 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h2><p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 <code>responseText</code> 或 <code>responseXML</code> 属性。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>responseText</code></td>
<td align="center">获得字符串形式的响应数据。</td>
</tr>
<tr>
<td align="center"><code>responseXML</code></td>
<td align="center">获得 XML 形式的响应数据。</td>
</tr>
</tbody></table>
<h2 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a><code>onreadystatechange</code> 事件</h2><p>当<strong>请求被发送到服务器</strong>时，我们需要<strong>执行一些基于响应的任务</strong>。</p>
<p>每当 <code>readyState</code> <strong>改变</strong>时，就会触发 <code>onreadystatechange</code> 事件。</p>
<p><code>readyState</code> 属性存有 XMLHttpRequest 的状态信息。</p>
<p>下面是 XMLHttpRequest 对象的三个重要的属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>onreadystatechange</code></td>
<td align="center">存储函数（或函数名），每当 <code>readyState</code> 属性改变时，就会调用该函数。</td>
</tr>
<tr>
<td align="center"><code>readyState</code></td>
<td align="center">存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪</td>
</tr>
<tr>
<td align="center">status</td>
<td align="center">200: “OK” 404: 未找到页面</td>
</tr>
</tbody></table>
<p>在 <code>onreadystatechange</code> 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。</p>
<p>当 <code>readyState</code> 等于 4 且状态为 200 时，表示响应已就绪：</p>
<p><strong>后端进行一个简单的用户伪校验</strong></p>
<pre><code class="java">@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

    request.setCharacterEncoding(&quot;utf-8&quot;);
    response.setContentType(&quot;html/text;charset=utf-8&quot;);

    String username = request.getParameter(&quot;username&quot;);
    String password = request.getParameter(&quot;password&quot;);

    if (username.equals(&quot;jack001&quot;) &amp;&amp; password.equals(&quot;123456&quot;))&#123;

        response.getWriter().print(&quot;1&quot;);

    &#125;else &#123;

        response.getWriter().print(&quot;2&quot;);

    &#125;

&#125;
</code></pre>
<h3 id="Ajax-JS"><a href="#Ajax-JS" class="headerlink" title="Ajax(JS)"></a>Ajax(JS)</h3><p><strong>一个基于JS原生Ajax的用户数据后端校验</strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;原生js的ajax&lt;/title&gt;
&lt;/head&gt;

&lt;script&gt;

    //测试Ajax的函数
    function testAjax()&#123;

        let xmlHttp;

        //判断是不是ie浏览器
        if(window.XMLHttpRequest)&#123;

            xmlHttp = new XMLHttpRequest();

        &#125;else &#123;

            xmlHttp = ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);

        &#125;

        let usernameEl = document.getElementById(&quot;username&quot;);

        let passwordEl = document.getElementById(&quot;password&quot;);

        let username = usernameEl.value;

        let password = passwordEl.value;

        //设置参数
        xmlHttp.open(&quot;GET&quot;,&quot;http://localhost:8080/jQuery/test?username=&quot;+username+&quot;&amp;password=&quot;+password,true);

        //访问具体的服务，发送请求
        xmlHttp.send();

        //绑定监听事件
        xmlHttp.onreadystatechange = function ()&#123;

            //判断服务器和网页的状态
            if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200)&#123;

                //获取服务器响应的数据
                alert(xmlHttp.responseText);

            &#125;

        &#125;

    &#125;

&lt;/script&gt;

&lt;body&gt;
请输入用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; value=&quot;&quot;&gt;&lt;br&gt;
请输入用户名密码：&lt;input type=&quot;password&quot; id=&quot;password&quot; value=&quot;&quot;&gt;&lt;br&gt;
&lt;input type=&quot;button&quot; value=&quot;ajax监听事件按钮&quot; onclick=&quot;testAjax()&quot;&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Ajax-JQuery"><a href="#Ajax-JQuery" class="headerlink" title="Ajax(JQuery)"></a>Ajax(JQuery)</h3><p><strong>一个基于Ajax的用户登录校验</strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;jQuery的ajax&lt;/title&gt;
&lt;/head&gt;
&lt;script src=&quot;../jQuery/jquery-1.7.2.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;

   $(function ()&#123;

       $(&quot;[value=提交]&quot;).click(function ()&#123;

           //获取用户名和密码的值
           let username = $(&quot;#username&quot;).val();

           let password = $(&quot;#password&quot;).val();

           //调用ajax函数
           $.ajax(&#123;

               //提交到后端的地址
               url:&quot;http://localhost:8080/jQuery/test&quot;,

               //提交的方式
               type:&quot;POST&quot;,

               //提交到后端的数据
               data:&#123;
                   username:username,
                   password:password
               &#125;,

               //请求成功之后的回调函数，监听事件
               success:function (obj)&#123;

                   if (obj == &quot;1&quot;)&#123;

                       alert(&quot;登陆成功&quot;);

                       //跳转到页面
                       location.href = &quot;http://www.baidu.com&quot;;
                   &#125;else &#123;

                       alert(&quot;登陆失败&quot;);

                   &#125;

               &#125;,

               //服务端返回的数据类型text,html,json,xml
               dataType:&quot;text&quot;

           &#125;)


       &#125;)

   &#125;)

&lt;/script&gt;

&lt;body&gt;
&lt;table align=&quot;center&quot; border=&quot;1px&quot;&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;td colspan=&quot;2&quot;&gt;&lt;h3&gt;用户登录&lt;/h3&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            请输入用户名
        &lt;/td&gt;
        &lt;td&gt;
            &lt;input type=&quot;text&quot; id=&quot;username&quot; value=&quot;&quot;&gt;&lt;br&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            请输入密码
        &lt;/td&gt;
        &lt;td&gt;
            &lt;input type=&quot;password&quot; id=&quot;password&quot; value=&quot;&quot;&gt;&lt;br&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;td colspan=&quot;2&quot;&gt;
            &lt;input type=&quot;button&quot; value=&quot;提交&quot;&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;


&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>jQuery中封装的ajax以JSON串的形式存值</strong></p>
<p>一些关键的<strong>key与value</strong>：</p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">url</td>
<td align="center">后端资源地址</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">“GET”、”POST”…</td>
</tr>
<tr>
<td align="center">data</td>
<td align="center">提交到后端的数据（JSON串）{username : username, password : password}</td>
</tr>
<tr>
<td align="center">success</td>
<td align="center">服务器反馈数据成功后执行的方法 function (object接收后端的参数){方法体}</td>
</tr>
<tr>
<td align="center">dataType</td>
<td align="center">服务端返回的数据类型text,html,json,xml   “text”</td>
</tr>
</tbody></table>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/17/Ajax/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/14/Annotation/">
        <h2>
            Annotation
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/14
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p><strong>什么是注解？</strong></p>
<p>是<strong>元数据(Annotation)</strong> ，是一种对代码进行说明的数据，JDK1.5引入的新<strong>规范</strong>，是与类、接口、枚举等引用类型处于同一个层次，可以用在包、类、属性、方法、方法的参数和局部变量等的前边，<strong>不影响代码的语义</strong>，可以对其进行<strong>解析</strong></p>
<p><strong>注解Annotation</strong>:  是一种<strong>引用数据类型</strong>(在类加载的时候会生成字节码文件)</p>
<p><strong>注解在以后的用途:</strong></p>
<p>​		注解的作用：</p>
<p>​		注解只能起到一个<strong>标识</strong>的作用</p>
<p><strong>spring框架</strong>：基于注解的开发模式</p>
<p>​		学习了反射可以不使用new关键字去创建一个类的实例</p>
<p>​		spring是一个容器里面会存放很多类的实例</p>
<p><strong>我怎么知道有哪些类需要去创建实例，那些类不需要创建实例?</strong></p>
<p>​		用注解去标识一下，需要创建实例的类，用注解去做一个标识</p>
<p>​		在spring框架检测到该类有注解时，就会通过反射机制去创建该类的实例</p>
<p><strong>beans</strong>： User、Student、Person、Animal</p>
<h2 id="创建一个注解"><a href="#创建一个注解" class="headerlink" title="创建一个注解"></a>创建一个注解</h2><pre><code class="java">public @interface MyAnnotation &#123;
    
&#125;
</code></pre>
<p>注解中可以拥有属性，但是<strong>不能拥有方法</strong></p>
<p>如果你给一个注解声明了属性，那么在注解<strong>修饰元素</strong>的时候，就必须要给属性<strong>赋值</strong>，除非你在声明属性的时候，给了属性默认值</p>
<h3 id="在注解中声明属性"><a href="#在注解中声明属性" class="headerlink" title="在注解中声明属性"></a>在注解中声明属性</h3><pre><code class="java">public @interface MyAnnotation &#123;

    //在注解中如何去声明属性
    String name() default &quot;&quot;;

    int i();

    String[] strings() default &#123;&quot;1&quot;,&quot;2&quot;&#125;;

    //枚举类型
    Math math() default Math.Max;
    
    Math[] maths() default &#123;Math.Max,Math.Count,Math.Sum&#125;;
    
&#125;
</code></pre>
<p><strong>在注解中定义属性只能时八大基本数据类型、字符串类型String、枚举类型、以及主要类型所对应的数组类型</strong></p>
<p>在定义属性时，如果属性名称是<strong>value</strong>，那在注解修饰元素，并且给属性赋值的时候，属性名称可以<strong>省略不写</strong></p>
<pre><code class="java">@MyAnnotation(name = &quot;123&quot;,i = 100)
</code></pre>
<h4 id="注解运用范围"><a href="#注解运用范围" class="headerlink" title="注解运用范围"></a>注解运用范围</h4><p>注解使用时的语法格式是：</p>
<p>​		@注解类型名</p>
<p>注解可以出现在类上、属性上、方法上、变量上等</p>
<p>注解可以出现在注解类型上</p>
<h3 id="JDK内置注解"><a href="#JDK内置注解" class="headerlink" title="JDK内置注解"></a>JDK内置注解</h3><p><strong>Deprecated</strong> 用 <code>@Deprecated</code> 注释的程序元素，不鼓励程序员使用这样的元素，通过是因为它很危险或存在更好的选择</p>
<p><strong>Override</strong>表示一个方法声明打算重写超类中的另一个方法声明</p>
<p><strong><code>SuppressWarnings</code></strong>  指示应该在注释元素（以及包含在该注释元素中的所有程序元素）中取消显示指定的编译器警告</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><strong>什么是元注解？</strong></p>
<p>用来标注“注解类型”的“注解”，称为元注解</p>
<p><strong>修饰注解的注解</strong></p>
<p>在定义注解时需要通过元注解指定例如注解的使用场合、是否生成文档、是否可以继承、注解保持的策略（是否能被反射机制所获取到）</p>
<p><strong>元注解</strong>：</p>
<p><code>@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</code>	表示注解的作用域</p>
<p>参数只能是枚举类型数组</p>
<pre><code class="java">//使得注解能标识在类和属性前
@Target(&#123;ElementType.TYPE,ElementType.FIELD&#125;)
public @interface MyAnnotation &#123;

&#125;
</code></pre>
<ul>
<li><p><code>@Retention(RetentionPolicy.RUNTIME)</code>	</p>
<p>注解的生命周期</p>
</li>
<li><p><code>RetentionPolicy(设置注解的生命周期以及保持性策略)</code>:</p>
<p>​	<strong>SOURCE</strong>：</p>
<p>​		当前注解只保留在源码这个层面上，在类加载的时候不会去生成字节码文件，而且不可以被反射机制所获取!</p>
<p>​		<strong>CLASS</strong>：</p>
<p>​		在类加载的时候会生成字节码文件，但是不可以被发射机制获取</p>
<p>​		<strong>RUNTIME</strong>：</p>
<p>​		在类加载的时候可以生成字节码文件，而且可以被反射机制获取工</p>
</li>
<li><p><code>@Inherited</code></p>
<p>标识允许子注解来继承这个注解（注意这里只能是继承不能是接口上使用，而且只能继承类上的注解，不能继承方法上的注解）</p>
</li>
<li><p><code>@Documented</code>	</p>
<p>生成JAVADOC时会包含注解</p>
</li>
</ul>
<h2 id="如何通过反射机制获取注解："><a href="#如何通过反射机制获取注解：" class="headerlink" title="如何通过反射机制获取注解："></a>如何通过反射机制获取注解：</h2><p>​		1、创建类对应的字节码对象</p>
<p>​		2、通过字节码对象获取注解字节码对象</p>
<pre><code class="java">public class Annotation01 &#123;

    public static void main(String[] args) &#123;


        try &#123;

            //创建字节码对象
            Class aClass = Class.forName(&quot;com.os467.pojo.User&quot;);

            //获取类上的注解
            MyAnnotation annotation = (MyAnnotation)aClass.getAnnotation(MyAnnotation.class);

            if (annotation != null)&#123;

                //获取注解上的属性
                System.out.println(annotation.name());

                //获取属性字节码对象
                Field[] declaredFields = aClass.getDeclaredFields();

                for (Field declaredField : declaredFields) &#123;

                    MyAnnotation annotation1 = declaredField.getAnnotation(MyAnnotation.class);

                    if (annotation1 != null)&#123;

                        System.out.println(declaredField.getName()+&quot; 这个属性上有注解&quot;);

                    &#125;

                &#125;

            &#125;

        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125;


    &#125;

&#125;
</code></pre>
<h3 id="根据注解自动生成SQL查询语句"><a href="#根据注解自动生成SQL查询语句" class="headerlink" title="根据注解自动生成SQL查询语句"></a>根据注解自动生成SQL查询语句</h3><pre><code class="java">package com.os467;

import com.os467.Annotion.Table;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;


public class ORM &#123;

    private ORM()&#123;

    &#125;

    public static String getSql(Object obj)&#123;

        StringBuilder stringBuilder = new StringBuilder();

        //获取obj字节码对象
        Class aClass = obj.getClass();

        Table annotation = (Table)aClass.getAnnotation(Table.class);

        //表的名称
        String table = null;

        if (annotation != null)&#123;

            //获取表的名称
            table = annotation.value();

            stringBuilder.append(&quot;select * from &quot;+ table +&quot; where &quot;);

        &#125;

        //获取属性字节码对象
        Field[] declaredFields = aClass.getDeclaredFields();

        for (Field declaredField : declaredFields) &#123;

            //打破封装
            declaredField.setAccessible(true);

            com.os467.Annotion.Field annotation1 = declaredField.getAnnotation(com.os467.Annotion.Field.class);

            //注解不为空的情况下拼接
            if (annotation1 != null)&#123;

                try &#123;

                    //获取属性值
                    Object o = declaredField.get(obj);

                    //检查email属性是否有多个&quot;，&quot;隔开
                    if (o != null &amp;&amp; o.toString().contains(&quot;,&quot;))&#123;

                        stringBuilder.append(annotation1.value() + &quot; in(&quot; + o + &quot;) and&quot;);

                    &#125;else if (o != null &amp;&amp; !o.toString().equals(&quot;0&quot;))&#123;

                        stringBuilder.append(annotation1.value() + &quot; = &quot;);

                        if (o instanceof String)&#123;

                            stringBuilder.append(&quot;&#39;&quot; + o + &quot;&#39;&quot; + &quot; and &quot;);

                        &#125;

                        if (o instanceof Integer)&#123;

                            stringBuilder.append(o + &quot; and &quot;);

                        &#125;

                    &#125;


                &#125; catch (IllegalAccessException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;

        &#125;

        String s = stringBuilder.toString();

        //替换掉最后的and 
        s = s.substring(0,s.length() - 4);

        if (s.contains(&quot;=&quot;))&#123;

            return s;

        &#125;

        return null;
    &#125;

&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/14/Annotation/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/13/Reflect/">
        <h2>
            Reflect
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/13
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="反射Reflect"><a href="#反射Reflect" class="headerlink" title="反射Reflect"></a>反射Reflect</h1><p><strong>反射机制是干什么的</strong>：</p>
<ul>
<li>可以在类加载的时候去获取类的相关信息（属性、方法、实现的接口、继承的类）</li>
<li>反射可以通过字节码的方式来创建实例</li>
</ul>
<p><strong>反射在以后开发中的作用</strong>：</p>
<p>​		我们设计程序最终是要提高程序的执行效率，我们在开发一个模块的时候，要不停的去创建对象 <code>User user = new User();</code> 使用<strong>new</strong>关键字，会使得程序之间产生耦合，以后new关键字使用多了，耦合就会变高，程序的执行效率就会很差</p>
<p>​		这个时候我们能不能换一种方式去创建实例，尽量避免使用new关键字，反射机制就可以在<strong>不使用</strong>new的情况下去创建实例</p>
<p>​		反射是各大java框架的<strong>底层</strong>：框架就是帮助程序解耦，提高程序的执行效率，提高开发人员的开发效率</p>
<p>spring  框架：容器</p>
<ul>
<li>通过java语言中的反射机制可以操作字节码文件</li>
<li>通过反射机制可以操作代码片段</li>
<li><code>java.lang.reflect</code></li>
</ul>
<p><strong>什么是反射</strong>：</p>
<p>​		反射是java中比较偏底层的一种机制，通过反射可以在类加载时去获取类相关的信息</p>
<h2 id="如何去获取一个类的字节码对象（Class）"><a href="#如何去获取一个类的字节码对象（Class）" class="headerlink" title="如何去获取一个类的字节码对象（Class）"></a>如何去获取一个类的字节码对象（Class）</h2><p>​	<code>对象.getClass()</code></p>
<p>​	<code>类.class属性</code></p>
<p>​	<code>Class.forName(&quot;全类名&quot;)</code></p>
<ul>
<li><p><strong><code>java.lang.Class：</code></strong> </p>
<p>代表整个字节码，代表一个类型，代表整个<strong>类</strong></p>
</li>
<li><p><strong><code>java.lang.reflect.Method</code>：</strong></p>
<p>代表字节码中的方法字节码，代表类中的<strong>方法</strong></p>
</li>
<li><p><strong><code>java.lang.reflect.Constructor：</code></strong></p>
<p>代表字节码中的<strong>构造方法</strong>字节码，代表类中的构造方法</p>
</li>
<li><p><strong><code>java.lang.reflect.Field：</code></strong></p>
<p>代表字节码中的<strong>属性</strong>字节码，代表类中的成员变量（静态变量+实例变量）</p>
</li>
</ul>
<h2 id="获取类中的属性"><a href="#获取类中的属性" class="headerlink" title="获取类中的属性"></a>获取类中的属性</h2><h3 id="获取类中公共的属性"><a href="#获取类中公共的属性" class="headerlink" title="获取类中公共的属性"></a>获取类中公共的属性</h3><p><code>getField()</code></p>
<pre><code class="java">//获取字节码对象
 Class stuClass = Class.forName(&quot;com.os467.pojo.Student&quot;);

 //getField()这个方法只能去获取公共的属性
 Field address = stuClass.getField(&quot;address&quot;);

 System.out.println(address);
</code></pre>
<h3 id="获取类中所有的属性"><a href="#获取类中所有的属性" class="headerlink" title="获取类中所有的属性"></a>获取类中所有的属性</h3><p><code>getDeclaredField()</code></p>
<pre><code class="java">//getDeclaredField()这个方法可以去获取一个类中所有的属性
Field id = stuClass.getDeclaredField(&quot;id&quot;);

System.out.println(id);
</code></pre>
<p><code>getDeclaredFields()</code></p>
<pre><code class="java">//获取一个类中所有属性，封装成字节码数组
Field[] declaredFields = stuClass.getDeclaredFields();
</code></pre>
<p><strong>获取全类名</strong></p>
<pre><code class="java">String name = stuClass.getName();
</code></pre>
<p><strong>获取简类名</strong></p>
<pre><code class="java">String simpleName = stuClass.getSimpleName();
</code></pre>
<p><strong>获取属性的类型</strong></p>
<p><code>declaredField.getType()</code></p>
<p><strong>获取属性的修饰符</strong></p>
<pre><code class="java">//获取属性的修饰符代号
int modifiers = declaredField.getModifiers();

//将代号转成修饰符字符串
String string = Modifier.toSring(modifiers);

System.out.println(string);
</code></pre>
<p>在学习反射时，获取类的<strong>信息</strong>都是通过<strong>get方法</strong>去获取的</p>
<h2 id="获取类中的方法"><a href="#获取类中的方法" class="headerlink" title="获取类中的方法"></a><strong>获取类中的方法</strong></h2><p>由于java类中的方法支持重载，所以在调用<code>getMethod(方法名称,参数类型)</code>方法时需要将方法的<strong>参数类型</strong>传入，不传入则默认获取<strong>无参</strong>的方法</p>
<h3 id="获取类中公有的方法"><a href="#获取类中公有的方法" class="headerlink" title="获取类中公有的方法"></a>获取类中公有的方法</h3><pre><code class="java">public class ReflectDemo03 &#123;

    public static void main(String[] args) throws Exception &#123;

        //获取字节码对象
        Class stuClass = Student.class;

        //获取一个类中的方法
        Method setAge = stuClass.getMethod(&quot;setAge&quot;,Integer.class);

        System.out.println(setAge);

        Method study = stuClass.getMethod(&quot;study&quot;, int.class, double.class, String.class);

        System.out.println(study);

    &#125;
&#125;
</code></pre>
<h3 id="获取类中所有的方法"><a href="#获取类中所有的方法" class="headerlink" title="获取类中所有的方法"></a>获取类中所有的方法</h3><pre><code class="java">public class ReflectDemo03 &#123;

    public static void main(String[] args) throws Exception &#123;

        //获取字节码对象
        Class stuClass = Student.class;

        //获取一个类中所有的方法
        Method[] declaredMethods = stuClass.getDeclaredMethods();

        for (Method declaredMethod : declaredMethods) &#123;

            System.out.println(declaredMethod);

        &#125;

    &#125;
&#125;
</code></pre>
<p><strong>其它的方法</strong></p>
<pre><code class="java">for (Method method : declaredMethods) &#123;

    //获取方法名称
    System.out.println(&quot;方法名称&quot;+method.getName());

    //获取方法返回值类型
    System.out.println(&quot;返回值类型&quot;+method.getReturnType().getSimpleName());

    //获取方法的参数
    for (Class&lt;?&gt; parameterType : method.getParameterTypes()) &#123;

        System.out.println(&quot;方法的参数类型&quot;+parameterType);


    &#125;

    //获取修饰符
    int modifiers = method.getModifiers();

    //将修饰符代号转成字符串
    String s = Modifier.toString(modifiers);

    System.out.println(&quot;修饰符&quot;+s);

&#125;
</code></pre>
<h3 id="获取所有的构造"><a href="#获取所有的构造" class="headerlink" title="获取所有的构造"></a>获取所有的构造</h3><pre><code class="java">public static void main(String[] args) throws Exception &#123;


    //获取字节码对象
    Class aClass = Class.forName(&quot;com.os467.pojo.Student&quot;);

    //获取所有的构造
    Constructor[] declaredConstructors = aClass.getDeclaredConstructors();

    //遍历数组
    for (Constructor declaredConstructor : declaredConstructors) &#123;

        System.out.println(declaredConstructor);

    &#125;

&#125;
</code></pre>
<h2 id="反射工具类ReflectUtils"><a href="#反射工具类ReflectUtils" class="headerlink" title="反射工具类ReflectUtils"></a>反射工具类ReflectUtils</h2><p>写一个工具类，写一个静态方法，方法传入一个类的全类名，然后反编译（可以获取这个类中所有的信息）这个类工具类要适用于所有的类</p>
<p><strong>根据反射获取类的信息</strong></p>
<ul>
<li>1、根据流对象先读取配置文件中的全类名数据</li>
<li>2、根据全类名创建字节码对象</li>
<li>3、根据字节码对象去获取类的信息，完成类的反编译</li>
</ul>
<pre><code class="java">package com.os467.utils;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Properties;

/**
 * 反编译工具类
 */
public class ReflectUtils &#123;

    //构造私有化
    private ReflectUtils()&#123;

    &#125;

    /**
     * 根据反射获取类的信息
     * 1、根据流对象先读取配置文件中的全类名数据
     * 2、根据全类名创建字节码对象
     * 3、根据字节码对象去获取类的信息，完成类的反编译
     * @return
     */
    public static String getTypeMessageByReflect()&#123;

        //用于字符串的追加,效率要比String高
        StringBuilder stringBuilder = new StringBuilder();

        try &#123;

            //创建流对象
            FileReader fileReader = new FileReader(&quot;className.properties&quot;);

            //创建集合对象
            Properties properties = new Properties();

            //将配置文件中的数据装载到集合里面
            properties.load(fileReader);

            //根据全类名创建字节码对象
            Class aClass = Class.forName(properties.getProperty(&quot;className&quot;));

            stringBuilder.append(&quot;public class &quot;);
            stringBuilder.append(aClass.getSimpleName()+&quot; &#123; \n&quot;);
            //获取类中所有的属性
            Field[] declaredFields = aClass.getDeclaredFields();

            for (Field declaredField : declaredFields) &#123;

                stringBuilder.append(&quot;\n\t&quot;);

                //获取属性的修饰符
                int modifiers = declaredField.getModifiers();

                //转成修饰符字符串
                String s = Modifier.toString(modifiers);

                //获取属性类型
                String simpleName = declaredField.getType().getSimpleName();

                //获取属性的名称
                String name = declaredField.getName();

                stringBuilder.append(s+&quot; &quot;+simpleName+&quot; &quot;+name+&quot;;&quot;);
                stringBuilder.append(&quot;\n&quot;);

            &#125;

            //获取类的所有构造
            Constructor[] declaredConstructors = aClass.getDeclaredConstructors();

            //遍历数组
            for (Constructor declaredConstructor : declaredConstructors) &#123;

                stringBuilder.append(&quot;\n\t&quot;);

                //获取构造的修饰符
                int modifiers = declaredConstructor.getModifiers();

                //转成修饰符字符串
                String s = Modifier.toString(modifiers);

                //获取构造名称
                String name = aClass.getSimpleName();

                stringBuilder.append(s + &quot; &quot; + name + &quot;(&quot;);

                //获取参数列表
                Class[] parameterTypes = declaredConstructor.getParameterTypes();

                //遍历参数列表
                for (Class parameterType : parameterTypes) &#123;

                    //获取参数名
                    stringBuilder.append(parameterType.getSimpleName()+&quot;,&quot;);

                &#125;

                //判断有参的还是无参的
                if (parameterTypes.length &gt; 0)&#123;

                    //删除具体下标下面的字符
                    stringBuilder.deleteCharAt(stringBuilder.length() - 1);

                &#125;

                stringBuilder.append(&quot;) &#123;&#125;&quot;);

                stringBuilder.append(&quot;\n&quot;);

                //获取所有的普通方法
                Method[] declaredMethods = aClass.getDeclaredMethods();

                //遍历数组
                for (Method declaredMethod : declaredMethods) &#123;

                    stringBuilder.append(&quot;\n\t&quot;);

                    //获取方法的修饰符
                    int modifiers1 = declaredMethod.getModifiers();

                    //转成修饰符字符串
                    String s1 = Modifier.toString(modifiers1);

                    //获取返回值类型
                    String simpleName = declaredMethod.getReturnType().getSimpleName();

                    stringBuilder.append(s1 + &quot; &quot; +simpleName + &quot; &quot; + declaredMethod.getName()+&quot;(&quot;);

                    //获取普通方法的参数列表
                    Class[] parameterTypes1 = declaredMethod.getParameterTypes();

                    //遍历参数
                    for (Class parameterType : parameterTypes1) &#123;

                        stringBuilder.append(parameterType.getSimpleName()+&quot;,&quot;);

                        if (parameterTypes.length &gt; 0)&#123;

                            //删除最后一个逗号
                            stringBuilder.deleteCharAt(stringBuilder.length() - 1);

                        &#125;

                    &#125;
                    stringBuilder.append(&quot;)&#123;&#125;&quot;);

                    stringBuilder.append(&quot;\n&quot;);

                &#125;

            &#125;

            stringBuilder.append(&quot;\n&#125;&quot;);

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;


        return stringBuilder.toString();
    &#125;


&#125;
</code></pre>
<p><strong>反射</strong></p>
<ul>
<li>通过反射机制访问对象的某个属性</li>
<li>通过反射机制调用对象的某个方法</li>
<li>通过反射机制调用某个构造方法实例化对象</li>
<li>通过反射机制获取父类及父类型接口</li>
</ul>
<p>获取父类</p>
<pre><code class="java">Class superclass = aClass.getSuperclass();
</code></pre>
<p>获取实现的接口</p>
<pre><code class="java">Class[] interfaces = aClass.getInterfaces();
</code></pre>
<h2 id="如何通过反射机制来创建一个类的实例"><a href="#如何通过反射机制来创建一个类的实例" class="headerlink" title="如何通过反射机制来创建一个类的实例"></a>如何通过反射机制来创建一个类的实例</h2><p><strong>无参构造实例</strong></p>
<p><strong><code>newInstance()</code></strong></p>
<pre><code class="java"> //获取字节码对象
Class aClass = Student.class;

//如何通过反射机制来创建一个类的实例
//默认情况下调用的是无参构造
Object o = aClass.newInstance();

if (o instanceof Student)&#123;

    Student student = (Student)o;

    System.out.println(student);

&#125;
</code></pre>
<p><strong>有参构造实例</strong></p>
<p><code>getDeclaredConstructor()</code>	不传参数就是获取无参构造实例</p>
<pre><code class="java">public static void main(String[] args) throws Exception &#123;

    //创建字节码对象
    Class aClass = User.class;

    //获取构造字节码对象
    Constructor constructor = aClass.getDeclaredConstructor(String.class,String.class);

    Object obj02 = constructor.newInstance(&quot;root&quot;, &quot;123456&quot;);

    System.out.println(obj02);
    
&#125;
</code></pre>
<h3 id="如何通过反射来给属性赋值"><a href="#如何通过反射来给属性赋值" class="headerlink" title="如何通过反射来给属性赋值"></a>如何通过反射来给属性赋值</h3><pre><code class="java">//获取属性，返回属性字节码对象
Field addressFiled = aClass.getDeclaredField(&quot;address&quot;);

//给属性进行一个赋值操作
//Object obj 属性所在类的实例
//Object value 具体要赋的值
addressFiled.set(o,&quot;南京市&quot;);

//通过反射获取属性具体的值
System.out.println(addressFiled.get(o));

System.out.println(o);
</code></pre>
<h3 id="如何通过反射获取属性值"><a href="#如何通过反射获取属性值" class="headerlink" title="如何通过反射获取属性值"></a>如何通过反射获取属性值</h3><p><strong>方法一</strong>：</p>
<p>先打破封装，再通过set方法给属性赋值</p>
<pre><code class="java">//获取属性字节码对象
Field declaredFieldName = aClass.getDeclaredField(&quot;name&quot;);

//打破封装
declaredFieldName.setAccessible(true);

//通过反射机制来创建一个类的实例
//采用的无参构造创建的实例
Object o = aClass.newInstance();

//调用set方法给属性赋值
declaredFieldName.set(o,&quot;张三&quot;);

System.out.println(o);
</code></pre>
<p><strong>方法二</strong>：</p>
<p>通过反射调用这个<strong>属性</strong>所对应的set方法给属性赋值</p>
<h2 id="通过反射调用类中的方法"><a href="#通过反射调用类中的方法" class="headerlink" title="通过反射调用类中的方法"></a>通过反射调用类中的方法</h2><pre><code class="java">public static void main(String[] args) throws Exception &#123;

    //获取字节码对象
    Class userClass = User.class;

    //获取方法字节码对象
    Method declaredMethod = userClass.getDeclaredMethod(&quot;login&quot;,String.class,String.class);

    //通过反射创建实例
    Object o = userClass.newInstance();

    //调用方法
    //通过反射调用方法的方法
    //Object var1 当前方法所在类的实例
    //Object... var2 你需要传的参数
    Object invoke = declaredMethod.invoke(o, &quot;zs001&quot;, &quot;123456&quot;);

    System.out.println(invoke);


&#125;
</code></pre>
<p><strong>注意</strong>：操作私有的方法需要打破封装</p>
<pre><code class="java">declaredMethod.setAccessible(true);
</code></pre>
<h4 id="反射在以后的用途"><a href="#反射在以后的用途" class="headerlink" title="反射在以后的用途"></a>反射在以后的用途</h4><p>反射最重要的用途就是开发各种通用框架，比如在spring中，我们将所有的类Bean交给spring容器管理，无论是XML配置Bean还是注解配置，当我们从容器中获取Bean来依赖注入时，容器会读取配置，而配置中给的就是类的信息，spring根据这些信息，需要创建那些Bean，spring就动态的创建这些类，还有在struts2的struts.xml中配置action，也是通过反射调用的action</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/13/Reflect/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/12/多线程/">
        <h2>
            多线程
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/12
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><ul>
<li><p>进程:是操作系统中一个程序及其数据在处理机上顺序执行时所发生的活动</p>
</li>
<li><p>线程:也成轻量进程，是进程中某个<strong>单一顺序</strong>的控制流（进程中的某一新单元）</p>
</li>
<li><p>多进程:在<strong>操作系统</strong>中同时运行多个任务(程序)</p>
</li>
<li><p>多线程:在同一应用<strong>程序</strong>中有多个顺序流同时执行</p>
</li>
<li><p>线程的生命周期:一个线程从创建到执行完的整个过程</p>
</li>
</ul>
<p><strong>线程与进程的区别</strong>：</p>
<p>​		进程对应的是一个服务，线程是进程中的执行单元</p>
<p>​		一个进程可以包含多个线程，一个线程一定属于某个进程</p>
<p>​		多线程特点：线程是<strong>异步</strong>的，线程是<strong>并发</strong>的，多个线程同时工作，线程与线程之间是互不干扰的</p>
<p>​		例子：火车站（进程）和售票窗口（线程）火车站 的关系</p>
<h2 id="关于线程的创建方式"><a href="#关于线程的创建方式" class="headerlink" title="关于线程的创建方式"></a>关于线程的创建方式</h2><p><strong>三种方法</strong>：</p>
<ul>
<li><p>继承Thread类</p>
</li>
<li><p>实现Runnable接口 &#x2F; 通过匿名内部类来创建线程对象</p>
</li>
<li><p>使用Callable结合Task实现多线程</p>
</li>
</ul>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p><strong>方法一</strong>：继承<strong>Thread</strong>类，重写<code>run()</code>方法</p>
<pre><code class="java">package com.os467.thread;

public class ThreadDemo01 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象
        ThreadImpl01 threadImpl01 = new ThreadImpl01();
        ThreadImpl01 threadImpl02 = new ThreadImpl01();

        //开启线程
        threadImpl01.start();
        threadImpl02.start();

    &#125;

&#125;


class ThreadImpl01 extends Thread&#123;

    /**
     * 让程序跑起来的方法
     */
    @Override
    public void run() &#123;

        for (int i = 0; i &lt; 10; i++) &#123;

            System.out.println(&quot;第&quot;+(i + 1)+&quot;个数为&quot;+i);

        &#125;


    &#125;
&#125;
</code></pre>
<h4 id="设置线程的名称"><a href="#设置线程的名称" class="headerlink" title="设置线程的名称"></a>设置线程的名称</h4><pre><code class="java">//设置线程的名称
threadImpl01.setName(&quot;t1&quot;);
threadImpl02.setName(&quot;t2&quot;);
</code></pre>
<p><strong>获取当前正在运行的线程</strong></p>
<pre><code class="java">class ThreadImpl01 extends Thread&#123;

     //获取当前正在运行的线程
    Thread thread = Thread.currentThread(); 
    
    System.out.println(thread.getName()+&quot;正在执行&quot;);

&#125;
</code></pre>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p><strong>方法二</strong>：实现一个Runnable接口</p>
<p>此方法的实现类只是一个<strong>可运行类</strong>，不能被称为线程类</p>
<pre><code class="java">package com.os467.thread;

public class ThreadDemo02 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象
        RunnableImpl02 runnableImpl02 = new RunnableImpl02();

        //创建线程类
        Thread thread1 = new Thread(runnableImpl02);

        Thread thread2 = new Thread(runnableImpl02);


        //设置线程名称
        thread1.setName(&quot;t1&quot;);

        //设置线程名称
        thread2.setName(&quot;t2&quot;);

        //开启线程
        thread1.start();

        //开启线程
        thread2.start();


    &#125;

&#125;

/**
 * 可运行类
 */
class RunnableImpl02 implements Runnable&#123;


    @Override
    public void run() &#123;

        for (int i = 0; i &lt; 10; i++) &#123;

            //获取当前正在运行的线程
            Thread thread = Thread.currentThread();

            System.out.println(thread.getName()+&quot;正在执行：&quot;+(i + 1)+&quot;个数为&quot;+i);

        &#125;

    &#125;

&#125;
</code></pre>
<h3 id="通过匿名内部类来创建线程对象"><a href="#通过匿名内部类来创建线程对象" class="headerlink" title="通过匿名内部类来创建线程对象"></a>通过匿名内部类来创建线程对象</h3><pre><code class="java">package com.os467.thread;

public class ThreadDemo03 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象
        Thread thread1 = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;

                for (int i = 0; i &lt; 10; i++) &#123;

                    System.out.println(Thread.currentThread().getName()+&quot; : &quot;+i);

                &#125;

            &#125;
        &#125;);

        //创建线程对象
        Thread thread2 = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;

                for (int i = 0; i &lt; 10; i++) &#123;

                    System.out.println(Thread.currentThread().getName()+&quot; : &quot;+i);

                &#125;

            &#125;
        &#125;);

        thread1.setName(&quot;t1&quot;);
        thread2.setName(&quot;t2&quot;);

        //开启线程
        thread1.start();
        thread2.start();

    &#125;

&#125;
</code></pre>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul>
<li><p>新建状态</p>
<p>​	创建出线程对象之后，线程就处于新建状态</p>
</li>
<li><p>就绪状态</p>
</li>
</ul>
<p>​			当一个线程调用了<code>start()</code>方法之后，该线程处于就绪状态，处于就绪状态的线程拥有争夺CPU资源的使用权力</p>
<ul>
<li>运行状态</li>
</ul>
<p>​			当一个线程<strong>争夺到了CPU使用权</strong>之后，就回去执行线程，运行run方法，这个时候的线程处于运行状态</p>
<ul>
<li>阻塞状态</li>
</ul>
<p>​			当线程在运行的过程中出现了控制台打印、睡眠sleep等需要等待的操作，这个时候线程会处于阻塞状态，处于阻塞状态的线程，会释放CPU使用权</p>
<ul>
<li>死亡状态</li>
</ul>
<p>​			当一个线程执行完run方法中所有的代码就会跳出run方法，这个时候线程处于死亡状态   <code>isAlive()方法</code>可以判断线程是否存活</p>
<pre><code class="java">package com.os467.thread;

public class ThreadDemo04 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象,该线程处于新建状态
        ThreadImpl02 threadImpl01 = new ThreadImpl02();
        ThreadImpl02 threadImpl02 = new ThreadImpl02();

        threadImpl01.setName(&quot;t1&quot;);
        threadImpl02.setName(&quot;t2&quot;);

        //该线程处于就绪状态
        threadImpl01.start();
        threadImpl02.start();

    &#125;

&#125;


class ThreadImpl02 extends Thread&#123;

    @Override
    public void run() &#123;//当某一个线程争夺到cpu使用权后才会进入run方法

        for (int i = 0; i &lt; 10; i++) &#123;

            System.out.println(Thread.currentThread().getName() + &quot;======&gt;&quot;+i);

            //睡眠的方法，可以让程序处于阻塞状态
            try &#123;
                Thread.sleep(500);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;

    &#125;

    //当某一线程执行完了run方法，那该线程处于死亡状态
&#125;
</code></pre>
<p><strong>Run方法和start方法的区别</strong></p>
<p>Run是执行方法，start是启动方法</p>
<p>start启动不一定执行run方法</p>
<p><strong>线程调度模型</strong></p>
<ul>
<li>抢占式调度模式</li>
</ul>
<p>​		哪个线程的优先级比较高，抢到的CPU时间片的概率就多一些，java采用的就是抢占式调度模型			</p>
<ul>
<li>均分式调度模型</li>
</ul>
<p>​		平均分配CPU时间片，每个线程占用的CPU时间片时间长度一样，平均分配，一切平等，有一些编程语言，线程调度模型采用		的是这种方式</p>
<p>使用哪种方式<strong>创建线程</strong>比较好？</p>
<p>​		实现runnable接口，因为我们以后是面向接口开发</p>
<p>​		因为如果继承了Thread类，那么类的可扩展性就降低了</p>
<p>​		以后我们在写程序，尽量使用Runnable接口方式来创建线程对象，面向接口开发，程序的可扩展性会提高</p>
<p><strong>问题</strong>:以下代码一共开启了<strong>几个</strong>线程？</p>
<pre><code class="java">package com.os467.thread;

public class ThreadDemo05 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象
        Thread thread1 = new Thread(new MyRunnable());
        Thread thread2 = new Thread(new MyRunnable());
        Thread thread3 = new Thread(new MyRunnable());

        thread1.setName(&quot;t1&quot;);
        thread3.setName(&quot;t3&quot;);

        thread1.start();
        thread2.run();
        thread3.start();

        for (int i = 0; i &lt; 10; i++) &#123;

            System.out.println(Thread.currentThread().getName() + &quot; ==&gt; &quot;+i);

        &#125;

    &#125;


&#125;


class MyRunnable implements Runnable&#123;

    @Override
    public void run() &#123;


        for (int i = 0; i &lt; 10; i++) &#123;

            System.out.println(Thread.currentThread().getName() + &quot; ==&gt; &quot;+i);

        &#125;

        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;


    &#125;


&#125;
</code></pre>
<p><strong>答案</strong>:一共开启了4个线程：</p>
<p>​		两个普通线程	调用了<code>start()</code>方法</p>
<p>​		守护线程（后台线程）：垃圾回收线程</p>
<p>​		主线程（<code>main线程</code>）：JVM调用主函数</p>
<h4 id="线程在内存上的分布，以及执行流程"><a href="#线程在内存上的分布，以及执行流程" class="headerlink" title="线程在内存上的分布，以及执行流程"></a>线程在内存上的分布，以及执行流程</h4><ul>
<li>​		每一个线程都会去对应一个栈，创建的每个线程，JVM都会去开辟出一个分支栈</li>
<li>​		main中 针对于某个线程调用了start方法，这个时候，JVM会为这个线程单独的开辟出一个分支栈</li>
<li>​		假如程序中开启了t1、t2、t3 三个线程，<strong>栈与栈之间的资源是不共享的</strong></li>
<li>​		比如 t1对应的分支栈声明了一个集合对象List，这个集合的引用在别的栈是访问不到的</li>
</ul>
<p>在主线程调用了start方法之后，会开辟分支栈，每个栈都会去执行不同的任务，栈与栈之间的资源是不共享的</p>
<p>堆的资源是共享的，因为JVM上只有一个堆，只要你去创建引用数据类型的实例，都是在堆中开辟空间</p>
<p>方法区中的资源也是共享的，因为内存中只能有一个方法区</p>
<p><strong>获取、设置线程优先级方法</strong></p>
<pre><code class="java">//获取某个线程的优先级,java默认情况下线程优先级是5
int priority1 = thread1.getPriority();
</code></pre>
<pre><code class="java">//设置线程优先级方法，1-10，1优先级最低，10最高
thread1.setPriority(1);
</code></pre>
<h4 id="yield-让位方法"><a href="#yield-让位方法" class="headerlink" title="yield()让位方法"></a>yield()让位方法</h4><p>暂停当前正在执行的线程对象，并执行其他线程</p>
<p><code>yield()</code>方法的执行会让当前线程从”运行状态”回到”就绪状态”</p>
<p><code>Thread.yield();</code></p>
<h2 id="多线程其它方法"><a href="#多线程其它方法" class="headerlink" title="多线程其它方法"></a>多线程其它方法</h2><h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h4><p><code>join()</code>当前线程进入阻塞，指定线程执行，直到指定<strong>线程结束</strong>当前线程才可以继续</p>
<p>线程a{</p>
<p>​		线程b.join()</p>
<p>}</p>
<p>将线程b合并入线程a，线程a等待线程b<strong>结束</strong>后才继续运行</p>
<p><strong>注意</strong>：线程合并必须要有两个不同的线程</p>
<hr>
<p><code>suspend()</code>线程自己把自己挂起</p>
<p><code>resume</code>线程自己把自己唤醒</p>
<p><strong>龟兔赛跑案例</strong></p>
<p>兔子线程类</p>
<pre><code class="java">package com.os467.game;

//兔子线程
public class Rabbit extends Thread &#123;

    private String name;

    public Rabbit(String name) &#123;
        //给当前的线程实例设置名称
        super(name);
        this.name = name;
    &#125;


    @Override
    public void run() &#123;

        //模拟整个赛道跑步的过程
        for (int i = 0; i &lt;= 900; i+=100) &#123;

            if(i == 800)&#123;

                System.out.println(Thread.currentThread().getName()+&quot;开始睡觉&quot;);

                //自己把自己挂起
                Thread.currentThread().suspend();

            &#125;

            System.out.println(Thread.currentThread().getName() + &quot;跑了&quot;+(i+100)+&quot;米&quot;);

            try&#123;

                //模拟睡眠
                Thread.sleep(1000);


            &#125;catch (Exception e)&#123;

                e.printStackTrace();

            &#125;

        &#125;


        System.out.println(Thread.currentThread().getName()+&quot;跑完了全程,最终比赛失败&quot;);

    &#125;

&#125;
</code></pre>
<p>乌龟线程类</p>
<pre><code class="java">package com.os467.game;

//乌龟线程类
public class Tortoise extends Thread &#123;

    private String name;

    //兔子的引用
    private Rabbit rabbit;

    public Tortoise(String name, Rabbit rabbit) &#123;
        //给当前的线程实例设置名称
        super(name);
        this.name = name;
        this.rabbit = rabbit;
    &#125;

    //唤醒兔子的方法
    public void resumeRabbit()&#123;

        System.out.println(Thread.currentThread().getName()+&quot; 唤醒了 &quot;+rabbit.getName());

        //调用唤醒的方法
        this.rabbit.resume();

    &#125;

    @Override
    public void run() &#123;

        //模拟整个赛道跑步的过程
        for (int i = 0; i &lt;= 950; i+=50) &#123;

            System.out.println(Thread.currentThread().getName() + &quot;跑了&quot;+(i+50)+&quot;米&quot;);

            try&#123;

                //模拟睡眠
                Thread.sleep(1000);


            &#125;catch (Exception e)&#123;

                e.printStackTrace();

            &#125;

        &#125;

        //乌龟唤醒兔子
        this.resumeRabbit();

        System.out.println(Thread.currentThread().getName()+&quot;跑完了全程,取得了胜利&quot;);

    &#125;
&#125;
</code></pre>
<p>测试类</p>
<pre><code class="java">package com.os467.game;

public class Test &#123;

    public static void main(String[] args) &#123;

        //创建兔子线程
        Rabbit rabbit = new Rabbit(&quot;兔子&quot;);

        //创建乌龟线程
        Tortoise tortoise = new Tortoise(&quot;乌龟&quot;,rabbit);

        //开启线程
        rabbit.start();
        tortoise.start();

    &#125;

&#125;
</code></pre>
<hr>
<p>&#x2F;&#x2F;<code>tl.stop()</code>中断线程</p>
<p>&#x2F;&#x2F;<code>interrupt</code>中断睡眠</p>
<p>&#x2F;&#x2F;<code>tl.isAlive()</code>判断指定线程是否处于活动状态</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ul>
<li>java语言中线程分为两大类</li>
</ul>
<p>用户线程</p>
<p>守护线程（后台线程）</p>
<ul>
<li>守护线程的特点</li>
</ul>
<p>一般守护线程是一个死循环，所有的用户线程只要结束，守护线程自动结束</p>
<p>守护线程一般指的是后台线程，守护线程一般会去守护一个用户线程，用户线程启动，守护线程随之启动，用户线程结束，守护线程也结束，例如垃圾回收线程</p>
<p>设置守护线程<strong>方法</strong>:<code>普通线程对象.setDaemon(true)</code></p>
<pre><code class="java">package com.os467;

public class ThreadDemo01 &#123;

    public static void main(String[] args) &#123;

        //创建线程对象
        Thread t1 = new Thread(new createThread());

        //将一个普通线程设置为守护线程
        t1.setDaemon(true);

        //开启线程
        t1.start();

        for (int i = 0; i &lt; 10; i++) &#123;

            System.out.println(Thread.currentThread().getName()+&quot; ===&gt; &quot;+i);

            try &#123;
                Thread.sleep(500);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;

    &#125;

&#125;

class createThread implements Runnable&#123;


    @Override
    public void run() &#123;

        //守护线程一般就是一个死循环
        while (true)&#123;

            System.out.println(&quot;守护线程正在执行&quot;);

            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>定时器</strong></p>
<ul>
<li>定时器的作用：间隔特定的时间，执行特定的程序</li>
</ul>
<p>​	在java的类库中已经写好了一个定时器：<code>java.util.Timer</code></p>
<h3 id="实现线程的第三种方式（Callable结合Task）"><a href="#实现线程的第三种方式（Callable结合Task）" class="headerlink" title="实现线程的第三种方式（Callable结合Task）"></a>实现线程的第三种方式（Callable结合Task）</h3><ul>
<li>使用Callable结合Task实现多线程编程</li>
</ul>
<p><code>FutureTask futureTask = new FutureTask(new Callable())</code></p>
<pre><code class="java">public class ThreadDemo02 &#123;

    public static void main(String[] args) &#123;

        //这个类官方称之为未来任务类，不是线程类
        FutureTask futureTask = new FutureTask(new Callable() &#123;

            //作用类似于run方法
            @Override
            public Object call() throws Exception &#123;

                int num = 0;

                for (int i = 0; i &lt; 10; i++) &#123;

                    num += i;

                    System.out.println(Thread.currentThread().getName() + &quot;===&gt;&quot; + i);

                    Thread.sleep(500);

                &#125;

                return num;

            &#125;
        &#125;);

        //创建线程对象
        Thread thread = new Thread(futureTask);

        //设置线程名称
        thread.setName(&quot;t1&quot;);

        //开启线程
        thread.start();

        //线程结束之后获取线程的返回值
        try &#123;

            Object o = futureTask.get();

            System.out.println(&quot;最终累加的结果为:&quot;+o);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; catch (ExecutionException e) &#123;
            e.printStackTrace();
        &#125;



    &#125;

&#125;
</code></pre>
<p><strong>缺点</strong>：由于需要获取返回值，此方法会造成原线程的阻塞</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li><strong>异步编程模型</strong></li>
</ul>
<p>​		线程A和线程B,各自执行各自的，A不管B，B不管A，谁也不需要等谁，这种编程模型叫做:异步编程模型，其实就是：多线程<strong>并发</strong>，效率较高</p>
<ul>
<li><strong>同步编程模型</strong></li>
</ul>
<p>​		线程A和线程B，在线程A执行的时候，必须等待B线程执行结束，或者说在A线程执行的时候，必须等待B线程执行结束，两个线程之间发生了等待关系，这就是同步程模型，效率较低</p>
<h2 id="锁池和等待池"><a href="#锁池和等待池" class="headerlink" title="锁池和等待池"></a>锁池和等待池</h2><ul>
<li><p><strong>锁池</strong></p>
<p>​		假设线程A已经拥有了某个<strong>对象</strong>(不是类)的锁，而其它线程B,C想要调用这个对象的某个<strong>synchronized方法</strong>(或者块)之前必须获得该对象锁的<strong>拥有权</strong>，而恰巧该对象的锁目前正被A所<strong>占有</strong>，此时B，C线程就会被<strong>阻塞</strong>，进入一个地方去<strong>等待</strong>锁的释放，这个地方便是该对象的锁池</p>
</li>
<li><p><strong>等待池</strong></p>
</li>
</ul>
<p>​		假设线程A调用了某个对象的<strong>wait方法</strong>，线程A就会<strong>释放</strong>该对象的锁，同时线程A就进入到了该对象的<strong>等待池</strong>中，进入等待池中的线程<strong>不会去竞争</strong>该对象的锁</p>
<h2 id="Object类中的wait和notify方法"><a href="#Object类中的wait和notify方法" class="headerlink" title="Object类中的wait和notify方法"></a>Object类中的wait和notify方法</h2><ul>
<li><code>wait()</code> 让正在该对象上活动的线程进入等待状态，无期限等待，直到被唤醒为止。<code>wait()</code>方法的调用，会让正在改对象的当前线程进入等待状态</li>
</ul>
<p>此对象其实就是多线程中的<strong>共享对象</strong></p>
<p>使用此方法必须保证当前多线程处于<strong>线程同步状态</strong></p>
<p>当共享对象是类的实例的时候，可以直接在类的方法中写<code>wait</code>和<code>notify</code>方法</p>
<p><strong>notify()方法作用</strong></p>
<p>​		只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</p>
<p><strong><code>notifyAll()</code>方法的作用</strong></p>
<p>​		会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会</p>
<p><strong>需求：生产者和消费者关系</strong>：</p>
<p><strong>仓库</strong></p>
<p>仓库里面存放的就是生产者生产出来的商品，需要交给消费者去消费</p>
<p>要保证生产者与消费者均衡的状态：</p>
<p>如果仓库中没有产品了，这个时候消费者线程就不能再进行消费了，需要交给生产者线程去生产，如果仓库已经满了，仓库已经有产品的情况下，生产者线程就不用再生产了，要交由消费者线程去消费</p>
<p>生产者与消费者wait、notify</p>
<p>​		要想使用wait和notify方法，必须是在<strong>线程同步</strong>的前提下</p>
<p><strong>Consumer</strong></p>
<pre><code class="java">package com.os467.wait;

public class Consumer extends Thread &#123;

    private House house;

    public Consumer(String name,House house)&#123;

        super(name);
        this.house = house;

    &#125;

    @Override
    public void run() &#123;

        //模拟一直生产
        while (true) &#123;

            synchronized (this.house) &#123;

                if (this.house.getObjects().size() == 0) &#123;

                    //消费者不能再消费，要让这个消费者处于等待状态
                    try &#123;

                        //让处于该对象上活跃的线程处于等待状态
                        this.house.wait();

                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;

                &#125;

                //仓库中有产品，消费者就要去消费
                Object obj = this.house.getObjects().remove(0);

                System.out.println(Thread.currentThread().getName() + &quot;消费了一个产品，产品实例为&quot; + obj);

                try &#123;
                    //模拟睡眠
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;

                //唤醒生产者去生产
                this.house.notifyAll();

            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>House</strong></p>
<pre><code class="java">package com.os467.wait;

import java.util.List;

//仓库，用于存放产品的
public class House &#123;

    private List&lt;Object&gt; objects;

    public House(List&lt;Object&gt; objects) &#123;
        this.objects = objects;
    &#125;

    public List&lt;Object&gt; getObjects() &#123;
        return objects;
    &#125;

    public void setObjects(List&lt;Object&gt; objects) &#123;
        this.objects = objects;
    &#125;

&#125;
</code></pre>
<p><strong>Producer</strong></p>
<pre><code class="java">package com.os467.wait;

/**
 * 需求：
 *      生产者线程在什么情况下不需要生产产品？
 *      当仓库中的产品满足一定数量之后，就不用再生产了
 *
 *      只要当仓库中有产品，就要交由消费者去消费，消费者消费完了，仓库中没产品了，就继续交由生产者去生产
 */
public class Producer extends Thread &#123;

    //创建仓库的引用
    private House house;

    public Producer(String name,House house)&#123;

        super(name);
        this.house = house;

    &#125;

    @Override
    public void run() &#123;

        //模拟一直生产
        while (true) &#123;

            synchronized (this.house) &#123;

                if (this.house.getObjects().size() &gt; 0) &#123;

                    //生产者不能再生产，要让这个生产者处于等待状态
                    try &#123;

                        //让处于该对象上活跃的线程处于等待状态
                        this.house.wait();

                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;

                &#125;

                //如果仓库中没有产品，生产者要继续生产
                this.house.getObjects().add(new Object());

                System.out.println(Thread.currentThread().getName() + &quot;生产了一个产品，产品实例为&quot; + this.house.getObjects().get(0));

                try &#123;
                    //模拟睡眠
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;

                //唤醒此对象的消费者线程去消费
                this.house.notifyAll();

            &#125;
        &#125;

    &#125;

&#125;
</code></pre>
<p><strong>WaitDemo</strong></p>
<pre><code class="java">package com.os467.wait;

import java.util.ArrayList;

public class WaitDemo &#123;

    public static void main(String[] args) &#123;

        //创建仓库对象
        House house = new House(new ArrayList&lt;&gt;());

        //创建生产者线程
        Producer producer = new Producer(&quot;生产者&quot;,house);

        //创建消费者线程
        Consumer consumer = new Consumer(&quot;消费者&quot;,house);

        //启动线程
        producer.start();
        consumer.start();


    &#125;

&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/12/多线程/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/10/IO流/">
        <h2>
            IO流
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/10
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h2><p><strong>什么是IO流</strong></p>
<p>​	io流就是内存和硬盘上完成对数据的读和写</p>
<p>I：Input</p>
<p>O：Output</p>
<p>通过IO可以完成硬盘文件的读和写</p>
<p>往内存中去，叫做<strong>输入</strong>（Input），或者叫做<strong>读</strong>（Read）</p>
<p>从内存中出来，叫做<strong>输出</strong>（Output），或者叫做<strong>写</strong>（Write）</p>
<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><p><strong>字节和字符</strong>：</p>
<p>​		字节（Byte）是一种计量单位，表示数据量多少，它是计算机信息技术用于计量存储容量的一种计量单位</p>
<p>​		字符就是键盘上所有的符号，包括英文，汉字等</p>
<p>​		针对于每一个字符，都有固定的Ascll码与之对应，<code>!</code>占了一个字节，然后根据字节流读取数据的时候，读取的是<code>!</code>这个字符所对应的AscII码</p>
<p>​		像特殊符号、英文在java中占了一个字节，汉字<code>你</code>在java中占了两个字节</p>
<p>有的流时按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制位</p>
<p>按照字符的方式读取数据的，一次读取一个字符，这种流是为了方便读取普通文本文件而存在的</p>
<ul>
<li><strong>字节流</strong></li>
</ul>
<p>​			字节流在读取数据的时候，会遍历文件中的字符，然后读取的是每个字符所对应的asII码</p>
<p>​			字节流可以读取任意类型的文件（普通文本，视频，录音，图片…）</p>
<ul>
<li><strong>字符流</strong></li>
</ul>
<p>​			在读取数据的时候，就是一个字符一个字符的进行读取，字符流的效率比较高，但是只能读取普通文本</p>
<p><strong>流的分类</strong></p>
<p><strong>java.io.InputStream</strong>		字节输入流</p>
<p>读取硬盘数据到内存</p>
<p><strong>java.io.OutputStream</strong>		字节输出流</p>
<p>存储内存数据到硬盘</p>
<p><strong>java.io.Reader</strong>		字符输入流</p>
<p><strong>java.io.Writer</strong>		字符输出流</p>
<h3 id="流的关闭"><a href="#流的关闭" class="headerlink" title="流的关闭"></a>流的关闭</h3><p>所有的<strong>流</strong>都实现了java.io.Closeable接口，都是可关闭的，都有<code>close()</code>方法</p>
<p>所有的<strong>输出流</strong>都实现了java.io.Flushable接口，都是可刷新的，都有<code>flush()</code>方法 </p>
<h5 id="文件专属流"><a href="#文件专属流" class="headerlink" title="文件专属流"></a>文件专属流</h5><ul>
<li>java.io.FileInputStream</li>
<li>java.io.FileOutputStream</li>
<li>java.io.FileReader</li>
<li>java.io.FileWriter</li>
</ul>
<pre><code class="java">//创建一个字节流对象
FileInputStream fileInputStream = new FileInputStream(&quot;D:\\pythonschool\\PY_lab\\File\\html.txt&quot;);

//调用读取数据的方法,一次读取一个字符
//fileInputStream.read() 这个方法的返回值是指定字符的ascii码，在文件中数据都读取完的情况下会返回-1
int read = fileInputStream.read();

//输出一次读取的字符的Ascii码
System.out.println(read);

//读取数据
int read = fileInputStream.read();

//通过循环的方式来读取数据
do &#123;

    System.out.println(read);

    read = fileInputStream.read();
&#125;while (read !=-1);
</code></pre>
<p><code>fileInputStream.read()</code> 如果传了字符数组，那么返回的是读取的字符个数</p>
<pre><code class="java">//通过字节数组的方式可以一次性读取多个字节
//1、创建一个字节数组
byte[] bytes = new byte[10];

int read = fileInputStream.read(bytes);

//read是读取字符的个数
System.out.println(read);
</code></pre>
<p><strong>FileInputStream这个字节流如何将ascII转成对应的字符</strong></p>
<p>可以根据String这个类来完成</p>
<pre><code class="java">//创建一个String类
//参数：读取数组，读取起始位置，读取字符数量
//默认从0开始读，读取长度为bytes.length
String s = new String(bytes);

System.out.println(s);
</code></pre>
<p><strong>注</strong>：第二次读取会对之前数组中已经存储的数据进行覆盖</p>
<h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><pre><code class="java">package com.os467.io;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class IoTest03 &#123;

    public static void main(String[] args) &#123;

        //创建输入流对象
        FileInputStream fileInputStream = null;

        try &#123;

            fileInputStream = new FileInputStream(&quot;D:\\pythonschool\\PY_lab\\File\\html.txt&quot;);

            //创建字节数组 1kb=1024b
            byte[] bytes = new byte[1024];

            int read = 0;

            //遍历字节数组,读取数据
            while ((read = fileInputStream.read(bytes)) != -1)&#123;

                //根据字符串将读取到的字节转换成字符串,读取到多少个就转换多少个
                System.out.print(new String(bytes,0,read));

            &#125;


        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;

            try &#123;
                //关闭流对象
                fileInputStream.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;

        &#125;

    &#125;




&#125;
</code></pre>
<p><strong>方法2</strong>：只适合小文件</p>
<pre><code class="java">fileInputStream = new FileInputStream(&quot;D:\\pythonschool\\PY_lab\\File\\html.txt&quot;);

//获取指定文件的字节总个数
int available = fileInputStream.available();

byte[] bytes = new byte[available];

int read = fileInputStream.read(bytes);

System.out.println(new String(bytes,0,read));
</code></pre>
<h4 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h4><pre><code class="java">//创建字节输出流
fileOutputStream = new FileOutputStream(&quot;C:\\Users\\tly20\\Desktop\\test.txt&quot;);

//写入数据到硬盘上
fileOutputStream.write(97);

//创建一个字节数组
byte[] bytes = &#123;98,99,100,101&#125;;

fileOutputStream.write(bytes);
</code></pre>
<p><strong>将字符串数据写入</strong></p>
<pre><code class="java">//创建一个字符串
String str = &quot;你好，Tom&quot;;

//将字符串转成对应的字节数组
byte[] bytes1 = str.getBytes();

//写入数据
fileOutputStream.write(bytes1);

//刷新
fileOutputStream.flush();
</code></pre>
<p><strong>开启写入追加(默认是false，覆盖写入)</strong></p>
<pre><code class="java">fileOutputStream = new FileOutputStream(&quot;C:\\Users\\tly20\\Desktop\\test.txt&quot;,true);
</code></pre>
<p><strong>字符输入输出流</strong></p>
<pre><code class="java">package com.os467.io;

import java.io.*;

/**
 * 通过字符输入流和字符输出流来完成一个普通文本文件的拷贝
 */
public class IoTest06 &#123;
    public static void main(String[] args)&#123;

        //文件字符输入流
        FileReader fileReader = null;

        //文件字符输出流
        FileWriter fileWriter = null;


        //创建文件字符输入流
        try &#123;

            //创建文件字符输入流
            fileReader = new FileReader(&quot;C:\\Users\\tly20\\Desktop\\test.txt&quot;);

            fileWriter = new FileWriter(&quot;C:\\Users\\tly20\\Desktop\\test_copy.txt&quot;,true);

            //创建字符数组 一次读取1024字符
            char[] chars = new char[100];

            //读数据
            int readCount = 0;

            //一边读，一边写
            while ((readCount = fileReader.read(chars) )!= -1)&#123;

                //数据的转换
                String str = new String(chars,0,readCount);

                //数据的写入,可以直接写入字符串
                fileWriter.write(str);

            &#125;

            //刷新输出流
            fileWriter.flush();

        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;

            //关闭资源
            if (fileReader != null)&#123;

                try &#123;
                    fileReader.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;

            if (fileWriter != null)&#123;

                try &#123;
                    fileWriter.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;

            &#125;

        &#125;


    &#125;




&#125;
</code></pre>
<p><strong>注意点</strong>：</p>
<ul>
<li>字节流要创建<strong>字节数组</strong>bytes[]接收读取的数据，字符流要创建<strong>字符数组</strong>chars[]接收读取的数据</li>
<li>输入流和输出流在最后都需要通过<code>close()</code>方法<strong>关闭资源</strong></li>
<li>输出流需要通过<code>flush()</code>方法进行<strong>刷新</strong></li>
</ul>
<h5 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h5><ul>
<li>java.io.BufferedReader</li>
<li>java.io.BufferedWriter</li>
<li>java.io.BufferedInputStream</li>
<li>java.io.BufferedOutputStream</li>
</ul>
<p>缓冲流会将字节先写到一个缓冲区中，然后通过<code>flush()</code>或者关闭这个缓冲流来实现将缓冲流中的数据回显</p>
<p><strong>特点</strong>：不需要创建数组</p>
<pre><code class="java">package com.os467.io;

import java.io.*;

/**
 * 缓冲流:
 *      自带缓冲区的流，在一次读取多个字符的时候，可以不用创建数组
 */
public class IoTest08 &#123;
    public static void main(String[] args) throws Exception&#123;

        String readLine = null;

        //创建缓冲流对象
        BufferedReader bufferedReader = new BufferedReader(new FileReader(&quot;C:\\Users\\tly20\\Desktop\\test.txt&quot;));

        //调用读取数据的方法
        //读取一行数据

        while ((readLine = bufferedReader.readLine()) != null)&#123;

            System.out.println(readLine);

        &#125;


        bufferedReader.close();
    &#125;

&#125;
</code></pre>
<h5 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h5><p>可以将字符流转换成字节流，也可以将字节流转换成字符流  InputStreamReader</p>
<p>包装流和节点流： new 流(new 流()) 外层是包装流，里面的是节点流</p>
<p>在关闭流对象的时候，只需要关闭<strong>最外层</strong>的包装流即可</p>
<pre><code class="java">//创建转换流 将字节流转换成字符流
        InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;C:\\Users\\tly20\\Desktop\\test.txt&quot;));

//关闭流的时候只需要关闭最外层的包装流即可
inputStreamReader.close();
</code></pre>
<h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><ul>
<li>java.io.DataInputStream</li>
<li>java.io.DataOutputStream</li>
</ul>
<p>数据流在写入数据到文件中的时候，要根据数据类型来写入，而且写入之后的文件是加密的，是我们看不懂的文件，如果想读取这些数据的话，只能通过数据输入流来读取</p>
<p>数据输入流在读取数据的时候，是要按照写入的顺序来读取，而且需要按照指定的数据类型来读取</p>
<p><strong>存入数据流数据</strong></p>
<pre><code class="java">public static void main(String[] args) throws  Exception &#123;

    //创建一个数据输出流
    DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(&quot;C:\\Users\\tly20\\Desktop\\test_copy.txt&quot;));

    //指定数据
    boolean b = false;
    float f = 10f;
    int i = 20;
    double d = 3.14;
    
    //调用写入的方法
    dataOutputStream.writeBoolean(b);
    dataOutputStream.writeFloat(f);
    dataOutputStream.writeInt(i);
    dataOutputStream.writeDouble(d);
    
    //刷新输出流
    dataOutputStream.flush();
    
    //关闭流
    dataOutputStream.close();
    
&#125;
</code></pre>
<p><strong>按照存储的顺序读取加密数据</strong></p>
<pre><code class="java">public static void main(String[] args) throws  Exception &#123;

    //创建一个数据输出流
    DataInputStream dataInputStream = new DataInputStream(new FileInputStream(&quot;C:\\Users\\tly20\\Desktop\\test_copy.txt&quot;));

    //读取数据要根据写入的顺序来读取
    boolean b = dataInputStream.readBoolean();

    float v = dataInputStream.readFloat();

    int i = dataInputStream.readInt();

    double v1 = dataInputStream.readDouble();

    System.out.println(b);
    System.out.println(v);
    System.out.println(i);
    System.out.println(v1);
    
    dataInputStream.close();


&#125;
</code></pre>
<h5 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h5><ul>
<li>java.io.PrintWriter</li>
<li>java.io.PrintStream</li>
</ul>
<p>默认情况是我们经常使用的控制台打印，我们可以去改变输出流的输出方向</p>
<p>标准输出流的默认输出方向就是控制台</p>
<p><strong>标准输出流以后适用的场景</strong>：</p>
<p>可以去收集日志</p>
<p>比如说程序在某个时间点发生了某某异常，然后可以根据这个流来收集异常信息</p>
<p>或者去收集模块域模块之间的调用次数</p>
<pre><code class="java">//创建输出流对象，使用相对路径
PrintStream printStream = new PrintStream(new FileOutputStream(&quot;data.txt&quot;));

//打印hello world在data.txt文件中
printStream.print(&quot;hello world&quot;);
</code></pre>
<pre><code class="java">//创建输出流对象，不设置路径会默认打印在控制台
PrintStream printStream = System.out;

printStream.print(&quot;Hello world&quot;);
</code></pre>
<pre><code class="java">//设置输出的方向
PrintStream printStream = new PrintStream(new FileOutputStream(&quot;data.txt&quot;));

System.setOut(printStream);

//打印在data.txt中
System.out.println(&quot;hello world&quot;);

//刷新输出流
printStream.flush();

//关闭资源
printStream.close();
</code></pre>
<h5 id="异常日志收集工具类"><a href="#异常日志收集工具类" class="headerlink" title="异常日志收集工具类"></a>异常日志收集工具类</h5><pre><code class="java">package com.os467.utils;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.PrintStream;
import java.text.Format;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 日志收集工具类
 */
public class LoggerUtils &#123;

    private LoggerUtils()&#123;

    &#125;

    /**
     * 收集日志的方法
     * @param message
     */
    public static void logger(String message)&#123;

        PrintStream printStream = null;

        try &#123;

            //创建标准输出流对象
            printStream = new PrintStream(new FileOutputStream(&quot;logger&quot;,true));

            //设置输出路径
            System.setOut(printStream);

            //创建日期对象
            Date date = new Date();

            //创建日期格式化对象
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);

            //将日期转成字符串
            String time = simpleDateFormat.format(date);

            //记录日志
            System.out.println(time +&quot; : &quot;+message );

            //刷新输出流对象
            printStream.flush();

        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;

            if (printStream != null)&#123;

                printStream.close();

            &#125;

        &#125;


    &#125;

&#125;
</code></pre>
<h3 id="对象专属流"><a href="#对象专属流" class="headerlink" title="对象专属流"></a>对象专属流</h3><p>java.io.ObjectInputStream</p>
<p>java.io.ObjectOutput</p>
<p><strong>可序列化接口</strong>：</p>
<p>写入的对象必须实现序列化的<strong>接口</strong><code>Serializable</code></p>
<ul>
<li>对象专属流可以完成在一个内存和硬盘上对java对象进行<strong>序列化</strong>与<strong>反序列化</strong></li>
</ul>
<h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p><strong>序列化</strong>：</p>
<p>​		序列化就是将java对象写入到硬盘上，写入之后的文件也是加密的格式</p>
<p><strong>反序列化</strong>：</p>
<p>​		将文件中我们看不懂的加密数据读取出来，读取的就是java对象</p>
<ul>
<li><p>以后我们搭建的分布式项目，模块与模块间如果想完成数据的传输，需要通过<strong>序列化与反序列化</strong>来完成</p>
</li>
<li><p>序列化java对象的时候，该对象需要去实现一个序列化的接口</p>
</li>
<li><p><code>Serializable</code>序列化接口，这个接口没有任何的方法，只是一个标识性接口</p>
<p>因为我们在执行加载某一个类的时候会生成该类对应的字节码文件，这个时候jvm虚拟机会检查该类是否有<code>Serializable</code>这个接口</p>
<p>如果有，则赋予该类序列化的权限，如果没有则不能进行序列化</p>
</li>
</ul>
<p><strong>对User类的对象进行序列化操作</strong></p>
<pre><code class="java">public static void main(String[] args) throws  Exception &#123;

    //创建输出流对象(序列化对象)
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;users.txt&quot;));

    //创建user对象
    User user = new User();

    //将java对象写到文件中
    objectOutputStream.writeObject(user);

    //刷新输出流
    objectOutputStream.flush();

    //关闭流
    objectOutputStream.close();

&#125;
</code></pre>
<p><strong>对文件中存储的user数据进行反序列化操作</strong></p>
<pre><code class="java">public static void main(String[] args) throws  Exception &#123;

    //创建输入流对象
    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;users.txt&quot;));

    //读取数据
    Object object = objectInputStream.readObject();

    //判断数据类型
    if (object instanceof User)&#123;

        User user = (User)object;

        System.out.println(user);

    &#125;

    //关闭流
    objectInputStream.close();


&#125;
</code></pre>
<p><strong>对多个对象进行序列化与反序列化（通过ArrayList来完成）</strong></p>
<pre><code class="java">序列化多个对象
-----------------------------------------------------------------------------------------
//创建输出流对象(序列化对象)
ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;users.txt&quot;));

//创建user对象
User user1 = new User(1,&quot;张三1&quot;,&quot;男&quot;);
User user2 = new User(2,&quot;张三2&quot;,&quot;男&quot;);
User user3 = new User(3,&quot;张三3&quot;,&quot;男&quot;);
User user4 = new User(4,&quot;张三4&quot;,&quot;男&quot;);

//创建集合对象
ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;();

users.add(user1);
users.add(user2);
users.add(user3);
users.add(user4);

//将java对象写到文件中
objectOutputStream.writeObject(users);

//刷新输出流
objectOutputStream.flush();

//关闭流
objectOutputStream.close();
------------------------------------------------------------------------------------------
反序列化多个对象
------------------------------------------------------------------------------------------
//创建输入流对象
ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;users.txt&quot;));

//用一个数组来接收
ArrayList&lt;User&gt; arrayList = (ArrayList&lt;User&gt;)objectInputStream.readObject();

for (User user : arrayList) &#123;

    System.out.println(user);

&#125;

//关闭流
objectInputStream.close();
</code></pre>
<p><strong>关于序列化版本号的问题</strong>：</p>
<p>如果在反序列化之前修改了类中的代码，在类加载的时候会<strong>重新生成字节码文件</strong>，那么jvm给该类生成的<strong>序列化版本号</strong>就会<strong>改变</strong>，在反序列化时，旧的序列化版本号与新生成的版本号不对应，就无法完成反序列化</p>
<p><strong>解决方案</strong>：</p>
<p>我们可以在类中写死一个序列化版本号</p>
<pre><code class="java">private static final long serialVersionUID = 8683452581122892189L;
</code></pre>
<h4 id="关键字transient"><a href="#关键字transient" class="headerlink" title="关键字transient"></a>关键字transient</h4><p><code>transient</code>可以使得某一属性不参与序列化的操作，在反序列化后会得到null值</p>
<p><strong>JAVA	I&#x2F;O读取文件</strong></p>
<p><strong>读取文本文件</strong></p>
<p><code>new BufferedReader(new InputStreamReader(new FileInputStream(&quot;a.txt&quot;),&quot;UTF-8&quot;))</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/10/IO流/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/07/javaScript/">
        <h2>
            javaScript
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/7
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p><strong>什么是JavaScript？</strong></p>
<ul>
<li><p>JavaScript语言诞生主要是完成页面的数据验证</p>
<p>因此它运行在客户端，需要运行浏览器来解析执行JavaScript代码 ，简称JS</p>
</li>
<li><p>JS是Netscape网景公司的产品，最早取名为LiveScript 为了吸引更多java开发人员，更名为JavaScript，JS是弱类型，Java是强类型</p>
</li>
</ul>
<p><strong>JavaScript和html代码的结合</strong></p>
<ul>
<li>使用script标签来书写JavaScript代码</li>
<li>使用script标签引入单独的JavaScript代码文件</li>
</ul>
<p><strong>JavaScript是运行在客户端的一门编程语言，简称js</strong></p>
<h2 id="js的代码该如何去编写"><a href="#js的代码该如何去编写" class="headerlink" title="js的代码该如何去编写"></a>js的代码该如何去编写</h2><p>​		我们需要结合html来编写js代码：</p>
<p>​		a、在html文件中定义一个<code>&lt;script&gt;&lt;/script&gt;</code>标签，在该标签的内部去写js代码</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;JavaScript&lt;/title&gt;
&lt;/head&gt;

&lt;!--定义一个script去写js代码--&gt;
&lt;script&gt;

    //js中封装的有对应的函数
    alert(&quot;网页弹窗&quot;);

&lt;/script&gt;
&lt;body&gt;



&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>​		b、会声明一个js文件，在js文件中去写js代码，然后通过<code>&lt;script&gt;</code>标签去引入js文件</p>
<pre><code class="html">&lt;!--引入js文件--&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../js/test.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="JavaScript变量"><a href="#JavaScript变量" class="headerlink" title="JavaScript变量"></a>JavaScript变量</h2><ul>
<li>数值类型：number</li>
<li>字符串类型：string</li>
<li>对象类型：object</li>
<li>布尔类型：boolean</li>
<li>函数类型：function</li>
</ul>
<p><strong>在js中如何去声明一个变量</strong></p>
<p>​	<code>var、let</code>这两个关键字可以去接收一个变量</p>
<p>而且任何变量都可以用这两个关键字接收</p>
<p>var i &#x3D; 100</p>
<p>let str &#x3D; “123456”</p>
<p>关于js中的逻辑运行算（与 &amp;&amp;	或 ||	非 ! ）：</p>
<p>在js中 null、undefined、0 、false参与逻辑运算时本身代表的是false，其余所有的数据都表示true</p>
<p><strong>与运算</strong></p>
<ul>
<li>如果参与&amp;&amp;与运算两者都为真的情况下，会取到后者的值</li>
<li>如果参与&amp;&amp;与运算有一者为假的情况下，会取到为假的那个值</li>
<li>如果参与&amp;&amp;与运算两者都为假的情况下，会取到前者的值</li>
</ul>
<p><strong>或运算</strong></p>
<ul>
<li>如果参与||或运算两者都为真的情况下，会取到前者的值</li>
<li>如果参与||或运算有一者为假的情况下，会取到为真的那个值</li>
<li>如果参与||或运算两者都为假的情况下，会取到后者的值</li>
</ul>
<p><em>都有惰性取值的特点，最后计算完的值返回</em></p>
<p>取非！运算，首先要搞清楚，数据本身是为真还是为假，取非之后，真就是假，假就是真</p>
<h3 id="数组的定义方式"><a href="#数组的定义方式" class="headerlink" title="数组的定义方式"></a>数组的定义方式</h3><p>JS中数组的定义：</p>
<p><strong>格式：</strong></p>
<p><code>var 数组名 = [];</code>&#x2F;&#x2F;空数组</p>
<p><code>var 数组名 = [1,&#39;abc&#39;,true];</code>&#x2F;&#x2F;定义数组同时赋值元素</p>
<p>js数组可以在一个数组中存放任意类型的值</p>
<p>js数组可以给任意一个下标赋值，未赋值的默认为<strong>undefined</strong></p>
<p><strong>遍历数组</strong></p>
<pre><code class="javascript">for (let i = 0;i &lt; array.length; i++)&#123;

    alert(array[i]);

&#125;
</code></pre>
<h3 id="JS对象"><a href="#JS对象" class="headerlink" title="JS对象"></a>JS对象</h3><p>在js中也能new对象，但是必须使用js封装好的对象</p>
<p>通过<code>对象.属性 = 值</code>的方法赋值，属性和值都可以自定义</p>
<pre><code class="javascript">let object = new Object();

object.name = &quot;tom&quot;;
object.age = 15;
object.address = &quot;北京市&quot;;
object.key = &quot;value&quot;;

alert(object.name);
alert(object.age);
alert(object.address);

//正则对象
let regExp = new RegExp();
</code></pre>
<h2 id="函数的两种定义方式"><a href="#函数的两种定义方式" class="headerlink" title="函数的两种定义方式"></a>函数的两种定义方式</h2><ul>
<li><p>function 函数名(形参列表){函数体}</p>
<pre><code class="javascript">function function01(num1,num2)&#123;
    
    let num = num1 + num2;
    
    return num;
    
&#125;
</code></pre>
</li>
<li><p>let  函数名 &#x3D; function(形参列表){函数体}</p>
</li>
</ul>
<pre><code class="javascript">let function02 = function(num1,num2)&#123;
    
    let num = num1 + num2;
    
    return num;
    
&#125;
</code></pre>
<p><strong>注：</strong>js中的函数，在定义参数的时候可以不用写数据类型，参数与参数之间用逗号分割</p>
<p><strong>注：</strong>js中的函数没有返回值类型，在函数体中写完代码之后，有返回值就返回，没有返回值就不用返回</p>
<p><strong>注：</strong>js中的函数是不支持重载的，如果你同时定义了两个同名的函数，下面那个会覆盖上面那个</p>
<p>在JavaScript语言中，定义带有返回值的函数<strong>只需要在函数体内直接使用return语句返回值即可</strong></p>
<p><strong>JS隐式参数</strong></p>
<pre><code class="javascript">//arguments js 中的隐式参数，是一个数组类型，可以去接收所有数据
function function02()&#123;

    alert(arguments[0]);
    alert(arguments[1]);
    alert(arguments[2]);

&#125;

alert(function02(100,true,&quot;hello&quot;));
</code></pre>
<p><strong>简单的数字相加函数</strong></p>
<pre><code class="javascript">let function02 = function(num1,num2) &#123;

       let num = null;

       if ((typeof num1) == &quot;number&quot; &amp;&amp; (typeof num2) == &quot;number&quot;) &#123;

           let num = num1 + num2;

       &#125; else &#123;

           return &quot;你传的数据不合法&quot;;

       &#125;

       return num;
   &#125;
</code></pre>
<h2 id="JS中的事件"><a href="#JS中的事件" class="headerlink" title="JS中的事件"></a>JS中的事件</h2><ul>
<li><strong>onload</strong> 加载完成事件：页面加载完成之后，常用于做页面js代码初始化操作</li>
<li><strong>onclick</strong> 单机事件：常用于按钮的点击响应操作</li>
<li><strong>onblur</strong> 失去焦点事件：常用于输入框失去焦点后验证其输入内容是否合法</li>
<li><strong>onchange</strong> 内容发生改变事件：常用于下拉列表和输入框内容发生改变后操作</li>
<li><strong>onsubmit</strong> 表单提交事件：常用于表单提交前，验证所有表单项是否合法</li>
</ul>
<p><strong>关于js中的事件（分为静态注册和动态注册）：</strong></p>
<p>​	<strong>静态注册</strong>：通过html标签内部的事件属性来完成事件的注册</p>
<pre><code class="javascript">&lt;body onload=&quot;alert(&#39;静态注册页面加载完成事件&#39;)&quot;&gt; &lt;/body&gt;
</code></pre>
<pre><code class="javascript">&lt;!--鼠标单机事件：静态注册--&gt;
&lt;input type=&quot;button&quot; value=&quot;测试鼠标单机事件&quot; onclick=&quot;alert(&#39;鼠标单机事件静态注册&#39;)&quot;&gt;
</code></pre>
<p>​	</p>
<p>​	<strong>动态注册</strong>：先通过dom对象获取到某一个具体的html元素，然后对这个标签进行绑定，注册事件</p>
<p><code>document.getElementById()</code>通过id这个属性查找html元素</p>
<p><strong>注</strong>：动态注册一定要写在<code>script</code>标签中，或者js文件中</p>
<pre><code class="javascript">//页面加载完成事件动态注册
//window是html内置对象
  window.onload = function ()&#123;
      
    //在该函数中完成页面初始化的操作
      
      alert(&quot;动态绑定页面加载完成事件&quot;)

  &#125;
</code></pre>
<p>动态注册单击事件</p>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;JavaScript&lt;/title&gt;
&lt;/head&gt;

&lt;!--定义一个script去写js代码--&gt;
&lt;script type=&quot;text/javascript&quot;&gt;


  //页面加载完成事件动态注册
  //window是html内置对象
    window.onload = function ()&#123;

        alert(&quot;动态绑定页面加载完成事件&quot;)

        //通过动态注册的方式来注册单击事件
        let elementInput = document.getElementById(&quot;onclickTest&quot;);

        //[object HTMLInputElement] dom对象
        alert(elementInput)

        //动态注册单击事件
        elementInput.onclick=function ()&#123;

            alert(&quot;触发了单击事件，动态注册的方式&quot;)

        &#125;
    &#125;


    

&lt;/script&gt;

&lt;!--引入js文件--&gt;
&lt;!--&lt;script type=&quot;text/javascript&quot; src=&quot;../js/test.js&quot;&gt;&lt;/script&gt;--&gt;
&lt;body&gt;

    &lt;!--鼠标单机事件：静态注册--&gt;
    &lt;input type=&quot;button&quot; value=&quot;测试鼠标单机事件(静态)&quot; onclick=&quot;alert(&#39;鼠标单机事件静态注册&#39;)&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;button&quot; value=&quot;测试鼠标单机事件(动态)&quot; id=&quot;onclickTest&quot;&gt;&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>加载完成事件（<strong>onload</strong>）：</p>
<p>​		浏览器在解析html页面的时候是一个标签一个标签的往下解析</p>
<p>​		在浏览器解析完所有的html元素之后会触发的操作</p>
<p>失去焦点事件（<strong>onblur</strong>）</p>
<pre><code class="html">测试鼠标失去焦点事件(静态):&lt;input type=&quot;text&quot; id=&quot;onblur&quot; onblur=&quot;alert(&#39;触发了失去焦点事件&#39;)&quot;&gt;&lt;br&gt;
</code></pre>
<pre><code class="javascript">//动态绑定失去焦点事件
let elementOnblur = document.getElementById(&quot;onblurTest&quot;);

//绑定事件
elementOnblur.onblur = function ()&#123;

    alert(&quot;触发了失去焦点事件，动态注册的方式&quot;);

&#125;
</code></pre>
<p>内容发送改变事件（<strong>onchange</strong>）</p>
<pre><code class="html">测试内容发生改变事件(静态):&lt;input type=&quot;text&quot; value=&quot;123&quot; onchange=&quot;alert(&#39;内容已发生改变&#39;)&quot;&gt;&lt;br&gt;
</code></pre>
<pre><code class="javascript">//内容发生改变事件
let elementSelect = document.getElementById(&quot;onchangeTest&quot;);

//绑定事件
elementSelect.onchange = function ()&#123;

    alert(&quot;内容已发生改变,动态注册的方式&quot;);

&#125;
</code></pre>
<h4 id="关于html的上下文文本对象document"><a href="#关于html的上下文文本对象document" class="headerlink" title="关于html的上下文文本对象document"></a>关于html的上下文文本对象document</h4><p>这个是html内置的对象，通过这个对象可以去获取html对象（标签）</p>
<p>而且获取的方式有很多种（比如：根据id属性获取，根据name属性获取，根据具体的标签名称获取）</p>
<p><strong>DOM模型和document对象</strong></p>
<p><strong>DOM</strong>全称是Document Object Model 文档对象模型</p>
<p><strong>document</strong>对象</p>
<p>1.Document它管理了所有的HTML文档内容</p>
<p>2.document它是一种树结构的文档，有层级关系</p>
<p>3.它让我们把所有的标签都对象化</p>
<p>4.我们可以通过document访问所有的标签对象</p>
<p><strong>Document对象中的方法</strong></p>
<ul>
<li><code>document.getElementById(elementId)</code>通过标签的id属性查找标签dom对象，elementId是标签的id属性值</li>
<li><code>document.getElementsByName(elementName)</code>通过标签的name属性查找标签dom对象，elementName标签的name属性值</li>
<li><code>document.getElementsByTagName(tagname)</code>通过标签名找标签dom对象，tagname是标签名</li>
<li><code>document.createElement(tagName)</code>方法，通过给定的标签名，创建一个标签对象，tagName是要创建的标签名</li>
</ul>
<pre><code class="javascript">//获取所有name属性值为username的标签
let inputEls = document.getElementsByName(&quot;username&quot;);

//[object NodeList]
alert(inputEls);

for (let i = 0; i &lt; inputEls.length; i++) &#123;

    alert(inputEls[i]);

&#125;
</code></pre>
<h5 id="标签的常用属性"><a href="#标签的常用属性" class="headerlink" title="标签的常用属性"></a>标签的常用属性</h5><ul>
<li>childNodes属性，获取当前节点的所有子节点</li>
<li>firstChild属性，获取当前节点的第一个子节点</li>
<li>lastChild属性，获取当前节点的最后一个子节点</li>
<li>parentNode属性，获取当前节点的父节点</li>
<li>nextSibling，获取当前节点的下一个节点</li>
<li>previousSibling属性，获取当前节点的上一个节点</li>
<li>className用于获取或设置标签的class属性值</li>
<li>innerHTML属性，表示获取&#x2F;设置起始标签和结束标签中的内容</li>
<li>innerText属性，表示获取&#x2F;设置起始标签和结束标签中的文本</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/07/javaScript/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/07/06/XML/">
        <h2>
            XML
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/6
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p><strong>什么是xml?</strong></p>
<p>xml是可扩展的标记性语言</p>
<p><strong>xml的作用</strong></p>
<p>xml的主要作用有：</p>
<p>1.用来保存数据，而且这些数据具有自我描述性</p>
<p>2.它还可以作为项目或者模块的配置文件</p>
<p>3.还可以作为网络传输数据的格式</p>
<h2 id="xml语法"><a href="#xml语法" class="headerlink" title="xml语法"></a>xml语法</h2><h3 id="xml命名规则"><a href="#xml命名规则" class="headerlink" title="xml命名规则"></a>xml命名规则</h3><ul>
<li>名称可以含字母、数字以及其他的字符</li>
<li>名称不能以数字或者标点符号开始</li>
<li>名称不能包含空格</li>
</ul>
<p><strong>1.文档声明</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</code></pre>
<p><strong>2.元素（标签）</strong></p>
<p>元素是指开始标签到结束标签的内容</p>
<pre><code class="xml">&lt;!--根标签--&gt;
&lt;students&gt;

    &lt;!--子标签--&gt;
    &lt;student id=&quot;1001&quot;&gt;
        &lt;name&gt;张三&lt;/name&gt;
        &lt;age&gt;25&lt;/age&gt;
        &lt;address&gt;镇江市&lt;/address&gt;
    &lt;/student&gt;

    &lt;!--子标签--&gt;
    &lt;student id=&quot;1002&quot;&gt;
        &lt;name&gt;李四&lt;/name&gt;
        &lt;age&gt;29&lt;/age&gt;
        &lt;address&gt;南京市&lt;/address&gt;
    &lt;/student&gt;

    &lt;!--子标签--&gt;
    &lt;student id=&quot;1003&quot;&gt;
        &lt;name&gt;王五&lt;/name&gt;
        &lt;age&gt;19&lt;/age&gt;
        &lt;address&gt;上海市&lt;/address&gt;
    &lt;/student&gt;

&lt;/students&gt;
</code></pre>
<p><strong>3.xml属性</strong></p>
<p><strong>id属性为1003</strong></p>
<pre><code class="xml">&lt;student id=&quot;1003&quot;&gt;
</code></pre>
<p><strong>4.xml注释</strong></p>
<p> ctrl + shift + &#x2F;</p>
<pre><code class="xml">&lt;!--此处写注释--&gt;
</code></pre>
<h2 id="xml解析技术"><a href="#xml解析技术" class="headerlink" title="xml解析技术"></a>xml解析技术</h2><p>​	xml可扩展的标记语言，不管是html文件还是xml文件它们都是标记型文档，都可以使用w3c组织制定的dom技术来解析</p>
<p>​	document对象表示的是整个文档（可以是html文档，也可以是xml文档）</p>
<p>​		w3c是一个制定规范的组织，针对于xml，html都制定了相关的规范，元素都是以标签的形式体现的，每个标签都是一个对象，而且每个标签都是有层级关系的，w3c通过一种树形图来管理这种关系，而且提供了一个文本对象dom对象，通过这个dom对象可以去获取所有的标签对象</p>
<p><strong>dom解析技术</strong></p>
<ul>
<li><p>dom解析技术是W3C组织制定的，而所有的编程语言都对这个解析技术使用了自己语言的特点进行实现，Java对<strong>dom技术解析</strong>标记也做了实现</p>
</li>
<li><p>sun公司在JDK5版本对dom解析技术进行升级：<strong>SAX</strong>（Simple API for XML） SAX解析，它跟W3C制定的解析不太一样，它是以类似事件机制通过回调告诉用户当前正在解析的内容，它是一行一行的读取xml文件进行解析的，不会创建大量的dom对象，所以它在解析xml的时候，在<strong>内存</strong>的使用上，和<strong>性能</strong>上，都优于Dom解析。</p>
</li>
<li><p>jdom在dom基础上进行了封装</p>
</li>
<li><p>dom4j又对jdom进行了封装</p>
</li>
<li><p>pull主要用在Android手机开发，实在跟sax非常类似都是事件机制解析xml文件</p>
</li>
</ul>
<h2 id="Dom4j"><a href="#Dom4j" class="headerlink" title="Dom4j"></a>Dom4j</h2><ul>
<li>Dom4j是第三方的解析技术，我们需要使用第三方给我们提供好的类库才可以解析xml文件</li>
<li></li>
<li>由于dom4j它不是sun公司的技术，而属于第三方公司的技术，需要使用dom4j就需要到dom4j官网下载dom4j的jar包</li>
</ul>
<h3 id="dom4j编程步骤"><a href="#dom4j编程步骤" class="headerlink" title="dom4j编程步骤"></a>dom4j编程步骤</h3><p>1.先加载xml文件创建Document对象</p>
<p>2.通过Document对象拿到根元素对象 <code>getRootElement()</code></p>
<p>3.通过<code>根元素.elements(标签名)</code>；可以返回一个集合，这个集合里放着。所有你指定的标签名的元素对象</p>
<p>4.找到你想要修改、删除的子元素，进行相应的操作</p>
<p>5.保存到硬盘上</p>
<p>将xml文件内容解析封装为java对象</p>
<pre><code class="java">package com.os467.xml;

import com.os467.beans.Student;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.util.ArrayList;
import java.util.List;

public class Dom4jTest &#123;

    public static void main(String[] args) &#123;

        try &#123;
            //创建流对象
            SAXReader saxReader = new SAXReader();

            //通过流对象读取xml文件，然后返回document对象
            Document document = saxReader.read(&quot;src/xml/test.xml&quot;);

            //通过document获取到根标签
            Element rootElement = document.getRootElement();

            //获取根标签中所有的子标签对象
            List&lt;Element&gt; elements = rootElement.elements(&quot;student&quot;);

            //创建集合对象
            List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();

            //遍历集合
            for (Element element : elements) &#123;

                //获取子标签中的数据
                String name = element.elementText(&quot;name&quot;);
                String age = element.elementText(&quot;age&quot;);
                String address = element.elementText(&quot;address&quot;);
                

                //将这些数据封装成java对象
                Student student = new Student(name, Integer.parseInt(age), address);

                //将这些对象添加到集合中
                studentList.add(student);


            &#125;

            for (Student student : studentList) &#123;

                System.out.println(student);

            &#125;

        &#125; catch (DocumentException e) &#123;
            e.printStackTrace();
        &#125;


    &#125;

&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/07/06/XML/" class="go-post">
        阅读全文
    </a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <svg class="fa-icon"><use xlink:href="#caret-right-solid"></use></svg>
            </span>
        </a>
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://img.gejiba.com/images/ad7295b88b395d72d985a0835695dd71.jpg " alt="avatar">
        </div>
        <div class="name">
            Os467
        </div>
        <div class="descriptions">
            
            <div class="description">
                Description...
            </div>
            
        </div>
        <div class="icon-links">
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2022 Tly的博客
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Os467
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>